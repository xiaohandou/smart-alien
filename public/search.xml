<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在阿里云Centos上配置Nginx+uwsgi+负载均衡配置</title>
      <link href="/2020/07/22/Note/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2020/07/22/Note/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>负载均衡的目的是为了解决单个节点压力过大，造成Web服务响应过慢，严重的情况下导致服务瘫痪，无法正常提供服务。<strong>春节期间在12306网站上买过火车票的朋友应该深有体会，有时查询一张火车票都会很慢，甚至整个网页都卡住不动了。通常一个访问量非常大的Web网站（比如：淘宝、京东、12306等），由于一个Web服务同时能处理的用户并发请求的数量有限，同时还有机器故障的情况，所以一个Web站点通常会在N台机器上各部署一套同样的程序。当某一个服务挂掉的时候，还有第二个、第三个、第N个服务。。。继续为用户提供服务，给用户的感觉，你的服务还在正常的运行！</strong>在这些提供同样服务的机器当中，在硬件配置方面也各不一样，这样就会存在部份机器性能非常好，能快速计算并响应用户的请求，另外一部份机器可能配置差点，响应用户的请求的时间会长一些。这就需要我们思考一个问题？如果有一个服务正在同时处理1000个用户的请求，这个服务的上限可能最多能同时处理1000个用户的请求，这时它已经很忙了，如果此时又有一个新请求过来，我们仍然把这个请求分配给这台机器，这时候这个请求就只能在干等着，等这个服务处理完那些请求后，再继续处理它。这样在浏览器中的反应就像12306我们在春节买票一样，卡在那不动了，让用户眼巴巴的干着急。而能提供同样服务的其它机器，这时确很空闲。这样不仅是对服务器资源的浪费，也充分发挥不出弄多台服务器装同一个服务的最高价值。我们通常称对某一台机器的访问量称为负载量，如何将一个用户的请求，合理的分配到一台能快速响应用户请求的服务器上，我们就需要用到一些负载策略。也就体现出了文章主题的用意了：<strong>负载均衡，将用户的所有HTTP请求均衡的分配到每一台机器上，充分发挥所有机器的性能，提高服务的质量和用户体验。负载均衡可以通过负载均衡网络硬件设备和Web服务器软件来实现，前者设备成本较高，小公司通常负担不起，所以后者一般是我们的首选</strong>。<em>实现负载均衡常用的Web服务器软件有Nginx、HAProxy、LVS、Apache，本文主要介绍Nginx的负载均衡策略，至于Nginx是干嘛的，自行百度。</em></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>言归正传，关于在阿里云Centos上配置Nginx+uwsgi+负载均衡配置</strong>，网上一查一大堆，主要内容那是千篇一律</p><ol><li><p>先上张图，了解什么是nginx负载均衡</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/fuzai1.png" alt="fuzai"></p></li><li><p>其实配置起来非常简单，利用wsgi在不同端口上起两个服务，然后修改ngin网站配置，命令如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure></li><li><p>将原来的uwsgi_pass注释，改为变量进行绑定</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>      /root/myweb_access.log;</span><br><span class="line">    <span class="attribute">error_log</span>       /root/myweb_error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">75M</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">        <span class="comment">#uwsgi_pass 127.0.0.1:8000;</span></span><br><span class="line">        <span class="attribute">uwsgi_pass</span> mytest;</span><br><span class="line">        <span class="attribute">uwsgi_param</span> UWSGI_SCRIPT mypro.wsgi;</span><br><span class="line">        <span class="attribute">uwsgi_param</span> UWSGI_CHDIR  /root/mypro;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/mypro/static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之后修改主配置文件，在http配置内添加负载均衡配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> mytest &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8002</span>;  <span class="comment">#负载均衡服务器群</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8003</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后重启服务即可</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl</span> restart nginx.service</span><br></pre></td></tr></table></figure></li></ol><h3 id="内置负载均衡策略"><a href="#内置负载均衡策略" class="headerlink" title="内置负载均衡策略"></a>内置负载均衡策略</h3><p><strong>来源于网络</strong></p><p>Nginx负载均衡是通过upstream模块来实现的，内置实现了三种负载策略，配置还是比较简单的。官网负载均衡配置说明：<a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/load_balancing.html</a></p><ul><li>轮循（默认）<br>Nginx根据请求次数，将每个请求均匀分配到每台服务器</li><li>最少连接<br>将请求分配给连接数最少的服务器。Nginx会统计哪些服务器的连接数最少。</li><li>IP Hash<br>绑定处理请求的服务器。第一次请求时，根据该客户端的IP算出一个HASH值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过HASH算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。</li></ul><ol><li><p>轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.14</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>weight</p><p>默认为1，将请求平均分配给每台server</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span>;  <span class="comment"># 2/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;  <span class="comment"># 3/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;  <span class="comment"># 1/6次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例配置，表示6次请求中，100分配2次，101分配3次，102分配1次</p></li><li><p>max_fails</p><p>默认为1。某台Server允许请求失败的次数，超过最大次数后，在fail_timeout时间内，新的请求将不会分配给这台机器。如果设置为0，Nginx会将这台Server置为永久无效状态，然后将请求发给定义了proxy_next_upstream, fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, and memcached_next_upstream指令来处理这次错误的请求。</p></li><li><p>fail_timeout</p><p>默认为10秒。某台Server达到max_fails次失败请求后，在fail_timeout期间内，nginx会认为这台Server暂时不可用，不会将请求分配给它</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>192.168.0.100这台机器，如果有3次请求失败，nginx在15秒内，不会将新的请求分配给它。</p></li><li><p>backup备份机，所有服务器挂了之后才会生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   在100和101都挂了之前，102为不可用状态，不会将请求分配给它。只有当100和101都挂了，102才会被启用。</p><ol start="6"><li><p>down</p><p>标识某一台server不可用。可能能通过某些参数动态的激活它吧，要不真没啥用。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> down;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   表示101这台Server为无效状态，不会将请求分配给它。</p><ol start="7"><li><p>max_conns</p><p>限制分配给某台Server处理的最大连接数量，超过这个数量，将不会分配新的连接给它。默认为0，表示不限制。注意：1.5.9之后的版本才有这个配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> max_conns=<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示最多给100这台Server分配1000个请求，如果这台Server正在处理1000个请求，nginx将不会分配新的请求给到它。假如有一个请求处理完了，还剩下999个请求在处理，这时nginx也会将新的请求分配给它。</p></li><li><p>resolve</p><p>将server指令配置的域名，指定域名解析服务器。需要在http模块下配置resolver指令，指定域名解析服务</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">10.0.0.1</span>;</span><br><span class="line">    <span class="attribute">upstream</span> u &#123;</span><br><span class="line">        <span class="attribute">zone</span> ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">server</span> example.com resolve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第三方负载策略"><a href="#第三方负载策略" class="headerlink" title="第三方负载策略"></a>第三方负载策略</h3><p><strong>来源于网络</strong></p><ol><li><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>根据服务器的响应时间来分配请求，响应时间短的优先分配，即负载压力小的优先会分配。</p><p>由于fair模块是第三方提供的，所以在编译nginx源码的时候，需要将fair添加到nginx模块中。</p><p><code>假设我的nginx是通过源码安装的，安装在/opt/nginx目录下，而且安装时没有添加fair模块</code></p><ul><li><p>下载fair模块<a href="https://github.com/xyang0917/nginx-upstream-fair" target="_blank" rel="noopener">源码</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /opt</span><br><span class="line">wget https://github.com/xyang0917/nginx-upstream-fair/archive/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p><strong>解压后的目录名为：nginx-upstream-fair-master</strong></p></li><li><p>重新编译nginx，将fair模块添加到编译参数，我的nginx源码目录在/opt/nginx-1.10.0</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /opt/nginx-nginx-<span class="number">1</span>.<span class="number">10</span>.<span class="number">0</span></span><br><span class="line">./configure --prefix=/opt/nginx --add-module=/opt/nginx-upstream-fair-master</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>不要执行make install，这样会覆盖之前nginx的配置</p></li><li><p>将新编译的nginx可执行程序拷贝到/opt/nginx/sbin/目录下，覆盖之前安装的nginx，编译后的nginx执行程序，放在nginx源码的objs目录下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | grep nginx</span><br><span class="line">kill -<span class="number">9</span> nginx进程ID  <span class="comment"># 停止nginx服务</span></span><br><span class="line">cp /opt/nginx-<span class="number">1</span>.<span class="number">10</span>.<span class="number">0</span>/objs/nginx /opt/nginx/sbin/  <span class="comment"># 覆盖旧的nginx</span></span><br><span class="line">nginx <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure></li><li><p>配置使用fair负载策略模块</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    fair;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于采用fair负载策略，配置weigth参数改变负载权重将无效。</strong></p></li></ul></li><li><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，服务器做缓存时比较有效。</p><p>1.7.2版本以后，url_hash模块已经集成到了nginx源码当中，不需要单独安装。之前的版本仍需要单独安装，<a href="https://github.com/evanmiller/nginx_upstream_hash" target="_blank" rel="noopener">下载地址</a><br>安装方法和fair模块一样，先下载url_hash源码，然后重新编译nginx源码，将url_hash模块添加到编译配置参数当中，最后将编译后生成的nginx二进制文件替换之前安装的nginx二进制文件即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用DockerHub在Centos7.6环境下部署Nginx反向代理Gunicorn+Flask独立架构</title>
      <link href="/2020/07/21/Blog/aliyun%E9%83%A8%E7%BD%B2flask/"/>
      <url>/2020/07/21/Blog/aliyun%E9%83%A8%E7%BD%B2flask/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>书接上回，上回说到</strong>，<a href="https://www.sirxs.cn/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/">在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</a>，今天我们来讲一讲利用DockerHub在Centos7.6环境下部署Nginx反向代理Gunicorn+Flask独立架构</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>首先你需要有自己的云服务。我推荐白嫖</p><p><a href="https://free.aliyun.com/?spm=5176.14145661.J_3598540520.ace-channel-latest-activity-card.3eb418759BoljH" target="_blank" rel="noopener">https://free.aliyun.com/?spm=5176.14145661.J_3598540520.ace-channel-latest-activity-card.3eb418759BoljH</a></p><p>阿里云白嫖服务器</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu.png" alt="docker"></p></li><li><p>其次你需要将本地项目<code>push</code>到DockerHub(仓库)</p><ul><li><p>首先激活账号，创建仓库</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu1.png" alt="docker"></p><p><strong>这里的创建仓库与Github类似</strong></p></li><li><p>填写仓库信息具体为仓库名称、描述以及是否公开或者私有。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu2.png" alt="docker"></p></li><li><p>创建成功之后，它就会出现在镜像列表中</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu3.png" alt="docker"></p></li></ul></li><li><p>此时我们需要对本地的镜像重命名，这里重命名为herosir/flask_back。因为要与dockerhub上的仓库对应。如果名称不对应是无法将本地镜像push到线上仓库中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag myflask herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu4.png" alt="docker"></p></li><li><p>之后在命令行输入命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li><p>用DockerHub的账号和密码登录</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu5.png" alt="docker"></p></li><li><p>登录成功之后，用命令把本地镜像push到DockerHub中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>注意这里的镜像名称必须和hub中的仓库名称一致，否则将会抛出错误。</p></li><li><p>上传成功后，就可以在DockerHub中看到它了，此时就能随意pull操作了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu6.png" alt="docker"></p></li></ol><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol><li><p>前置操作已经完毕，此时，登录你的云服务器，这里以阿里云的Centos7.6为例子，进入服务器后安装Docker服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#升级yum</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#卸载旧版本docker</span></span><br><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment">#设置源</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum makecache fast</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>安装完成后输入 docker -v</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu7.png" alt="docker"></p><p><em>返回Docker版本号说明没有问题</em></p></li><li><p>拉取我们之前打包并且上传到hub的Flask镜像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>下载成功后，会展示在镜像库里</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu8.png" alt="docker"></p></li><li><p>运行项目，这里我们可以采用后台守护进程的模式起服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> --name testflask herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>使用docker ps命令可以看到是否运行成功。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu9.png" alt="docker"></p></li><li><p>使用服务器的ip访问一下Flask服务，这里有个小坑，不论是腾讯云、阿里云还是百度云亦或是各种乱七八糟的云，都需要在安全组策略中开放你需要访问的端口，比如这里我用的阿里云。</p><ul><li><p>解决安群组策略</p></li><li><p>找到服务器的<code>配置规则</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu10.png" alt="docker"></p></li><li><p><code>手动添加</code>下图信息</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu11.png" alt="docker"></p></li></ul></li><li><p>设置完成之后通过服务器<code>公网IP</code>进行访问</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu12.png" alt="docker"></p><p>OK，访问没有问题</p></li><li><p>接下来，我们同样利用Docker来安装Nginx服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>随后启动Nginx测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><ul><li><p>这里也需要设置安群组</p><p>操作同上，内容如下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu13.png" alt="docker"></p></li></ul></li><li><p>直接访问<code>公网IP</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu14.png" alt="docker"></p></li><li><p>现在，我们将运行Nginx容器里的配置文件copy到宿主机里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:/etc/nginx/conf.d/default.conf /root/default.conf</span><br></pre></td></tr></table></figure><p><strong>前面是容器的路径 后面是宿主机的路径</strong></p><p><em>容器id可以通过docker ps命令查看</em></p></li><li><p>复制出来之后，输入命令修改这个nginx配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/default.conf</span><br></pre></td></tr></table></figure></li><li><p>将Gunicorn配置加到里面(<strong>更改</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    listen  [::]:<span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://你的服务器公网IP:<span class="number">5000</span>; <span class="comment"># 这里是指向 gunicorn host 的服务地址</span></span><br><span class="line"></span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改完配置文件之后，关掉运行的nginx服务容器，并且删掉它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li><li><p>随后再次启动Nginx容器，不过这次和上次不同之处就是需要用到 -v 进行挂载了，挂载简单理解就是将宿主机的文件替换Docker容器内部的文件，达到修改的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d -p <span class="number">80</span>:<span class="number">80</span> -v /root/default.conf:/etc/nginx/conf.d/default.conf nginx</span><br></pre></td></tr></table></figure><p><strong>这里-v参数也遵循冒号左侧为宿主机右侧为容器的原则。</strong></p></li><li><p>新启动成功后，访问服务器ip</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu15.png" alt="docker"></p><p><strong>OK，部署完成</strong></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>部署完成，轻松且愉快</p><p>最后Dockerhub地址：<a href="https://hub.docker.com/r/herosir/flask_back" target="_blank" rel="noopener">https://hub.docker.com/r/herosir/flask_back</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</title>
      <link href="/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>书接上回，上回说到</strong>，<a href="https://www.sirxs.cn/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/">Windows下安装docker</a>，今天我们来讲一讲将本地项目打包到docker</p><h4 id="什么是docker镜像"><a href="#什么是docker镜像" class="headerlink" title="什么是docker镜像"></a>什么是docker镜像</h4><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p><p>回到正题，Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ol><li><p>首先我们先看下项目的整体结构</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx.png" alt="docker"></p></li><li><p><code>manage.py</code>是项目入口文件</p><p><strong>此项目地址：<a href="https://gitee.com/wangxs020202/flask/tree/wxs/" target="_blank" rel="noopener">https://gitee.com/wangxs020202/flask/tree/wxs/</a></strong></p></li><li><p>接下里我们使用Gunicorn+gevent来运行Flask项目</p></li><li><p>安装相应的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn gevent --user</span><br></pre></td></tr></table></figure></li><li><p>编辑项目目录下的gunicorn.conf.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers = <span class="number">3</span>    <span class="comment"># 进程数</span></span><br><span class="line">worker_class = <span class="string">"gevent"</span>   <span class="comment"># 异步模式</span></span><br><span class="line">bind = <span class="string">"0.0.0.0:5000"</span></span><br></pre></td></tr></table></figure></li><li><p>由于Gunicorn并不支持Windows环境，所以只需要写好配置，不需要运行。</p></li><li><p>编辑项目目录下的requirements.txt文件，这里面都是我们项目所依赖的库</p><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>导出<code>pip list</code>并生成<code>requirements.txt</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">alembic==<span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">aliyun-python-sdk-core==<span class="number">2.13</span><span class="number">.15</span></span><br><span class="line">autobahn==<span class="number">20.4</span><span class="number">.3</span></span><br><span class="line">Automat==<span class="number">0.8</span><span class="number">.0</span></span><br><span class="line">bcrypt==<span class="number">3.1</span><span class="number">.7</span></span><br><span class="line">billiard==<span class="number">3.6</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line">celery==<span class="number">4.4</span><span class="number">.2</span></span><br><span class="line">certifi==<span class="number">2019.9</span><span class="number">.11</span></span><br><span class="line">cffi==<span class="number">1.12</span><span class="number">.3</span></span><br><span class="line">channels==<span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">chardet==<span class="number">3.0</span><span class="number">.4</span></span><br><span class="line">Click==<span class="number">7.0</span></span><br><span class="line">constantly==<span class="number">15.1</span><span class="number">.0</span></span><br><span class="line">cryptography==<span class="number">2.8</span></span><br><span class="line">daphne==<span class="number">2.5</span><span class="number">.0</span></span><br><span class="line">dnspython==<span class="number">1.16</span><span class="number">.0</span></span><br><span class="line">dwebsocket==<span class="number">0.5</span><span class="number">.12</span></span><br><span class="line">eventlet==<span class="number">0.25</span><span class="number">.2</span></span><br><span class="line">Flask==<span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">Flask-Cors==<span class="number">3.0</span><span class="number">.8</span></span><br><span class="line">Flask-Migrate==<span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">Flask-MySQLdb==<span class="number">0.2</span><span class="number">.0</span></span><br><span class="line">Flask-Script==<span class="number">2.0</span><span class="number">.6</span></span><br><span class="line">Flask-SocketIO==<span class="number">4.3</span><span class="number">.0</span></span><br><span class="line">Flask-SQLAlchemy==<span class="number">2.4</span><span class="number">.1</span></span><br><span class="line">Flask-Uploads==<span class="number">0.2</span><span class="number">.1</span></span><br><span class="line">gevent==<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">greenlet==<span class="number">0.4</span><span class="number">.15</span></span><br><span class="line">gunicorn==<span class="number">20.0</span><span class="number">.4</span></span><br><span class="line">html5lib==<span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">hyperlink==<span class="number">19.0</span><span class="number">.0</span></span><br><span class="line">idna==<span class="number">2.8</span></span><br><span class="line">importlib-metadata==<span class="number">1.6</span><span class="number">.0</span></span><br><span class="line">incremental==<span class="number">17.5</span><span class="number">.0</span></span><br><span class="line">itsdangerous==<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">jmespath==<span class="number">0.9</span><span class="number">.5</span></span><br><span class="line">jsonify==<span class="number">0.5</span></span><br><span class="line">monotonic==<span class="number">1.5</span></span><br><span class="line">mysqlclient==<span class="number">1.4</span><span class="number">.4</span></span><br><span class="line">npm==<span class="number">0.1</span><span class="number">.1</span></span><br><span class="line">numpy==<span class="number">1.18</span><span class="number">.1</span></span><br><span class="line">opencv-contrib-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br><span class="line">opencv-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br><span class="line">optional-django==<span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">paramiko==<span class="number">2.7</span><span class="number">.1</span></span><br><span class="line">paypalrestsdk==<span class="number">1.13</span><span class="number">.1</span></span><br><span class="line">pbr==<span class="number">5.4</span><span class="number">.3</span></span><br><span class="line">pdfminer3k==<span class="number">1.3</span><span class="number">.4</span></span><br><span class="line">Pillow==<span class="number">6.2</span><span class="number">.1</span></span><br><span class="line">ply==<span class="number">3.11</span></span><br><span class="line">pyasn1==<span class="number">0.4</span><span class="number">.8</span></span><br><span class="line">pyasn1-modules==<span class="number">0.2</span><span class="number">.8</span></span><br><span class="line">pycodestyle==<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">pycparser==<span class="number">2.19</span></span><br><span class="line">pycryptodome==<span class="number">3.9</span><span class="number">.7</span></span><br><span class="line">pycryptodomex==<span class="number">3.9</span><span class="number">.4</span></span><br><span class="line">PyHamcrest==<span class="number">1.9</span><span class="number">.0</span></span><br><span class="line">PyJWT==<span class="number">1.7</span><span class="number">.1</span></span><br><span class="line">pymongo==<span class="number">3.10</span><span class="number">.1</span></span><br><span class="line">PyMySQL==<span class="number">0.9</span><span class="number">.3</span></span><br><span class="line">PyNaCl==<span class="number">1.3</span><span class="number">.0</span></span><br><span class="line">pyOpenSSL==<span class="number">19.1</span><span class="number">.0</span></span><br><span class="line">pysnowflake==<span class="number">0.1</span><span class="number">.3</span></span><br><span class="line">python-alipay-sdk==<span class="number">2.0</span><span class="number">.1</span></span><br><span class="line">python-dateutil==<span class="number">2.8</span><span class="number">.0</span></span><br><span class="line">python-docx==<span class="number">0.8</span><span class="number">.10</span></span><br><span class="line">python-editor==<span class="number">1.0</span><span class="number">.4</span></span><br><span class="line">python-engineio==<span class="number">3.13</span><span class="number">.0</span></span><br><span class="line">python-socketio==<span class="number">4.6</span><span class="number">.0</span></span><br><span class="line">qiniu==<span class="number">7.2</span><span class="number">.8</span></span><br><span class="line">redis==<span class="number">3.3</span><span class="number">.11</span></span><br><span class="line">requests==<span class="number">2.22</span><span class="number">.0</span></span><br><span class="line">selenium==<span class="number">3.141</span><span class="number">.0</span></span><br><span class="line">service-identity==<span class="number">18.1</span><span class="number">.0</span></span><br><span class="line">soupsieve==<span class="number">1.9</span><span class="number">.5</span></span><br><span class="line">SQLAlchemy==<span class="number">1.3</span><span class="number">.10</span></span><br><span class="line">sqlparse==<span class="number">0.3</span><span class="number">.1</span></span><br><span class="line">stevedore==<span class="number">1.31</span><span class="number">.0</span></span><br><span class="line">tornado==<span class="number">6.0</span><span class="number">.4</span></span><br><span class="line">Twisted==<span class="number">20.3</span><span class="number">.0</span></span><br><span class="line">txaio==<span class="number">20.4</span><span class="number">.1</span></span><br><span class="line">upyun==<span class="number">2.5</span><span class="number">.5</span></span><br><span class="line">urllib3==<span class="number">1.25</span><span class="number">.6</span></span><br><span class="line">vine==<span class="number">1.3</span><span class="number">.0</span></span><br><span class="line">virtualenv==<span class="number">16.7</span><span class="number">.7</span></span><br><span class="line">virtualenv-clone==<span class="number">0.5</span><span class="number">.3</span></span><br><span class="line">virtualenvwrapper==<span class="number">4.8</span><span class="number">.4</span></span><br><span class="line">virtualenvwrapper-win==<span class="number">1.2</span><span class="number">.5</span></span><br><span class="line">webencodings==<span class="number">0.5</span><span class="number">.1</span></span><br><span class="line">Werkzeug==<span class="number">0.16</span><span class="number">.0</span></span><br><span class="line">Whoosh==<span class="number">2.7</span><span class="number">.4</span></span><br><span class="line">yapf==<span class="number">0.30</span><span class="number">.0</span></span><br><span class="line">zipp==<span class="number">3.1</span><span class="number">.0</span></span><br><span class="line">zope.interface==<span class="number">4.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><strong>由于只需要本项目的包，大家可以酌情删除多余的包</strong></p></li><li><p>随后在项目目录下创建一个 Dockerfile 文件，这个文件可以理解为打包镜像的脚本，你需要这个镜像做什么，就把任务写到脚本中，Docker通过执行这个脚本来打包镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /Project/flask_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"gunicorn"</span>, <span class="string">"manage:app"</span>, <span class="string">"-c"</span>, <span class="string">"./gunicorn.conf.py"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到，我们项目的镜像首先基于python3.6这个基础镜像，然后声明项目目录在/Project/flask_back中，拷贝依赖表，之后安装相应的依赖，这里在安装过程中我们指定了国内的源用来提高打包速度，最后利用gunicorn运行项目，值得一提的是，ENV LANG C.UTF-8是为了声明Docker内部环境中的编码，防止中文乱码问题。</p></li><li><p>最后我们就可以愉快的打包整个项目了，在项目根目录下执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="string">'flask_back'</span> .</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx2.png" alt="docker"></p><p><strong>这里一定要指定Docker的下载源，否则速度会非常缓慢，打包好的镜像文件大概有1g左右。</strong></p></li><li><p>下载结束之后，可以看到myflask这个镜像已经静静躺在镜像库中了，运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx3.png" alt="docker"></p><p>我们可以看到<code>flask_back</code>以及打包成功</p></li><li><p>然后我们就可以利用这个镜像来通过容器跑Flask项目了，运行命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p <span class="number">5000</span>:<span class="number">5000</span> flask_back</span><br></pre></td></tr></table></figure></li><li><p>我们可以看到docker内部的端口5000映射到宿主机的5000端口上</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx4.png" alt="docker"></p></li><li><p>通过网址访问一下，这里注意一点，就是Windows系统下，访问Docker容器需要通过分配的ip来访问，而不是我们常用的localhost。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx5.png" alt="docker"></p></li><li><p>接下来我们启动本地<code>flask</code>项目与<code>docker</code>内部镜像对比</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx7.png" alt="docker"></p></li><li><p>对比</p><ul><li><p>docker</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx6.png" alt="docker"></p></li><li><p>本地</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx8.png" alt="docker"></p></li></ul></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>可以看到启动docker与本地项目并不会影响</strong></p><p>到这里我们的 Docker+Flask + Gunicorn就部署完毕了，将这个镜像上传Dockerhub仓库，在任何时间、任何地点、任何系统上，只要连着网、只要我们想，就都可以在短短1分钟之内部署好我们的项目，这就是Docker技术对开发人员最好的馈赠。</p><p>下期<code>利用DockerHub在Centos7.7环境下部署Nginx反向代理Gunicorn+Flask独立架构</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装docker</title>
      <link href="/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.so.com/doc/8850626-9175652.html" target="_blank" rel="noopener">Docker</a> 是一个<a href="https://baike.so.com/doc/4975645-27166090.html" target="_blank" rel="noopener">开源</a>的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a>   并遵从 Apache2.0 协议开源，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.so.com/doc/5349227-5584683.html" target="_blank" rel="noopener">Linux</a>或Windows 机器上，也可以实现<a href="https://baike.so.com/doc/2617474-2763805.html" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.so.com/doc/5888674-6101559.html" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h3 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>首先我们需要下载<code>Git</code>，Git大家应该都有，非常好用的一款<code>开源</code>的分布式版本控制系统，如果没有我们后期会出安装教程。</p></li><li><p>紧接着下载<code>Docker</code>安装包，这个我已经下载好，并传上了百度网盘。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker1.png" alt="docker"></p><p><strong>大家可以拉下：链接: <a href="https://pan.baidu.com/s/1TC8YLrUsS5JhlmOih8Cl5A" target="_blank" rel="noopener">https://pan.baidu.com/s/1TC8YLrUsS5JhlmOih8Cl5A</a> 提取码: zph1</strong></p></li><li><p>接下来打开压缩包，点击安装包</p><p><strong>切记安装的时候一定要断掉网络</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker2.png" alt="docker"></p></li><li><p>进入安装页面，取消勾选项，点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker3.png" alt="docker"></p></li><li><p>选择安装路径，点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker4.png" alt="docker"></p></li><li><p>取消勾选项</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker5.png" alt="docker"></p></li><li><p>直接点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker6.png" alt="docker"></p></li><li><p>点击<code>Install</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker7.png" alt="docker"></p></li><li><p>安装成功，会给你安装两个软件</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker8.png" alt="docker"></p><p><strong>Oracle VM VirtualBox 是一个虚拟机，不会影响使用，但是必须得</strong></p></li><li><p>之后进入你的<code>Git</code>bin目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker9.png" alt="docker"></p><p><strong>复制路径</strong></p></li><li><p>鼠标右键<code>Docker Quickstart Terminal</code>，点击<code>属性</code>,<code>图一</code>,将复制的路径更换到此地方<code>图二</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker10.png" alt="docker"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker11.png" alt="docker"></p></li><li><p>之后解压<code>DockerToolbox-18.01.0-ce.exe</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker12.png" alt="docker"></p></li><li><p>将解压下来的文件放到下面的路径中</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker13.png" alt="docker"></p></li><li><p>之后进入<code>Docker</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker14.png" alt="docker"></p><p><strong>第一次加载是很慢的</strong></p></li><li><p>出现这个小鲸鱼说明启动成功了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker15.png" alt="docker"></p></li><li><p>进入虚拟机，可以看见一个任务正在运行</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker16.png" alt="docker"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>docker安装非常简单的，前面断网的原因是他在运行时会自动下载<code>DockerToolbox-18.01.0-ce.exe</code>这个文件，这个文件非常大的，所以直接断网。明天发<code>在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Git Bash实现Git代码上传加密</title>
      <link href="/2020/07/15/Note/Gitbash/"/>
      <url>/2020/07/15/Note/Gitbash/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>以前我都是在<a href="https://gitee.com/" target="_blank" rel="noopener">gitee</a>上上传本地项目，今天新创建了一个vue项目，突发奇想，想上传<a href="https://github.com/" target="_blank" rel="noopener">github</a>,觉得和gitee差不多，很好实现。谁知道在坑无数啊</p><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ol><li><p>这个博客就是在github上部署的，先前用gitbash生成的<code>id_rsa</code>用到了这个上面，然后我就再次使用gitbash生成了新的<code>id_rsa</code>（由此处去坑）</p></li><li><p>在我把新的<code>id_rsa</code>上传的新项目的时候，推送代码的时候出现了错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to ***** denied to deploy key</span><br></pre></td></tr></table></figure><p><strong>实在头疼</strong></p></li><li><p>然后在网上找问题。。。</p></li><li><p>最后将博客下的<code>ssh key</code> 放的用户下就ok了</p></li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p>首先我们需查看本地是否以生成<code>id_rsa</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash.png" alt=""></p></li><li><p>如果没有使用<code>Git Bash 进入 ssh 目录</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>查看自己的github上上传的邮箱</p><p><a href="https://github.com/settings/emails" target="_blank" rel="noopener">https://github.com/settings/emails</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash2.png" alt=""></p></li><li><p>粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span></span><br></pre></td></tr></table></figure><p>这将创建以所提供的电子邮件地址为标签的新 SSH 密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Generating public/private rsa key pair.</span></span><br></pre></td></tr></table></figure></li><li><p>提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</span></span><br></pre></td></tr></table></figure></li><li><p>在提示时输入安全密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter same passphrase again: [Type passphrase again]</span></span><br></pre></td></tr></table></figure></li><li><p>之后查看本地是否生成<code>id_rsa</code>，文本编辑器打开公钥 <code>id_rsa.pub</code> 复制内容，添加到 Github setting。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash3.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash4.png" alt=""></p></li><li><p>完成上述进本已将完成，剩下的就是线上仓库与本地建立联系，推送了。</p></li><li><p>每次推送需要输入我们当时设置的密码<strong>如何解决？？</strong></p></li><li><p>git bash 进入你的项目目录，输入： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>然后你会在你本地生成一个文本，上边记录你的账号和密码。当然这些你可以不用关心。 然后你使用上述的命令配置好之后，再操作一次 git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本次踩坑实属对Git的理解还是太浅。。。。</p><p><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git菜鸟</a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB 导入Json和Bson</title>
      <link href="/2020/07/14/Note/7.14/"/>
      <url>/2020/07/14/Note/7.14/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>在很久以前，我们学习了MongoDB的安装与一些简单的命令。<a href="https://www.sirxs.cn/2020/06/04/Note/MongoDB/">MongoDB与相关命令</a>，点击此处跳转。</p><p>我们知道MongoDB可以导出数据为JSON和BSON。BSON是一种特殊的JSON文件，又称为Binary JSON。我们想导入到另一个MongoDB的数据库里时怎么处理呢。</p><p>今天我们就来说一说MongoDB 如何导入Json和Bson。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li><p>首先，我们需要进入MongoDB的<code>bin</code>目录下，直接输入<code>cmd</code>进入终端窗口</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon.png" alt="mon"></p></li><li><p>紧接着，在终端窗口输入下面的代码</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon2.png" alt="mon"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux下可以使用：mongorestore -d &lt;db_name&gt; &lt;bson_folder&gt;</span><br><span class="line">windows下可以使用：mongorestore.exe -d &lt;db_name&gt; &lt;bson_folder&gt;</span><br><span class="line"><span class="comment">#db_name：数据库名</span></span><br><span class="line"><span class="comment">#bson_folder：bson或json文件路径</span></span><br></pre></td></tr></table></figure></li><li><p>之后进入终端窗口，进入<code>MongoDB</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon3.png" alt="mon"></p></li><li><p>进入<code>mongo</code>之后，输入<code>show dbs</code>，查看以有的数据库</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon4.png" alt="mon"></p><p><strong>可以看到我们已经导入的数据库</strong></p></li><li><p>紧接着进入导入的数据库，并查询所有表</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon5.png" alt="mon"></p></li><li><p>最后查询这个表</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon6.png" alt="mon"></p><p><strong>可以看到我们导入的数据都出现了</strong></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>MongoDB</strong>作为是一种<a href="https://zh.wikipedia.org/wiki/面向文檔的數據庫" target="_blank" rel="noopener">面向文档</a>的<a href="https://zh.wikipedia.org/wiki/数据库管理系统" target="_blank" rel="noopener">数据库管理系统</a>，用<a href="https://zh.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>等语言撰写而成，在我们遇到存储大量的数据是会是很好的数据库，以解决应用程序开发社区中的大量现实问题。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过高德API和Python3实现通过IP获取地区</title>
      <link href="/2020/07/13/Blog/ip%E6%9F%A5%E5%9C%B0%E5%8C%BA/"/>
      <url>/2020/07/13/Blog/ip%E6%9F%A5%E5%9C%B0%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://zh.wikipedia.org/wiki/高德地圖" target="_blank" rel="noopener">高德地图</a>，是中国领先的<a href="https://baike.baidu.com/item/数字地图/10689386" target="_blank" rel="noopener">数字地图</a>内容、导航和位置服务解决方案提供商。拥有导航<a href="https://baike.baidu.com/item/电子地图/1287271" target="_blank" rel="noopener">电子地图</a>甲级测绘资质、测绘航空摄影甲级资质和互联网地图服务甲级测绘资质“三甲”资质，其优质的电子地图数据库成为公司的核心竞争力。</p><p>最新地图浏览器：最新<a href="https://baike.baidu.com/item/矢量地图/5132557" target="_blank" rel="noopener">矢量地图</a>渲染，最高质量地图效果、最丰富数据信息、最快速操作体验、最节省数据流量。专业地图服务：实地采集、网络采集，行业领先。</p><p>丰富的出行查询功能：地名信息查询、分类信息查询、公交换乘、驾车路线规划、公交线路查询、位置收藏夹等丰富的基础地理信息查询工具。</p><p>成为现代人们生活的必备品</p><h3 id="获取key并查询"><a href="#获取key并查询" class="headerlink" title="获取key并查询"></a>获取key并查询</h3><ol><li><p>注册成功之后，创建新应用</p><p>进入<a href="https://lbs.amap.com/dev/" target="_blank" rel="noopener">控制台</a>，创建一个新应用。如果您之前已经创建过应用，可直接跳过这个步骤。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode1.png" alt="de"></p></li><li><p>添加新Key</p><p>在创建的应用上点击”添加新Key”按钮，在弹出的对话框中，依次：输入应用名名称，选择绑定的服务为“web服务API”，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode2.png" alt="de"></p><p>在阅读完高德地图API服务条款后，勾选此选项，点击“提交”，完成 Key 的申请，此时您可以在所创建的应用下面看到刚申请的 Key 了。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode3.png" alt="de"></p></li><li><p>进入<a href="https://lbs.amap.com/api/webservice/guide/api/ipconfig/" target="_blank" rel="noopener">高德IP定位</a>，并查看官方文档</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode4.png" alt="de"></p></li><li><p>使用已申请的<code>key</code></p><p>第一步，申请”web服务 API”密钥（Key）；</p><p>第二步，拼接HTTP请求URL，第一步申请的Key需作为必填参数一同发送；</p><p>第三步，接收HTTP请求返回的数据（JSON或XML格式），解析数据。</p><p>如无特殊声明，接口的输入参数和输出数据编码全部统一为UTF-8。</p></li><li><p>IP定位API服务地址：</p><table><thead><tr><th>URL</th><th><a href="https://restapi.amap.com/v3/ip?parameters" target="_blank" rel="noopener">https://restapi.amap.com/v3/ip?parameters</a></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr></tbody></table></li><li><p>请求参数</p><table><thead><tr><th align="left">参数名</th><th align="left">含义</th><th align="left">规则说明</th><th align="left">是否必须</th><th align="left">缺省值</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">请求服务权限标识</td><td align="left">用户在高德地图官网<a href="https://lbs.amap.com/dev/" target="_blank" rel="noopener">申请Web服务API类型KEY</a></td><td align="left">必填</td><td align="left">无</td></tr><tr><td align="left">ip</td><td align="left">ip地址</td><td align="left">需要搜索的IP地址（仅支持国内）若用户不填写IP，则取客户http之中的请求来进行定位</td><td align="left">可选</td><td align="left">无</td></tr><tr><td align="left">sig</td><td align="left">签名</td><td align="left">选择数字签名认证的付费用户必填</td><td align="left">可选</td><td align="left">无</td></tr><tr><td align="left">output</td><td align="left">返回格式</td><td align="left">可选值：JSON,XML</td><td align="left">可选</td><td align="left">JSON</td></tr></tbody></table></li><li><p>请求接口了解完之后，开始写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">'114.247.50.2'</span></span><br><span class="line">url = <span class="string">'https://restapi.amap.com/v3/ip?ip='</span>+ip+<span class="string">'&amp;output=json&amp;key=66a7ff5f4d2371a783d196becc856f94'</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li><li><p>调用结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"status"</span>:<span class="string">"1"</span>,<span class="string">"info"</span>:<span class="string">"OK"</span>,<span class="string">"infocode"</span>:<span class="string">"10000"</span>,<span class="string">"province"</span>:<span class="string">"北京市"</span>,<span class="string">"city"</span>:<span class="string">"北京市"</span>,<span class="string">"adcode"</span>:<span class="string">"110000"</span>,<span class="string">"rectangle"</span>:<span class="string">"116.0119343,39.66127144;116.7829835,40.2164962"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个ip只能我们手动输入，但我们可以使用<code>socket</code>模块来获取本机的ip</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 获取本机计算机名称</span></span><br><span class="line">hostname = socket.gethostname()</span><br><span class="line"><span class="comment"># 获取本机ip</span></span><br><span class="line">ip = socket.gethostbyname(hostname)</span><br><span class="line">print(ip)</span><br></pre></td></tr></table></figure></li><li><p>打印结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>  <span class="comment"># 因为我用的以太网，所以获取到的是以太网IP</span></span><br></pre></td></tr></table></figure></li><li><p>两者结合使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 获取本机计算机名称</span></span><br><span class="line">hostname = socket.gethostname()</span><br><span class="line"><span class="comment"># 获取本机ip</span></span><br><span class="line">ip = socket.gethostbyname(hostname)</span><br><span class="line">url = <span class="string">'https://restapi.amap.com/v3/ip?ip='</span>+ip+<span class="string">'.139&amp;output=json&amp;key=66a7ff5f4d2371a783d196becc856f94'</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>通过调用高德接口，可以很方便实现通过IP查询地址</p><p><strong>更多内容查看<a href="https://lbs.amap.com/" target="_blank" rel="noopener">高德开放平台</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 为什么推荐蛇形命名法？</title>
      <link href="/2020/07/12/Note/python%E5%8F%98%E9%87%8F/"/>
      <url>/2020/07/12/Note/python%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>关于变量的命名，这又是一个容易引发程序员论战的话题。如何命名才能更具有可读性、易写性与明义性呢？众说纷纭。</p><p>今天，我们将聚焦于变量命名中的连接方式，来切入这块是非之地，想要回答的问题是——<strong>Python 为什么要推荐蛇形命名法？</strong></p><h3 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h3><p>首先一点，对于<strong>单个字符或者单词</strong>（例如：a、A、PYTHON、Cat），当它们被用作变量名时，大致有全小写、全大写和首字母大写这几种情况。编程语言中出现这些情况时，它们基本上跟英语的表达习惯是相同的。</p><p>但是，编程语言为了令变量名表达出更丰富的含义，通常需要使用<strong>多个单词或符号。</strong>英语习惯使用空格来间隔开单词，然而这种用法在编程语言中会带来一些麻烦，所以程序员们就创造出了另外的方法：</p><ul><li>蛇形命名法（snake case）</li><li>驼峰命名法（camel case）</li><li>匈牙利命名法（HN case）</li><li>帕斯卡命名法（Pascal case）</li><li>脊柱命名法（spinal case）</li><li>自由命名法（studly caps）</li><li>驼峰蛇形命名法</li></ul><p>总体而言，这些命名法都是要<strong>克服单词间的空格，从而把不同单词串连起来，</strong>最终达到创造出一种新的“单词”的效果。</p><p>我画了一张思维导图，大略区分了这几种命名法：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mm1.png" alt="img"></p><p>如果按照受众量与知名程度排名，毫无疑问排前两位的是驼峰命名法和蛇形命名法。</p><p>我们简单比较一下它们的优缺点：</p><ul><li>可读性：蛇形命名法用下划线拉大词距，更清楚易读；驼峰命名法的变量名紧凑，节省行宽</li><li>易写性：驼峰命名法以大小写为区分，不引入额外的标识符；蛇形命名法统一小写，输入相对方便</li><li>明义性：对于某些缩写成的专有名词，例如HTTP、RGB、DNS等等，一般习惯全用大写表示，但是如果严格遵循这两种命名法的话，须得只留首字母大写或者全小写，这样对原意都会造成一些“破坏”，有时候甚至让人感觉到别扭。如果保留全大写，IDE可能识别不准，反而会出现波浪提示</li></ul><p>由此可见，它们各有优缺点，但哪一方都不具有压倒性。我个人稍微偏好于蛇形命名法，但是在需要用驼峰命名的时候（比如写 Java 时），也能无障碍切换。</p><p>需要指出的是，Python 也推荐使用驼峰式命名，那是在类名、Type 变量、异常 exception 名这些情况。而在<strong>包名、模块名、方法名和普通变量名</strong>等情况，则是推荐用蛇形命名（lower_case_with_underscores）。</p><p>那么，为什么 Python 会推荐用蛇形命名法呢？</p><p><strong>最大的原因是历史原因。</strong>蛇形命名方式起源于 1960 年代，那时它甚至还没有特定的名称。Python 从 C 语言中借鉴过来后，给它起名为“lower_case_with_underscores”，即带下划线的小写命名。</p><p>直到 21 世纪初的几年，在 Intel 和 Ruby 社区中，才有人开始以“snake_case”即蛇形命名来称呼它。</p><p>现今有不少编程语言在某些场景下会推荐使用蛇形命名法，而 Python 则是其中最早这么做的之一，并且是使用场景最多的语言之一。</p><p>维基百科上统计了一份清单，可以看出 Python 对它的偏好：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mm2.png" alt="img"></p><p>其次，还有一个比较重要的原因，<strong>那就是 Python 对下划线“_”的独特偏爱。</strong></p><p>比如类似于 <em>xx、<strong>xx、xx_、</strong>xx_</em> 等等的写法就随处可见，甚至还有孤零零一个下划线 _ 作为变量的特殊情况。这样看来，下划线作为单词间的连接，恰恰是这种传统习惯的一部分。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最后，我还看到过一种解释：<strong>因为 Python 是蟒蛇啊，理所当然是用蛇形命名……</strong></p><p>对于这三个解释，你们是如何感想的呢？对于蛇形命名法，大家是喜欢还是不喜欢呢？欢迎留言交流。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ShareLatex和Python3打造属于自己的特色简历</title>
      <link href="/2020/07/11/Note/%E4%BD%BF%E7%94%A8ShareLatex%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/"/>
      <url>/2020/07/11/Note/%E4%BD%BF%E7%94%A8ShareLatex%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>履历</strong>(英式英语：<a href="https://zh.wikipedia.org/w/index.php?title=Curriculum_Vitae&action=edit&redlink=1" target="_blank" rel="noopener">Curriculum Vitae</a>，简称<strong>CV</strong>；美式英语：<a href="https://zh.wikipedia.org/w/index.php?title=Résumé&action=edit&redlink=1" target="_blank" rel="noopener">Résumé</a>)，是对个人教育、工作经历的书面介绍，是求职者通向面试阶段的重要一环。</p><p>说起简历模板，大家一定不会陌生，随便在百度搜关键词“简历模板”，林林总总的会出现一大片，但是这些简历模板往往都会有一个共同点，就是太Low、“土味”重、没有时代感、味同嚼蜡，蜡都要顺着嘴角流下来了，以一个求职者的视角来看待这些简历都会无奈心烦，更别说招聘者了。所以新时代的简历应该具备独特性、新颖、与众不同并且不落窠臼。</p><p>Resume是在申请求职时最常使用的文件，为你的教育程度、工作经历以及工作技能做简单且明了的摘要，同时，也会依个人、申请职位的需求，列出求职目标。由于是个人“摘要”，Resume通常为一页，最多不超过二页，以求简洁。</p><p>而在CV中，则会详细的列举出个人的经验与相关技能，尤其是个人的学术背景，如：教学经验、研究成果、获奖纪录、相关出版物⋯⋯等细节，也因此，CV的篇幅会比Resume长上许多，通常会超过二页。</p><h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><ol><li><p>首先进入<a href="https://www.sharelatex.com/" target="_blank" rel="noopener">ShareLatex</a>，注册账号并登陆。</p></li><li><p>之后通过邮箱激活，选择新建序幕，并选简历</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha1.png" alt="sha"></p></li><li><p>紧接着我们会发现有许多简历模板，但是都用LaTeX语法写的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha2.png" alt="sha"></p></li><li><p>随后点开其中一个，就可以进行定制化的编辑</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha3.png" alt="sha"></p></li><li><p>编辑之后，可以点击重新编译查看效果，如果编辑好之后就可以在线下载pdf，非常方便</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha4.png" alt="sha"></p></li><li><p>但是由于LaTeX语法我们没有学过，而且编辑成本比较高，最重要的对于一些英文不好的很难编辑。</p></li><li><p>其实<code>6</code>的问题很好解决。我们可以下载这上面的原始pdf简历，再通过Python脚本将其转换为我们所熟悉的Word文档模式，这样就可以随便进行编辑</p></li><li><p>通过Pdfminer3k以及Python-Docx两个库，使用python可以实现</p></li><li><p>首先安装依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pdfminer3k</span><br><span class="line">pip3 install python-docx</span><br></pre></td></tr></table></figure></li><li><p>通过Pdfminer3k读取pdf内容，再使用Python-Docx写入word文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFResourceManager</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> process_pdf</span><br><span class="line"><span class="keyword">from</span> pdfminer.converter <span class="keyword">import</span> TextConverter</span><br><span class="line"><span class="keyword">from</span> pdfminer.layout <span class="keyword">import</span> LAParams</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = open(<span class="string">"pdf文件地址"</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">resource_manager = PDFResourceManager()</span><br><span class="line">return_str = StringIO()</span><br><span class="line">lap_params = LAParams()</span><br><span class="line"></span><br><span class="line">device = TextConverter(resource_manager, return_str, laparams=lap_params)</span><br><span class="line">process_pdf(resource_manager, device, file)</span><br><span class="line">device.close()</span><br><span class="line"></span><br><span class="line">content = return_str.getvalue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_control_characters</span><span class="params">(content)</span>:</span></span><br><span class="line">    mpa = dict.fromkeys(range(<span class="number">32</span>))</span><br><span class="line">    <span class="keyword">return</span> content.translate(mpa)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content.split(<span class="string">'\n'</span>):</span><br><span class="line">    paragraph = doc.add_paragraph()</span><br><span class="line">    paragraph.add_run(remove_control_characters(line))</span><br><span class="line">doc.save(<span class="string">"mypdf.docx"</span>)</span><br></pre></td></tr></table></figure></li><li><p>但是，这样弄出来的简历，没有样式而且麻烦</p></li><li><p>我们可以通过注册登陆<a href="https://smallpdf.com/" target="_blank" rel="noopener">https://smallpdf.com/</a>此网站，进行在线转换</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha5.png" alt="sha"></p></li><li><p>直接拖拽上传即可。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha6.png" alt="sha"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>一个不落俗套的简历模板可以让你的求职如虎添翼，也可以让你的简历从招聘者邮箱中的海量简历中脱颖而出，但是简历模板也仅仅是求职中的一个重要细节之一，比起简历模板，简历中的工作经历以及技术经验则更加重要，切不可本末倒置。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> ShareLatex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下安装编辑器之神Vim</title>
      <link href="/2020/07/10/Note/vim%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/10/Note/vim%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>相对于pycharm，Sublime、Vscode等编辑器，vim一直是处于编辑器的最顶端，奉行 Unix 传统的“Do one thing and do it well”哲学。</p><p>本次我们在Win10平台构建一套以Vim为核心的Python开发环境。</p><h3 id="下载安装与使用"><a href="#下载安装与使用" class="headerlink" title="下载安装与使用"></a>下载安装与使用</h3><ol><li><p>首先进入<a href="https://tuxproject.de/projects/vim/x64/" target="_blank" rel="noopener">giv官网</a>下载gvim8，注意根据系统类型选择32或者64位，这里我们选择64位的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim1.png" alt="vim"></p></li><li><p>下载完成后，将下载好的压缩包解压，并且将文件放到C:/vim目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim2.png" alt="vim"></p></li><li><p>紧接着我们配置下环境变量，这样我们就可以在电脑的任意位置启动vim</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim3.png" alt="vim"></p></li><li><p>之后在当前的用户目录，建立一个_vimrc文件，这是vim的配置文件，所有的设置都在这里编写</p><p>将以下内容添加到_vimrc文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" An example for a vimrc file.</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Maintainer:Bram Moolenaar &lt;Bram@vim.org&gt;</span></span><br><span class="line"><span class="string">"</span> Last change:<span class="number">2019</span> Dec <span class="number">17</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">"</span> To use it, copy it to</span><br><span class="line"><span class="string">"       for Unix:  ~/.vimrc</span></span><br><span class="line"><span class="string">"</span>      <span class="keyword">for</span> Amiga:  s:.vimrc</span><br><span class="line"><span class="string">" for MS-Windows:  $VIM_vimrc</span></span><br><span class="line"><span class="string">"</span>      <span class="keyword">for</span> Haiku:  ~/config/settings/vim/vimrc</span><br><span class="line"><span class="string">"    for OpenVMS:  sys$login:.vimrc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> When started <span class="keyword">as</span> <span class="string">"evim"</span>, evim.vim will already have done these settings, bail</span><br><span class="line"><span class="string">" out.</span></span><br><span class="line"><span class="string">if v:progname =~? "</span>evim<span class="string">"</span></span><br><span class="line"><span class="string">  finish</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Get the defaults that most users want.</span><br><span class="line">source $VIMRUNTIME/defaults.vim</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">"vms"</span>)</span><br><span class="line">  set nobackup<span class="string">" do not keep a backup file, use versions instead</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  set backup"</span> keep a backup file (restore to previous version)</span><br><span class="line">  <span class="keyword">if</span> has(<span class="string">'persistent_undo'</span>)</span><br><span class="line">    set undofile<span class="string">" keep an undo file (undo changes after closing)</span></span><br><span class="line"><span class="string">  endif</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if &amp;t_Co &gt; 2 || has("</span>gui_running<span class="string">")</span></span><br><span class="line"><span class="string">  "</span> Switch on highlighting the last used search pattern.</span><br><span class="line">  set hlsearch</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">" Put these in an autocmd group, so that we can delete them easily.</span></span><br><span class="line"><span class="string">augroup vimrcEx</span></span><br><span class="line"><span class="string">  au!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  "</span> For all text files set <span class="string">'textwidth'</span> to <span class="number">78</span> characters.</span><br><span class="line">  autocmd FileType text setlocal textwidth=<span class="number">78</span></span><br><span class="line">augroup END</span><br><span class="line"></span><br><span class="line"><span class="string">" Add optional packages.</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" The matchit plugin makes the % command work better, but it is not backwards</span></span><br><span class="line"><span class="string">"</span> compatible.</span><br><span class="line"><span class="string">" The ! means the package won't be loaded right away but when plugins are</span></span><br><span class="line"><span class="string">"</span> loaded during initialization.</span><br><span class="line"><span class="keyword">if</span> has(<span class="string">'syntax'</span>) &amp;&amp; has(<span class="string">'eval'</span>)</span><br><span class="line">  packadd! matchit</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">set encoding=utf<span class="number">-8</span></span><br><span class="line">set fileencodings=utf<span class="number">-8</span>,chinese,latin<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">"win32"</span>)</span><br><span class="line">    set fileencoding=chinese</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    set fileencoding=utf<span class="number">-8</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">set autoindent</span><br><span class="line">set nu!</span><br><span class="line">set shiftwidth=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line"></span><br><span class="line">language messages zh_CN.utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line">colo koehler</span><br><span class="line">set guifont=monaco:h11:cANSI</span><br><span class="line"></span><br><span class="line">set ts=<span class="number">4</span></span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">map &lt;F5&gt; :! python.exe %</span><br></pre></td></tr></table></figure></li><li><p>这些都是一些最基本的配置，比如设置编码解决中文乱码问题、自动缩进以及缩进宽度、菜单栏中文字体问题、主题和字体、以及四个空格代替制表符等等，注意一点这个配置里我将运行python脚本的快捷键设置成了F5。</p><p>这时进入windows命令行，输入gvim启动编辑器，然后键入命令:version，看到版本号就没有问题了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim4.png" alt="vim"></p></li><li><p>虽然现在Vim已经可以正常使用了，但是没有插件的加成，开发效率就不是那么高，所以我们现在来安装一些常用的插件。安装<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">pathogen.vim插件</a>（一个vim插件管理器， 直接Clone或者下载压缩包将Clone或者解压后的pathogen.vim文件放到C:/vim/autoload目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim5.png" alt="vim"></p></li><li><p>修改用户目录下的_vimrc配置文件，将下面的配置加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br></pre></td></tr></table></figure></li><li><p>这样就可以安装其他所有的插件了，紧接着我们安装一个<a href="https://www.vim.org/scripts/script.php?script_id=69" target="_blank" rel="noopener">项目管理插件</a>(project)，它可以帮助我们把项目整体导入vim编辑器内，通过点击文件进行修改，这样就不用每次编辑都要在命令行输入命令才能编辑了，大体上，这个插件可以帮我们快速修改整个项目。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim6.png" alt="vim"></p></li><li><p>将解压后的doc目录中的project文件拷贝到vim安装目录的doc目录下将plugin目录下的project.vim拷贝到vim安装目录的plugin目录下在命令行输入gvim启动编辑器。输入:Project，随后输入\C (是反斜杠和大写C，因为是输入命令，所以不会在编辑内显示，但是执行成功后会弹出窗口)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim7.png" alt="vim"></p></li><li><p>Enter the Name of the Entry: 输入项目名，Enter the Absolute Directory to，Load: 输入项目的文件目录路径（项目目录需要事先存在），Enter the CD parameter: 这个和项目目录路径一样即可，Enter the File Filter: 设置管理的文件类型，<em>.py,</em>.txt等等，可以设置多个，不设置（直接回车）默认为所有类型</p><p>再次使用：打开vim后输入:Project<br>使用回车打开或关闭标签。<br>添加或者修改文件后可以使用\R进行刷新项目。</p><p>这样我们就可以在vim里管理我们的项目了。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim8.png" alt="vim"></p></li><li><p>好了，项目导入后就可以愉快的开发了，但是我们发现vim默认没有代码补全，怎么办呢，聪明如你一定已经猜到可以用插件搞定，使用<a href="https://github.com/rkulla/pydiction" target="_blank" rel="noopener">pydiction</a>Clone或者下载压缩包之后，发现里面有after文件夹、complete-dict、pydiction.py</p><p>将after里面的python_pydiction.vim文件拷贝到 vim安装目录下的ftpplugin里面，将complete-dict、pydiction.py 拷贝到ftpplugin目录下。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim9.png" alt="vim"></p><p>随后在_vimrc里面添加 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filetype plugin on</span><br><span class="line">let g:pydiction_location=<span class="string">'C:vim/ftplugin/complete-dict'</span></span><br><span class="line">let g:pydiction_menu_height = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这就搞定了，使用方法是，敲入两个字母之后使用tab键进行补全，效果是下面这样：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim10.png" alt="vim"></p></li><li><p>还不错吧，有的时候，你甚至想用vim来编辑前端的页面，没有任何问题，使用<a href="https://vim.sourceforge.io/scripts/script.php?script_id=1879" target="_blank" rel="noopener">autocomplpop插件</a></p><p>解压后，将plugin下的脚本文件(.vim)、doc下的帮助文件(.txt)和autoload下的(.vim)文件分别拷贝至vim的 plugin、doc和autoload目录</p><p>这个插件甚至不需要配置，只需要在输入/insert模式下即可自动根据当前文档内的内容进行自动补全</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim11.png" alt="vim"></p></li><li><p>是不是感觉还不错？有了那么一点黑客的赶脚了。</p><p>Vim 有两种模式——Normal 模式和 Insert 模，所有命令都是在 Normal 模式下执行。启动 Vim 后，默认进入 Normal 模式，可以按 i 键进入 Insert 模式，或者 s 删除当前字符并进入 Insert 模式，退出 Insert 模式进入 Normal 按 ESC 。</p><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">i insert 输入</span><br><span class="line">v 行选中</span><br><span class="line">ctrl+v 列选中G 至文末</span><br><span class="line">gg 至文首</span><br><span class="line">:q 未修改退出</span><br><span class="line">:q! 强制不保存退出</span><br><span class="line">:x / :wq 保存并退出</span><br><span class="line">J 合并多行</span><br><span class="line">d 删除当前所选</span><br><span class="line">dd 删除多行并存在剪贴板中（剪切）</span><br><span class="line">y 复制当前所选</span><br><span class="line">yy 复制整行</span><br><span class="line">p 粘贴</span><br><span class="line">u 撤销操作</span><br><span class="line">w 光标移动到下一个单词处</span><br><span class="line">b 光标移动到上一个单词处</span><br><span class="line">^ 光标移动到行首</span><br><span class="line">$ 光标移动到行尾</span><br><span class="line">kjhl 或者上下左右键移动光标</span><br><span class="line">shift+上下键 翻页</span><br><span class="line">shift+左右 光标乙至上/下一个单词（以空格/标点区分单词）词首</span><br><span class="line">u 撤销上一步操作</span><br><span class="line">zo/zn/zc 折叠/展开代码块</span><br><span class="line">:vsp 新建工作区</span><br><span class="line">ctrl+w 松手后再按 方向键 切换工作区</span><br><span class="line">:MR 选择最近打开的文件（需安装插件）</span><br><span class="line">F12 运行当前文件</span><br><span class="line"><span class="comment"># 搜索光标处短语</span></span><br><span class="line">:set paste 进入粘贴模式</span><br><span class="line">:%s/target/something/g 替换全部 target 字段</span><br><span class="line">:s/target/something/g 替换选中区域 target 字段</span><br></pre></td></tr></table></figure></li><li><p>参考命令图解</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim12.png" alt="vim"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>现而今，Mac os和开源软件渐渐流行起来，此时的人们才发现：可扩展性才是软件的核心竞争力。在JetBrains横行的今天，Vscode为什么被评为最好的IDE？就是因为它在IDE中最具可扩展性。同理，将近30多年的历史浪潮中Vim没有被时代淘汰，反而愈发健壮，拥趸遍布全世界，也正是因为在数不清的编辑器中，Vim具有无可匹敌的可扩展性，当然了，这个世界除了编辑器之神，还有另外一种信仰：Emacs，它的教徒丝毫不少于Vim，它的影响力已经是超越编辑器的存在，有机会再分享关于Emacs的传说。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（在线客服系统）Python3.7+Flask1.1.1结合Socket.io与Vue2.9.6联合实现在线客服系统</title>
      <link href="/2020/06/28/Blog/websocket/"/>
      <url>/2020/06/28/Blog/websocket/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><h4 id="websocket是个啥？"><a href="#websocket是个啥？" class="headerlink" title="websocket是个啥？"></a>websocket是个啥？</h4><p>webSocket是一种在单个TCP连接上进行全双工通信的协议</p><p>webSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</p><p>现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 而比较新的技术去做轮询的效果是Comet。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。</p><p>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯</p><p>Socket.IO 就是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node（现在也支持python,go lang等语言）。其屏蔽了所有底层细节，让顶层调用非常简单，另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信，这一点就比websocket要智能不少。</p><h3 id="后端服务搭建"><a href="#后端服务搭建" class="headerlink" title="后端服务搭建"></a>后端服务搭建</h3><ol><li><p>我们需要使用flask框架来实现，首先安装相应的包</p><p><strong>分别安装Flask本地，跨域模块，以及socketio模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">pip install flask-cors</span><br><span class="line">pip install flask-socketio</span><br><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p><strong>注意版本</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flask                   <span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">Flask-Cors              <span class="number">3.0</span><span class="number">.8</span></span><br><span class="line">Flask-SocketIO          <span class="number">4.3</span><span class="number">.0</span></span><br><span class="line">Flask-SQLAlchemy        <span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li><li><p>接下来，写一个flask的入口文件<code>manage.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request,jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO,send,emit</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">CORS(app,cors_allowed_origins=<span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line">socketio = SocketIO(app,cors_allowed_origins=<span class="string">'*'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    message = urllib.parse.unquote(message)</span><br><span class="line">    print(message)</span><br><span class="line">    send(message,broadcast=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app,debug=<span class="literal">True</span>,host=<span class="string">"0.0.0.0"</span>,port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><u>我们写了三个基于socketio的视图方法，connect和disconnect顾名思义，当clinet发起连接或者断开时我们可以及时捕获到，而message方法就是前后端进行消息通信的重要方法。</u></p><p><em>发送消息的时候方法加了一个broadcast参数，这是socket.io极具特色的功能，类似广播的效果，可以同时给不同链接的client发送消息，即可以用于聊天，也可以用来做消息推送。</em></p><p> 最后需要注意的一点是，client发送消息时，最好用urlencode编码一下，这样可以解决中文乱码问题，而在server端，可以用urllib.parse.unquote()来进行解码操作。</p></li><li><p>启动flask服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk1.png" alt="socketio"></p><p><strong>没有出现错误，说明后端没问题</strong></p></li></ol><h3 id="Vue搭建页面"><a href="#Vue搭建页面" class="headerlink" title="Vue搭建页面"></a>Vue搭建页面</h3><ol><li><p>指定按本安装依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-socket.io@<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></li><li><p>在入口文件<code>main.js</code>中引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueSocketio <span class="keyword">from</span> <span class="string">'vue-socket.io'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueSocketio,<span class="string">'http://127.0.0.1:5000'</span>);</span><br></pre></td></tr></table></figure></li><li><p>构建用户链接组件<code>client.vue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">for</span>=<span class="string">"item in log_list"</span>&gt;</span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">         &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input v-model="msg" /</span>&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"send"</span>&gt;发送消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">  msg: "",</span></span><br><span class="line"><span class="regexp">  log_list:[]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/注册组件标签</span></span><br><span class="line"><span class="regexp">  components:&#123;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  sockets:&#123;</span></span><br><span class="line"><span class="regexp">    connect: function()&#123;</span></span><br><span class="line"><span class="regexp">      console.log('socket 连接成功')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    message: function(val)&#123;</span></span><br><span class="line"><span class="regexp">  console.log('返回:'+val);</span></span><br><span class="line"><span class="regexp">this.log_list.push(val);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  mounted:function()&#123;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp">send()&#123;</span></span><br><span class="line"><span class="regexp">  this.$socket.emit('message',encodeURI("用户:"+this.msg));</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务，访问页面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk2.png" alt="socketio"></p><p><strong>没有问题，接下来构建客服组件</strong></p></li><li><p>构建客服链接组件<code>server.vue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"item in log_list"</span>&gt;</span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">         &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input v-model="msg" /</span>&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"send"</span>&gt;发送消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">  msg: "",</span></span><br><span class="line"><span class="regexp">  log_list:[]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/注册组件标签</span></span><br><span class="line"><span class="regexp">  components:&#123;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  sockets:&#123;</span></span><br><span class="line"><span class="regexp">    connect: function()&#123;</span></span><br><span class="line"><span class="regexp">      console.log('socket 连接成功')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    message: function(val)&#123;</span></span><br><span class="line"><span class="regexp">  console.log('返回:'+val);</span></span><br><span class="line"><span class="regexp">  this.log_list.push(val);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  mounted:function()&#123;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">send()&#123;</span></span><br><span class="line"><span class="regexp">  this.$socket.emit('message',encodeURI("客服:"+this.msg));</span></span><br><span class="line"><span class="regexp">    &#125;,  </span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p><strong>用来模拟用户和客服分别在不同的电脑进行聊天的场景</strong></p></li><li><p>效果展示</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk3.png" alt="socketio"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk4.png" alt="socketio"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用python3.7实现钉钉机器人群发</title>
      <link href="/2020/06/19/Blog/dingrobot/"/>
      <url>/2020/06/19/Blog/dingrobot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>之前实现了<a href="https://www.sirxs.cn/2020/06/02/Blog/%E9%92%89%E9%92%89%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/">钉钉三方扫码登陆</a>，不得不说，钉钉还是一款很不错的办公软件。在最近的疫情期间，打游戏都不怎么坑了(因为钉钉的存在)。不过钉钉的群发机器人还是挺不错，可以自定义发送的信息。个人感觉比图灵好用，前期的<a href="https://www.sirxs.cn/2020/06/08/Live/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/">微信公众号添加机器人</a>使用的就是图灵机器人。</p><p>不过关于钉钉机器人网上的一些攻略年代都比较久远，代码很多都基于python2，那我们尝试用python3.7来开发配置钉钉自定义机器人。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><h4 id="quote-plus与quote的区别"><a href="#quote-plus与quote的区别" class="headerlink" title="quote_plus与quote的区别"></a>quote_plus与quote的区别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">quote = urllib.parse.quote(<span class="string">'a&amp;b/c'</span>)</span><br><span class="line">print(<span class="string">'a&amp;b/c:'</span>,quote)</span><br><span class="line">plus = urllib.parse.quote_plus(<span class="string">'a&amp;b/c'</span>)</span><br><span class="line">print(<span class="string">'a&amp;b/c:'</span>,plus)</span><br></pre></td></tr></table></figure><p>结果(一个不编译/,一个编译)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b/c: a%<span class="number">26</span>b/c</span><br><span class="line">a&amp;b/c: a%<span class="number">26</span>b%<span class="number">2</span>Fc</span><br></pre></td></tr></table></figure><h3 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h3><ol><li><p>在创建机器人之前，我们需要有自己的钉钉号，和创建一个钉钉群聊，而且创建机器人不支持手机端，所以请在电脑端进行创建</p></li><li><p>进入创建好的群，群成员可根据个人喜好添加，找到<code>智能群组手</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd1.png" alt="dd"></p></li><li><p>进入之后，下拉找到<code>添加机器人</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd2.png" alt="dd"></p></li><li><p>之后<code>添加机器人</code>，选择<code>自定义</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd3.png" alt="dd"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd4.png" alt="dd"></p></li><li><p><code>机器人名称</code>自己修改（<strong>密钥保存</strong>）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd5.png" alt="dd"></p><p><strong>需要注意的是，在安全设置一栏里，我们选择加签的方式来验证，在此说明一下，钉钉机器人的安全策略有三种，第一种是使用关键字，就是说你推送的消息里必须包含你创建机器人时定义的关键字，如果不包含就推送不了消息，第二种就是使用加密签名，第三种是定义几个ip源，非这些源的请求会被拒绝，综合来看还是第二种又安全又灵活。</strong></p></li><li><p>点击<code>完成</code>，ok，群发机器人已创建好（<strong>webhoot保存</strong>）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd6.png" alt="dd"></p><p><strong>值得一提的是，钉钉的机器人基于webhook协议，webhook呢是一个api概念,是微服务api的使用范式之一,也被成为反向api,即前端不主动发送请求。</strong></p></li></ol><h3 id="编写后端请求接口"><a href="#编写后端请求接口" class="headerlink" title="编写后端请求接口"></a>编写后端请求接口</h3><p><a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq" target="_blank" rel="noopener">钉钉开发文档</a></p><p>开发文档中居然出现了python3.8的代码，很遗憾我们用的是3.7的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">timestamp = str(round(time.time() * <span class="number">1000</span>))</span><br><span class="line">secret = <span class="string">'this is secret'</span></span><br><span class="line">secret_enc = secret.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">string_to_sign = <span class="string">'&#123;&#125;\n&#123;&#125;'</span>.format(timestamp, secret)</span><br><span class="line">string_to_sign_enc = string_to_sign.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()</span><br><span class="line">sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))</span><br><span class="line"><span class="comment"># print(timestamp)</span></span><br><span class="line"><span class="comment"># print(sign)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,json   <span class="comment">#导入依赖库</span></span><br><span class="line">headers=&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;   <span class="comment">#定义数据类型</span></span><br><span class="line">webhook = <span class="string">'"this is webhoot"&amp;timestamp='</span>+timestamp+<span class="string">"&amp;sign="</span>+sign</span><br><span class="line"><span class="comment">#定义要发送的数据</span></span><br><span class="line"><span class="comment">#"at": &#123;"atMobiles": "['"+ mobile + "']"</span></span><br><span class="line"><span class="comment">#群发</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="string">"text"</span>: &#123;<span class="string">"content"</span>: <span class="string">'群发消息'</span>&#125;,</span><br><span class="line">    <span class="string">"isAtAll"</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#@</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"msgtype"</span>: <span class="string">"text"</span>, </span><br><span class="line">    <span class="string">"text"</span>: &#123;</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"群发消息"</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">"at"</span>: &#123;</span><br><span class="line">        <span class="string">"atMobiles"</span>: [</span><br><span class="line">            <span class="string">"156xxxx8827"</span>, </span><br><span class="line">            <span class="string">"189xxxx8325"</span></span><br><span class="line">        ], </span><br><span class="line">        <span class="string">"isAtAll"</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(webhook, data=json.dumps(data), headers=headers)   <span class="comment">#发送post请求</span></span><br><span class="line"></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p>推送效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd7.png" alt="dd"></p><p><strong>校验不通过的消息将会发送失败，错误如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息内容中不包含任何关键词</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"keywords not in content"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timestamp 无效</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"invalid timestamp"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名不匹配</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"sign not match"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址不在白名单</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"ip X.X.X.X not in whitelist"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（贝宝模拟实现跨境支付）使用python3.7+Vue.js2.0+Django2.0.4实现Paypal模拟跨境支付功能</title>
      <link href="/2020/06/17/Blog/Paypal_Sandbox/"/>
      <url>/2020/06/17/Blog/Paypal_Sandbox/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><ol><li><a href="https://baike.baidu.com/item/PayPal" target="_blank" rel="noopener">Paypal(贝宝)</a>，作为一种外贸支付方式，目前在国际贸易支付服务中倍受亿万用户追捧，是全球商户和消费者最受欢迎的电子支付方式之一，是倍受全球亿万用户追捧的国际贸易<a href="https://baike.baidu.com/item/支付工具" target="_blank" rel="noopener">支付工具</a>，即时支付，即时到账，全中文操作界面，能通过中国的本地银行轻松提现，解决外贸收款难题，助您成功开展海外业务，决胜全球。注册PayPal后就可立即开始接受信用卡付款。、</li><li>PayPal是名副其实的全球化支付平台，  服务范围超过200个市场， 支持的币种超过100个。在跨国交易中， 将近70%的在线跨境买家更喜欢用PayPal支付海外购物款项。</li><li>之前写过模拟实现<a href="https://www.sirxs.cn/2020/06/13/Blog/Alipay_Sandbox/">支付宝模拟支付</a>，这次我们来实现跨境三方支付接口PayPal</li></ol><h3 id="创建贝宝沙盒应用"><a href="#创建贝宝沙盒应用" class="headerlink" title="创建贝宝沙盒应用"></a>创建贝宝沙盒应用</h3><ol><li><p>首先注册官网 <a href="https://www.paypal.com" target="_blank" rel="noopener">https://www.paypal.com</a> 以及开发者平台：<a href="https://developer.paypal.com/classic-home/" target="_blank" rel="noopener">https://developer.paypal.com/classic-home/</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal1.png" alt="paypal"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal2.png" alt="paypal"></p></li><li><p>注册成功后，在沙盒的账号控制页面：<a href="https://developer.paypal.com/developer/accounts/" target="_blank" rel="noopener">https://developer.paypal.com/developer/accounts/</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal3.png" alt="paypal"></p><p><strong>与支付宝沙箱一样，也有两个账号，一个商家，一个个人，当然也可以自己创建账号，点击蓝色按钮，即可创建</strong></p></li><li><p>接下来，我们要修改一下个人用户的信息</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal4.png" alt="paypal"></p><p><strong>Email ID 是支付的时候登陆的账号，密码建议修改</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal5.png" alt="paypal"></p><p><strong>接下来，我们修改一下<code>Funding</code>中的余额，以便我们测试使用</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal6.png" alt="paypal"></p></li><li><p>之后，进入应用管理页面：<a href="https://developer.paypal.com/developer/applications/" target="_blank" rel="noopener">https://developer.paypal.com/developer/applications/</a></p><p><strong>发现已有一个创建好的支付应用，并进入</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal11.png" alt="paypal"></p></li><li><p>记录下它的client_id和client_secret，会用到</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal12.png" alt="paypal"></p></li><li><p>做完这些之后，我们对沙箱的操作就已经完成了，我们进入下一步</p></li></ol><h3 id="安装PayPal的SDK，并进行测试"><a href="#安装PayPal的SDK，并进行测试" class="headerlink" title="安装PayPal的SDK，并进行测试"></a>安装PayPal的SDK，并进行测试</h3><h4 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h4><p>直接在终端窗口输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install paypalrestsdk</span><br></pre></td></tr></table></figure><p>完成下载:</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal7.png" alt="paypal"></p><h4 id="构建视图"><a href="#构建视图" class="headerlink" title="构建视图"></a>构建视图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paypalrestsdk</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment</span><span class="params">(request)</span>:</span></span><br><span class="line">    paypalrestsdk.configure(&#123;</span><br><span class="line">      <span class="string">"mode"</span>: <span class="string">"sandbox"</span>, <span class="comment"># sandbox代表沙盒</span></span><br><span class="line">      <span class="string">"client_id"</span>: <span class="string">"你的client_id,</span></span><br><span class="line"><span class="string">      "</span>client_secret<span class="string">": "</span>你的client_secret<span class="string">" </span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    payment = paypalrestsdk.Payment(&#123;</span></span><br><span class="line"><span class="string">        "</span>intent<span class="string">": "</span>sale<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>paye<span class="string">r": &#123;</span></span><br><span class="line"><span class="string">            "</span>payment_method<span class="string">": "</span>paypal<span class="string">"&#125;,</span></span><br><span class="line"><span class="string">        "</span>redirect_urls<span class="string">": &#123;</span></span><br><span class="line"><span class="string">            "</span>return_url<span class="string">": "</span>http://localhost:<span class="number">8000</span>/palpay/pay/<span class="string">",#支付成功跳转页面</span></span><br><span class="line"><span class="string">            "</span>cancel_url<span class="string">": "</span>http://localhost:<span class="number">3000</span>/paypal/cancel/<span class="string">"&#125;,#取消支付页面</span></span><br><span class="line"><span class="string">        "</span>transactions<span class="string">": [&#123;</span></span><br><span class="line"><span class="string">            "</span>amount<span class="string">": &#123;</span></span><br><span class="line"><span class="string">                #价格，精确到分</span></span><br><span class="line"><span class="string">                "</span>total<span class="string">": "</span><span class="number">5.00</span><span class="string">",</span></span><br><span class="line"><span class="string">                #货币种类</span></span><br><span class="line"><span class="string">                "</span>currency<span class="string">": "</span>USD<span class="string">"&#125;,</span></span><br><span class="line"><span class="string">            "</span>description<span class="string">": "</span>这是一个订单测试<span class="string">"&#125;]&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if payment.create():</span></span><br><span class="line"><span class="string">        print("</span>Payment created successfully<span class="string">")</span></span><br><span class="line"><span class="string">        for link in payment.links:</span></span><br><span class="line"><span class="string">            if link.rel == "</span>approval_url<span class="string">":</span></span><br><span class="line"><span class="string">                approval_url = str(link.href)</span></span><br><span class="line"><span class="string">                print("</span>Redirect <span class="keyword">for</span> approval: %s<span class="string">" % (approval_url))</span></span><br><span class="line"><span class="string">                #直接重定向到支付页面</span></span><br><span class="line"><span class="string">                return redirect(approval_url)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print(payment.error)</span></span><br><span class="line"><span class="string">        return HttpResponse("</span>支付失败<span class="string">")</span></span><br></pre></td></tr></table></figure><p><strong>return_url是支付成功后回调的页面，paypal会将一个支付者id回传，然后服务端需要验证支付才能真的完成支付</strong></p><p><strong>在支付之前会提示输入<code>账号</code>与<code>密码</code>是沙箱环境的账号与密码</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal9.png" alt="paypal"></p><p>登陆成功之后跳转支付页面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal8.png" alt="paypal"></p><p>支付完成之后，会跳转到我们定义的回调页面，并返回给我们参数：</p><p><code>http://localhost:8000/palpay/pay/?paymentId=PAYID-L3SYORA3C031930S1733650J&amp;token=EC-9TG269735K620131N&amp;PayerID=ETYYRCDN8C3XJ</code></p><p>这里paypal会传过来三个参数，支付id,token和支付者id</p><p>此时，我们的余额还没有扣除，需要用支付者的id进行确认</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment_execute</span><span class="params">(request)</span>:</span></span><br><span class="line">    paymentid = request.Get.get(<span class="string">"paymentId"</span>) <span class="comment">#订单id</span></span><br><span class="line">    payerid = request.Get.get(<span class="string">"PayerID"</span>)  <span class="comment">#支付者id</span></span><br><span class="line">    payment = paypalrestsdk.Payment.find(paymentid)</span><br><span class="line">    <span class="keyword">if</span> payment.execute(&#123;<span class="string">"payer_id"</span>: payerid&#125;):</span><br><span class="line">        print(<span class="string">"Payment execute successfully"</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"支付成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(payment.error) <span class="comment"># Error Hash</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"支付失败"</span>)</span><br></pre></td></tr></table></figure><p><strong>确定成功之后，paypal会扣除余额</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal10.png" alt="paypal"></p><p>自此，一次交易完成</p><h4 id="根据订单号，退款"><a href="#根据订单号，退款" class="headerlink" title="根据订单号，退款"></a>根据订单号，退款</h4><p>通过获取到的<code>paymentId</code>，查询到该订单的交易明细</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#明细</span></span><br><span class="line">payment = paypalrestsdk.Payment.find(<span class="string">"paymentId"</span>)</span><br><span class="line">print(payment)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal13.png" alt="paypal"></p><p>可以看到通过<code>paymentId</code>获取到了交易的状态，流水id，以及创建日期。</p><p><strong>通过获取到的流水号进行退款业务</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#退款</span></span><br><span class="line"><span class="keyword">from</span> paypalrestsdk <span class="keyword">import</span> Sale</span><br><span class="line">sale = Sale.find(<span class="string">"流水号"</span>)</span><br><span class="line"><span class="comment"># Make Refund API call</span></span><br><span class="line"><span class="comment"># Set amount only if the refund is partial</span></span><br><span class="line">refund = sale.refund(&#123;</span><br><span class="line">    <span class="string">"amount"</span>: &#123;</span><br><span class="line">        <span class="string">"total"</span>: <span class="string">"5.00"</span>,</span><br><span class="line">        <span class="string">"currency"</span>: <span class="string">"USD"</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># Check refund status</span></span><br><span class="line"><span class="keyword">if</span> refund.success():</span><br><span class="line">    print(<span class="string">"Refund[%s] Success"</span> % (refund.id))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Unable to Refund"</span>)</span><br><span class="line">    print(refund.error)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体而言，没有什么特别的难度，整个支付流程相对支付宝来说，更加的紧凑，但是做支付安全是第一要务，就个人体验（仅是个人体验）层面来说，支付宝在安全方面做的还是要比Paypal略强一些，起码在信用卡欺诈和盗刷方面风控做的更好，在风险保障和赔付方面都有提供保险，当然由于金融环境的差异较大，并不是说Paypal的风控做的不好，只是机制不同，在国外，如果持卡人的信用卡被盗刷，一般发卡组织会让商家去承担责任，而国内只能在交易环节设置更多的验证，本质上说是要持卡人承担责任。这也是为什么支付宝的风控看起来更好的原因。</p><p>  最后就是关于费率问题，Paypal官方给出的费率是每笔交易收取3.9%+$0.3（根据你的交易流水，比例可以优惠，具体下限看接入者的月营业额度），不过这可是美刀，不得不说这个费率是相当的高，但是国内做境外支付的电商，一般还是要接入Paypal作为支付方式。支付宝的费率基本上在1.2%左右，具体的费率也看交易流水，有实力的下限可以做到基本没有，单纯的看费率似乎支付宝更有优势，但是别忘记了，这样对比是不科学的，因为凡是接入Paypal的都是看中覆盖外币业务的地区，费率则是投资人该考虑的问题了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OOP总结</title>
      <link href="/2020/06/17/Note/oop/"/>
      <url>/2020/06/17/Note/oop/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Python 是一种解释型、面向对象、的高级程序设计语言。</p><p>那什么是面向对象呢</p><p>与面向对象经常拿来对比的就是面向过程编程，那么他们之间的区别在什么地方呢？</p><p>打个比方 ，我们买过的一般的玩具（变形金刚），我们必须要按照它说明书上的步骤，一步一步的去组装，才能得到最后的玩具，如果我们想要一个新的玩具，就要去商场买一个新的，然后按照说明书的顺序一步一步的组装。这就是面向过程</p><p>而面型对象呢？就可以理解为积木，没有一个固定的拼装方式，我们可以发挥自己的想象力，去自由的拼装和组装，同样的模块在不同的地方可以起到不同的作用（多态），一块儿积木就是一个最小的单位，我们哪里需要就放到哪里（封装）。也可以用多个对象组装起来去拼装成一个新的对象（继承）。大大的方便了我们的设计，不再拘泥于过程，极大程度上的放飞了生产力和效率。</p><p>总的来说就是<code>封装</code>,<code>继承</code>,<code>多态</code>，<code>抽象</code></p><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。</p><p>所以，在使用面向对象的封装特性时，需要：</p><ul><li>将内容封装到某处</li><li>从某处调用被封装的内容</li></ul><p>一、将内容封装到某处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="comment">#创建并初始化它的属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">obj2 = Foo(<span class="string">'老刘'</span>,<span class="number">28</span>)</span><br><span class="line"><span class="comment"># 将老刘与28分别封装到obj2的name与age属性中</span></span><br></pre></td></tr></table></figure><p>二、从某处调用被封装的内容</p><p>调用被封装的内容时，有两种情况：</p><ul><li>通过对象直接调用</li><li>通过self间接调用</li></ul><p>1、通过对象直接调用被封装的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">print(obj1.name) <span class="comment"># 直接调用obj1对象的name属性</span></span><br><span class="line">print(obj1.age) <span class="comment"># 直接调用obj1对象的age属性</span></span><br></pre></td></tr></table></figure><p>2、通过self间接调用被封装的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self)</span>:</span></span><br><span class="line">print(self.name)</span><br><span class="line">print(self.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">obj1.detail() <span class="comment"># Python默认会将obj1传给self参数，即：obj1.detail(obj1)，所以，此时方法内部的 self ＝ obj1，即：self.name 是 wupeiqi ；self.age 是 18</span></span><br></pre></td></tr></table></figure><p><strong>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</strong></p><p>继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。</p><p>例如：</p><p>　　老王可以：吃、喝、奥利给</p><p>　　老刘可以：吃、喝、奥利给</p><p>如果我们要分别为老王和老刘创建一个类，那么就需要为 老王 和 老刘 实现他们所有的功能，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s在吃'</span>%self.name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s在喝'</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类并继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s奥利给'</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类并继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoLiu</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s奥利给'</span>%self.name)</span><br><span class="line"></span><br><span class="line">c1 = LaoWang(<span class="string">'老王'</span>)</span><br><span class="line"><span class="comment"># 调用父类方法</span></span><br><span class="line">c1.eat()</span><br><span class="line">c1.drink()</span><br><span class="line"><span class="comment"># 调用自身方法</span></span><br><span class="line">c1.cry()</span><br><span class="line">print(<span class="string">'==================='</span>)</span><br><span class="line">c2 = LaoLiu(<span class="string">'老刘'</span>)</span><br><span class="line"><span class="comment"># 调用父类方法</span></span><br><span class="line">c2.eat()</span><br><span class="line">c2.drink()</span><br><span class="line"><span class="comment"># 调用自身方法</span></span><br><span class="line">c2.cry()</span><br></pre></td></tr></table></figure><p>多态，字面理解为多种形态，没错，就是一个方法能表现出不同的形态。</p><p>同一<strong>方法</strong>作用于不同的对象，可以有不同的解释，产生不同的结果。</p><p>现实中多态的例子举不胜举，比如我按下回车键，如果在word中就是换行，如果在QQ的发送消息界面就是发送消息，如果在命令行界面就是执行命令等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sex == <span class="string">"男士"</span>:</span><br><span class="line">            print(<span class="string">"%s是man"</span>%self.name)</span><br><span class="line">        <span class="keyword">elif</span> self.sex == <span class="string">"女士"</span>:</span><br><span class="line">            print(<span class="string">"%s是woman"</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Person)</span>:</span><span class="comment"># Child 继承 Person</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sex == <span class="string">"男士"</span>:</span><br><span class="line">            print(<span class="string">"%s是boy"</span>%self.name)</span><br><span class="line">        <span class="keyword">elif</span> self.sex == <span class="string">"女士"</span>:</span><br><span class="line">            print(<span class="string">"%sgirl"</span>%self.name)</span><br><span class="line"></span><br><span class="line">老王 = Child(<span class="string">"老王"</span>,<span class="string">"男士"</span>)</span><br><span class="line">小红 = Person(<span class="string">"小红"</span>,<span class="string">"女士"</span>)</span><br><span class="line"></span><br><span class="line">老王.print_title()</span><br><span class="line">小红.print_title()</span><br></pre></td></tr></table></figure><p>抽象：</p><p>提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：<strong>属性（数据）和操作（行为）</strong>。这个抽象模型我们称之为<strong>类</strong>。对类进行实例化得到对象。</p><p>抽象——就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来一般叫做类或者接口。)抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是数据抽象，二是过程抽象。</p><p>数据抽象——就是用代码的形式表示现时世界中一类事物的特性，就是针对对象的属性。比如建立一个鸟这样的类，鸟都有以下属性：一对翅膀、两只脚、羽毛等。抽象出来的类都是鸟的属性，或者成员变量。</p><p>过程抽象——就是用代码形式表示现实世界中事物的一系列行为，就是针对对象的行为特征。比如鸟会飞、会叫等。抽象出来的类一般都是鸟的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5数据加密</title>
      <link href="/2020/06/16/Note/md5/"/>
      <url>/2020/06/16/Note/md5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>MD5信息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://baike.baidu.com/item/密码散列函数/14937715" target="_blank" rel="noopener">密码散列函数</a>，可以产生出一个128位（16<a href="https://baike.baidu.com/item/字节/1096318" target="_blank" rel="noopener">字节</a>）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家<a href="https://baike.baidu.com/item/罗纳德·李维斯特/700199" target="_blank" rel="noopener">罗纳德·李维斯特</a>（Ronald Linn Rivest）设计，于1992年公开，用以取代<a href="https://baike.baidu.com/item/MD4/8090275" target="_blank" rel="noopener">MD4</a>算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如<a href="https://baike.baidu.com/item/SHA-2/22718180" target="_blank" rel="noopener">SHA-2</a>。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如<a href="https://baike.baidu.com/item/SSL/320778" target="_blank" rel="noopener">SSL</a>公开密钥认证或是<a href="https://baike.baidu.com/item/数字签名/212550" target="_blank" rel="noopener">数字签名</a>等用途。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p>下载md5包<code>npm install js-md5</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;js-md5&quot;: &quot;^0.7.3&quot;</span><br></pre></td></tr></table></figure><p>测试，并打印出md5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"><span class="number">666</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> md5 <span class="keyword">from</span> <span class="string">'js-md5'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//注册组件标签</span></span><br><span class="line">  components:&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//  设置秘钥，增加安全性  (应放在配置文件)</span></span><br><span class="line">    <span class="keyword">var</span> ed = <span class="string">'2020'</span></span><br><span class="line">     <span class="comment">//price:总价 goodid:商品id(3,1)</span></span><br><span class="line"><span class="keyword">var</span> sign = md5(<span class="string">'price=500&amp;goodid=3,1'</span> + ed)</span><br><span class="line">    <span class="built_in">console</span>.log(sign);</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a4299afde799fa1bf6d1ba0c13b0def7</span><br></pre></td></tr></table></figure><h4 id="Django-后端"><a href="#Django-后端" class="headerlink" title="Django(后端)"></a>Django(后端)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改price</span></span><br><span class="line">price = <span class="string">"1"</span></span><br><span class="line">goodid = <span class="string">"3,1"</span></span><br><span class="line"><span class="comment">#前端传的sign</span></span><br><span class="line">sign = <span class="string">"a4299afde799fa1bf6d1ba0c13b0def7"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"><span class="comment">#组合要加密的字符串</span></span><br><span class="line">sign_str = <span class="string">"price="</span>+price+<span class="string">"&amp;goodid="</span>+goodid+<span class="string">"2020"</span></span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">mysign = str(sign_str).encode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#设置加密</span></span><br><span class="line">md5.update(mysign)</span><br><span class="line">mysign = md5.hexdigest()</span><br><span class="line"><span class="comment">#判断</span></span><br><span class="line">print(mysign)</span><br><span class="line"><span class="keyword">if</span> sign == mysign:</span><br><span class="line">print(<span class="string">"pass"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"数据被篡改"</span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8c6849857cfeab25fa83bf7497943022</span><br><span class="line">数据被篡改</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>md5加密不经常用，但在设计到重要信息(金钱，虚拟币，商品)的时候会给我们数据带来非常安全的保障</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（支付宝模拟支付）使用python3.7+Vue.js2.0+Django2.0.4实现支付宝模拟支付功能</title>
      <link href="/2020/06/13/Blog/Alipay_Sandbox/"/>
      <url>/2020/06/13/Blog/Alipay_Sandbox/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>在当今科技发达的时代，纸币已将慢慢的从人们的口袋消失。随着带来的是更方便的电子货币（手机虚拟货币）。<a href="https://baike.baidu.com/item/%E6%94%AF%E4%BB%98%E5%AE%9D/496859" target="_blank" rel="noopener">支付宝</a>，是我国比较强大的第三方支付平台，也被广大人群所喜爱。在当今的基本所有网上购物平台都支持支付宝支付，所以我们用支付宝沙箱环境来模拟实现三方支付</p><h4 id="什么是沙箱环境"><a href="#什么是沙箱环境" class="headerlink" title="什么是沙箱环境"></a>什么是沙箱环境</h4><p>蚂蚁沙箱环境 (Beta) 是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考下文的 <strong>沙箱支持产品</strong> 列表）。 在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。 如何使用和配置沙箱环境请参考下文 <strong>如何使用沙箱环境</strong>。</p><p><strong>注意</strong></p><ul><li>由于沙箱为模拟环境，在沙箱完成接口开发及主要功能调试后，请务必在蚂蚁正式环境进行完整的功能验收测试。所有返回码及业务逻辑以正式环境为准。</li><li>为保证沙箱稳定，沙箱环境测试数据会进行定期数据清理。Beta 测试阶段每周日中午12点至每周一中午12点为维护时间，在此时间内沙箱环境部分功能可能会不可用，敬请谅解。</li><li>请勿在沙箱进行压力测试，以免触发相应的限流措施，导致无法正常使用沙箱环境。</li><li>沙箱支持的各个开放产品，沙箱使用的特别说明请参考各产品的快速接入文档或技术接入文档章节。</li></ul><h3 id="如何使用沙箱环境"><a href="#如何使用沙箱环境" class="headerlink" title="如何使用沙箱环境"></a>如何使用沙箱环境</h3><h4 id="第一步配置沙箱应用环境"><a href="#第一步配置沙箱应用环境" class="headerlink" title="第一步配置沙箱应用环境"></a>第一步配置沙箱应用环境</h4><ol><li><p>进入 <strong>开放平台 &gt; 开发者中心</strong> 在开发服务选项中点击 <strong>研发服务</strong> 即可进入 <a href="https://openhome.alipay.com/platform/appDaily.htm" target="_blank" rel="noopener">沙箱环境</a>。</p><p><img src= "/img/loading.gif" data-src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/254687/1589449249412-2fc126a6-4ae8-466d-8b94-be85ca191dc4.png" alt="alipay"></p></li><li><p>进入沙箱环境页面，系统已经自动为你创建一个应用，在 <strong>信息配置</strong> 中可以看到应用信息。</p><p><img src= "/img/loading.gif" data-src="https://static.dingtalk.com/media/lALOnH_0fM0BHM0Cog_674_284.png" alt="alipay"></p><ol><li>沙箱环境密钥设置支持上传 RSA2(SHA256) 的应用公钥和公钥证书两种形式，详见 <a href="https://opendocs.alipay.com/open/291/105971" target="_blank" rel="noopener">生成RSA密钥</a>。配置 RSA2(SHA256) 的应用公钥后，不需要配置 RSA(SHA1) 密钥，签名算法区别参见<a href="https://opendocs.alipay.com/open/291/106115" target="_blank" rel="noopener"> RSA 和RSA2 签名算法区别</a>。配置 crs 公钥证书时 <strong>组织/公司</strong> 需填写为 <strong>沙箱环境</strong>；</li><li>编写代码时，请将：</li></ol><ul><li>请求网关修改为：<code>https://openapi.alipaydev.com/gateway.do</code></li><li>appid 切换为沙箱的 appid</li><li>签名方式使用 RSA2</li><li>应用私钥（private_key）使用第 1 步生成的 RSA2 (SHA256) 的私钥(请根据开发语言进行选择原始或 pkcs8 格式)。</li><li>支付宝公钥（public_key）切换为第 1 步配置后应用公钥后，点击查看支付宝公钥看到的公钥。</li></ul><p><img src= "/img/loading.gif" data-src="https://static.dingtalk.com/media/lALOsWs3ic0Bus0CNw_567_442.png_620x10000q90g.jpg" alt="alipay"></p><p>选看部分作为进阶使用，非必填项；</p><ol><li>应用网关：该地址用于接收开放平台的异步通知。目前沙箱环境不需要配置此参数；</li><li>授权回调地址；第三方应用授权或获取用户信息中用于接收授权回调信息的地址。使用相关产品时需进行配置：</li></ol><ul><li>第三方应用授权：授权 url 中的 redirect_uri 必须与此值相同。</li><li>获取用户信息：授权 url 中的 redirect_uri 的域名必须与此值相同(例如：授权回调地址配置：<a href="https://auth.example.com/authCallBack" target="_blank" rel="noopener">https://auth.example.com/authCallBack</a> 高亮部分需和授权url相同)。</li></ul><ol><li>AES 密钥：目前不再使用。</li></ol></li></ol><h4 id="第二步根据文档写代码"><a href="#第二步根据文档写代码" class="headerlink" title="第二步根据文档写代码"></a>第二步根据文档写代码</h4><h4 id="电脑网站支付流程"><a href="#电脑网站支付流程" class="headerlink" title="电脑网站支付流程"></a>电脑网站支付流程</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/%E7%94%B5%E8%84%91%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="alipay"></p><h4 id="后端接口设计"><a href="#后端接口设计" class="headerlink" title="后端接口设计"></a>后端接口设计</h4><p><strong>请求方式</strong>： GET </p><p><strong>请求参数</strong>： 路径参数</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>order</td><td>str</td><td>是</td><td>订单编号</td></tr><tr><td>price</td><td>int</td><td>是</td><td>订单价格</td></tr></tbody></table><p><strong>返回数据</strong>： JSON</p><table><thead><tr><th>返回值</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>alipay_url</td><td>str</td><td>是</td><td>支付宝支付链接</td></tr></tbody></table><h4 id="后端实现（支付请求接口）"><a href="#后端实现（支付请求接口）" class="headerlink" title="后端实现（支付请求接口）"></a>后端实现（支付请求接口）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from alipay import AliPay</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">class Alipay(APIView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">         # 随机生成订单号</span><br><span class="line">        order = datetime.datetime.now().strftime("%Y%m%d%H%M%S") + str(random.randint(10, 99))</span><br><span class="line">        # 获取支付价格</span><br><span class="line">        price = request.GET.get("price", None)</span><br><span class="line">        # 获取token</span><br><span class="line">        jwt_token = request.GET.get("token",None)</span><br><span class="line">        try:</span><br><span class="line">            user_json = jwt_decode_handler(jwt_token)</span><br><span class="line">            # 获取token中的uid</span><br><span class="line">            user_id = user_json['user_id']</span><br><span class="line">        except:</span><br><span class="line">            return Response(&#123;"code":405,"message":"用户信息已失效，请重新登录"&#125;)</span><br><span class="line">        # 读取私钥及公钥</span><br><span class="line">        app_private_key_string = open("pay/private.txt").read()</span><br><span class="line">        alipay_public_key_string = open("pay/public.txt").read()</span><br><span class="line"></span><br><span class="line">        alipay = AliPay(</span><br><span class="line">            appid="支付宝沙箱id",</span><br><span class="line">            app_notify_url= None,  # 默认回调url</span><br><span class="line">            app_private_key_string=app_private_key_string,</span><br><span class="line">            alipay_public_key_string=alipay_public_key_string,</span><br><span class="line">            # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">            sign_type="RSA2",  # RSA 或者 RSA2</span><br><span class="line">            debug=True  # 默认False</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_string</span><br><span class="line">        order_str = alipay.api_alipay_trade_page_pay(</span><br><span class="line">            subject="返回名称",</span><br><span class="line">            notify_url=None,</span><br><span class="line">            out_trade_no=order,      # 订单号</span><br><span class="line">            total_amount=price,         # 订单价格</span><br><span class="line">            return_url="http://127.0.0.1:8000/get_alipy/"</span><br><span class="line">        )</span><br><span class="line"># 拼接支付宝支付页面网址url</span><br><span class="line">        request_url = 'https://openapi.alipaydev.com/gateway.do?' + order_str</span><br><span class="line"></span><br><span class="line">        return Response(&#123;</span><br><span class="line">            "code": 200,</span><br><span class="line">            "msg": "请求成功，跳转支付页面",</span><br><span class="line">            "data": request_url</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="后端实现（获取回调网站数据）"><a href="#后端实现（获取回调网站数据）" class="headerlink" title="后端实现（获取回调网站数据）"></a>后端实现（获取回调网站数据）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Get_Alipy(APIView):</span><br><span class="line">    def get(self,request):</span><br><span class="line">        user = request.query_params</span><br><span class="line">        # 获取支付用户id</span><br><span class="line">        uid = r.get("payuid")</span><br><span class="line">        # 获取订单号及价格  并将单位换算成分</span><br><span class="line">        price = int(float(user["total_amount"])*100)</span><br><span class="line">        order = user["out_trade_no"]</span><br><span class="line">        # 订单表中生成订单</span><br><span class="line">        Order.objects.create(uid=int(uid),order=order,price=price)</span><br><span class="line">        return Response(&#123;"code":200,"message":"购买成功"&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>支付宝沙箱环境是一个好东西，不需要商家认证那些，开发者可以直接整代码并且效果和实际上线效果是一样的。是一些技术研究者的福音。</p><p><strong>更多详情请查看</strong>：</p><ul><li><strong>文档主页</strong>：<a href="https://openhome.alipay.com/developmentDocument.htm" target="_blank" rel="noopener">https://openhome.alipay.com/developmentDocument.htm</a></li><li><strong>产品介绍</strong>：<a href="https://docs.open.alipay.com/270" target="_blank" rel="noopener">https://docs.open.alipay.com/270</a></li><li><strong>快速接入</strong>：<a href="https://docs.open.alipay.com/270/105899/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105899/</a></li><li>SDK：<a href="https://docs.open.alipay.com/270/106291/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/106291/</a><ul><li><strong>python对接支付宝SDK</strong>：<a href="https://github.com/fzlee/alipay/blob/master/README.zh-hans.md" target="_blank" rel="noopener">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a></li><li><strong>python对接支付宝SDK安装</strong>：<code>pip install python-alipay-sdk --upgrade</code></li></ul></li><li><strong>API列表</strong>：<a href="https://docs.open.alipay.com/270/105900/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105900/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snowflake分布式唯一算法</title>
      <link href="/2020/06/12/Blog/snowflake/"/>
      <url>/2020/06/12/Blog/snowflake/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>ID一般用来作为数据库表的主键，需要保证唯一性，通常情况下可以有以下几种方式实现：</p><p>1.UUID（Universally Unique Identifier）：</p><p>UUID是由一组32位数的16进制数字所构成的通用唯一识别码，可以保证ID的全局唯一性，但由于数据库或者文件系统的索引一般是由B+树构成的，而UUID插入完全无序，经常会导致一些中间节点合并和分裂，大大降低了数据库插入性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">print(uuid.uuid1())</span><br><span class="line"><span class="number">12725082</span>-acaa<span class="number">-11</span>ea<span class="number">-98</span>eb-e86a64ddceb7</span><br></pre></td></tr></table></figure><p>2.自增ID：</p><p>现在很多数据库引擎都支持自增ID，自增ID最大的好处是每次插入都在末尾，这样可以很大程度的减少节点的合并和分裂。而且自增ID所占空间也比UUID要小。但是自增ID只能保证一个库中一张表的ID唯一，往往不能保证多个库多张表的ID唯一，这样多个库之间合并的时候会因为主键冲突而失败。</p><p>3.自增ID+哈希取模：</p><p>如果数据量比较大，可以用n台机器存储。每台机器设置不同的起始值，所有机器的步长和机器数量相同。相当于自增ID与机器数量哈希取模。比如有3台机器，第一台设置1,4,7……；第二台设置2,5,8……；第三台设置3,6,9……但是这样的话，ID的生成对数据库严重依赖，一旦数据库挂掉，服务将变得不可用。</p><p>4.SnowFlake：</p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p>分布式情况下SnowFlake是一种生成ID比较好的算法。</p><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。</p><h3 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow2.png" alt="gitee"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li><p>首先安装库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pysnowflake</span><br></pre></td></tr></table></figure></li><li><p>接下来在本地启动snowflake服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snowflake_start_server --worker&#x3D;1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow3.png" alt="gitee"></p></li><li><p>这里值得说下的是可以通过定义端口号来实现运行多个服务</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow4.png" alt="gitee"></p></li><li><p>然后使用<code>setup</code>指定<code>ip</code>与<code>端口</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow5.png" alt="gitee"></p></li><li><p>之后就是对snowflake生成的id进行分析</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow1.png" alt="gitee"></p><p><strong>有人就会问，假设我搭建了上千个节点的分布式系统，此时接口接到参数id,我怎么判断该id的订单信息存储在那个节点中呢？</strong></p></li><li><p>其实很容易就可以判断，从SnowFlake的算法结构入手，本身就是二进制转换十进制的整形，现在我们反着进行解析即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先将其转换为二进制</span></span><br><span class="line">print(bin(<span class="number">4369145685749010433</span>))</span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line"><span class="number">0b11110010100010010100101101101000111011000000000001000000000001</span></span><br></pre></td></tr></table></figure></li><li><p>之前我们说第一位是标识符，此后是41位的时间戳，紧接着10位的节点标识码，最后12位的递增序列，从后面数12位是：000000000001，再数5位是：<code>00001</code> 这5位就是某个节点的存储标识，我们就二进制的<code>00001</code>转换为十进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点标识</span></span><br><span class="line">a = bin(<span class="number">4369049307706298369</span>)[<span class="number">47</span>:<span class="number">52</span>]</span><br><span class="line">print(<span class="string">'节点标识二进制%s'</span>%a)</span><br><span class="line"><span class="comment"># 强转十进制</span></span><br><span class="line">print(int(a,<span class="number">2</span>))</span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">节点标识二进制<span class="number">00001</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到，转换结果显示该id存储在节点1的数据库中</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实关于分布式唯一id的解决方案，也不仅仅只有uuid或者snowflake，像redis的incr原子性操作自增，亦或者Mongodb极具特色的_objectid的生成方式，专为分布式而设计的ID生成方案。都是可以参考的解决方案，但是方案总归是方案，总有其自身的特点和缺陷，这就需要根据实际应用场景而具体问题进行具体分析了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录（SSO）的设计与实现</title>
      <link href="/2020/06/10/Note/oss/"/>
      <url>/2020/06/10/Note/oss/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong></p><p>两个站点如果在同域下，那么它们之间是可以共享cookie的。简单的说就是这种同域下不同站点的sso实现可以通过cookie来实现，当用户访问这个域下面的任意站点时，浏览器都会将这个cookie发送给站点对应的系统。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss.jpg" alt="oss"></p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>比如阿里系的<strong>淘宝和天猫</strong>，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63967305d5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="oss"></p><p>简单来说，单点登录就是<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。</strong></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="第一种方式：凭借cookie，应用间的重定向"><a href="#第一种方式：凭借cookie，应用间的重定向" class="headerlink" title="第一种方式：凭借cookie，应用间的重定向"></a>第一种方式：凭借cookie，应用间的重定向</h4><p>这种方式比较简单，当用户在上面三个站点中的任意一个站点登录成功时，必须在浏览器中同时设置其他站点的cookie信息。<br> 例如：当用户登录site1站点，并且验证通过之后，浏览器会存储一份site1站点的cookie信息，这时，为了实现单点登录（为了在site2站点和site3站点无需登录），那么我们需要在浏览器设置site2站点和site3站点的cookie信息，因此，在用户登录site1站点的请求响应之前，需要从siteId1站点重定向到site2站点和site3站点去设置cookie信息，这样就可以保证，在任意站点登录成功之后，在浏览器也有其他站点的cookie信息。下图可具体展示其中流程：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss2.jpg" alt="oss"></p><p>这种方式其实过程比较简单，只需要确保登录其中一个站点在浏览器设置cookie其他站点都在浏览器设置对应cookie，就可以实现单点登录了（单点退出是一样的道理，一个退出清除cookie，其他也清除）。<br> 但是这种方式有一个非常明显的缺点是：这里举例是3个站点，如果是几十个上百个站点再使用这种方式将非常影响效率。</p><h4 id="第二种方式：借助单独的SSO服务器"><a href="#第二种方式：借助单独的SSO服务器" class="headerlink" title="第二种方式：借助单独的SSO服务器"></a>第二种方式：借助单独的SSO服务器</h4><p>这种方式需要借助一个单独的SSOServer，相对于上一种方式，这种方式就不需要将每个站点的cookie信息都保存在浏览器上，浏览器只需要保存SSOServer的cookie信息。将这个cookie信息用于需要做单点登录的所有站点中。<br> 对于这种方式，在浏览器对于任意一个站点的请求都将会先重定向到SSOServer去验证代表当前用户的cookie是否存在，如果存在，那么将验证成功后的跳转页面发送给浏览器，否则将跳转到登录页面提示用户登录。可参考如下图</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss3.jpg" alt="oss"></p><p>由于site1和site2的单点登录与site1、site2、site3之间的单点登录是同样道理的（因为登录site1后去访问site2和site3的流程都是相同的），所以，这里借助site1和site2的单点登录来说明这种方式。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（又拍云云存储）使用python3.7+Vue.js2.0+Django2.0.4实现又拍云云存储的异步文件上传功能</title>
      <link href="/2020/06/09/Blog/upyun/"/>
      <url>/2020/06/09/Blog/upyun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>上次我们实现了<a href="https://www.sirxs.cn/2020/06/08/Blog/qiniu/">七牛云异步上次文件</a>，今天我们来实现又拍云的异步文件上传功能</p><p>话不多说，直接实现吧</p><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><ol><li><p>首先进入又拍云官网：<a href="https://www.upyun.com/" target="_blank" rel="noopener">https://www.upyun.com/</a>，进行<code>注册登陆</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun1.png" alt="upyun"></p></li><li><p>登陆成功后，进入<code>控制台</code>,找到<code>云服务</code>，并进入</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun2.png" alt="upyun"></p></li><li><p>进入之后，<code>创建服务</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun3.png" alt="upyun"></p></li><li><p>这里与七牛云不同的是需要我们<code>新建一个授权操作员</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun4.png" alt="upyun"></p></li><li><p>进入<code>创建操作员</code>之后，将权限全部勾选，而且这个密码是一次性密码，需要我们记录</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun5.png" alt="upyun"></p></li><li><p>创建服务成功之后，进入<code>存储管理</code>，下面可以定义操作员<code>权限</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun6.png" alt="upyun"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun7.png" alt="upyun"></p></li></ol><h4 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h4><p>使用又拍云还需要安装一个库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install upyun</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun8.png" alt="upyun"></p><h3 id="Django-获取文件，并上传"><a href="#Django-获取文件，并上传" class="headerlink" title="Django(获取文件，并上传)"></a>Django(获取文件，并上传)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义文件上传类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        up = upyun.UpYun(<span class="string">'你的空间名称'</span>, username=<span class="string">'操作员账号'</span>, password=<span class="string">'操作员密码'</span>)</span><br><span class="line">        headers = &#123; <span class="string">'x-gmkerl-rotate'</span>: <span class="string">'180'</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            res = up.put(<span class="string">'/touxiang1.jpg'</span>, chunk, checksum=<span class="literal">True</span>, headers=headers)</span><br><span class="line">        <span class="comment">#返回结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'filename'</span>:img.name&#125;),content_type=<span class="string">'application/json'</span>)</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#多线程上传视频文件</span></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpYunVideo</span><span class="params">(APIView)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line"><span class="comment"># 获取视频文件</span></span><br><span class="line">video = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">print(video)</span><br><span class="line">name = video.name</span><br><span class="line">up = upyun.UpYun(<span class="string">'你的空间名称'</span>,<span class="string">'操作员账号'</span>,<span class="string">'操作员密码'</span>)</span><br><span class="line"><span class="comment"># 分块上传</span></span><br><span class="line"><span class="comment"># 创建一个分块上传实例(设置上传路径)</span></span><br><span class="line">uploader = up.init_multi_uploader(<span class="string">'/edu/%s'</span>%name)</span><br><span class="line">threads = []</span><br><span class="line">t1 = threading.Thread(target=uploader.upload,args=(<span class="number">0</span>,<span class="string">'分割文件'</span>))</span><br><span class="line">threads.append(t1)</span><br><span class="line">t2 = threading.Thread(target=uploader.upload,args=(<span class="number">1</span>,<span class="string">'分割文件'</span>))</span><br><span class="line">threads.append(t2)</span><br><span class="line"><span class="comment"># 启动多线程</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 阻塞主进程</span></span><br><span class="line">t.join()</span><br><span class="line"><span class="comment"># 调用结束</span></span><br><span class="line">res = uploader.complete()</span><br><span class="line"><span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'filename'</span>:name&#125;),content_type=<span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure><h3 id="Vue-获取视频数据，传给后端"><a href="#Vue-获取视频数据，传给后端" class="headerlink" title="Vue(获取视频数据，传给后端)"></a>Vue(获取视频数据，传给后端)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input @change=<span class="string">"upyun_video"</span> type=<span class="string">"file"</span> &gt;</span><br><span class="line">      上传进度：&#123;&#123;fileloadv&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 进度条视频</span></span><br><span class="line">      fileloadv:<span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//注册组件标签</span></span><br><span class="line">  components:&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="comment">// 上传七牛(视频)</span></span><br><span class="line">    upyun_video(e)&#123;</span><br><span class="line">      <span class="comment">// 获取文件对象</span></span><br><span class="line">      <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">      <span class="keyword">let</span> param = <span class="keyword">new</span> FormData();</span><br><span class="line">      <span class="comment">// 添加文件</span></span><br><span class="line">      param.append(<span class="string">'file'</span>,file);</span><br><span class="line">      <span class="keyword">const</span> config = &#123;</span><br><span class="line">        headers :&#123;</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 定制化axios</span></span><br><span class="line">      <span class="keyword">const</span> axios_upyun = <span class="keyword">this</span>.axios.create(&#123;<span class="attr">withCredentials</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      axios_upyun(&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        url:<span class="string">'http://localhost:8000/upyun/'</span>,</span><br><span class="line">        data:param,</span><br><span class="line">        timeout:<span class="number">30000</span>,</span><br><span class="line">        config:config,</span><br><span class="line">        <span class="comment">// 上传进度</span></span><br><span class="line">        onUploadProgress:<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 计算</span></span><br><span class="line">          <span class="keyword">var</span> com = (e.loaded / e.total);</span><br><span class="line">          <span class="comment">// 判断</span></span><br><span class="line">          <span class="keyword">if</span>(com &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.fileloadv = (com * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(res)</span><br><span class="line">         <span class="keyword">this</span>.fileloadv = <span class="string">'100%'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>页面效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun9.png" alt="upyun"></p><p>上传成功，返回值</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun10.png" alt="upyun"></p><p>查看文件(上传成功)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun11.png" alt="upyun"></p><p>同时，又拍云也可以用测试域名（CNAME）+ 设置的路径 + 获取到的名称，来实现查看文件</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun12.png" alt="upyun"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又拍云上传文件与七牛云上传文件其实，实现的过程没有什么太大的区别，之重要的是又拍云的免费流量比七牛云多出大概5g左右，当然了得加入一个所谓的又拍云联盟：<a href="https://www.upyun.com/league" target="_blank" rel="noopener">https://www.upyun.com/league</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2020/06/08/Note/reids%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2020/06/08/Note/reids%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>知识是珍贵宝石的结晶,文化是宝石放出的光泽。——泰戈尔</p><hr><h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>在<code>Redis</code>安装目录下找到<code>redis.windows.conf</code>这个文件，并打开</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/redis9.png" alt="redis"></p><p>下图就是RDB开启方式</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/RDB.png" alt="RDB"></p><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发</p><h4 id="1）触发机制"><a href="#1）触发机制" class="headerlink" title="1）触发机制"></a>1）触发机制</h4><p>手动触发分别对应save和bgsave命令</p><p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用</p><p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p><h4 id="2）自动触发RDB的持久"><a href="#2）自动触发RDB的持久" class="headerlink" title="2）自动触发RDB的持久"></a>2）自动触发RDB的持久</h4><p>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改 时，自动触发bgsave。</p><p>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。</p><p>执行debug reload命令重新加载Redis时，也会自动触发save操作。</p><p>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则 自动执行bgsave。</p><p>bgsave是主流的触发RDB持久化方式</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp.png" alt="img"></p><p>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进 程，如RDB/AOF子进程，如果存在bgsave命令直接返回。</p><p>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通 过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒</p><p>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</p><p>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的 时间，对应info统计的rdb_last_save_time选项。</p><p>进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的rdb_*相关选项。</p><p>RDB文件的处理</p><p>保存：RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配 置指定。可以通过执行config set dir{newDir}和config set dbfilename{newFileName}运行期动态执行，当下次运行时RDB文件会保存到新目录。</p><h1 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h1><h4 id="RDB的优点："><a href="#RDB的优点：" class="headerlink" title="RDB的优点："></a>RDB的优点：</h4><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p><p>Redis加载RDB恢复数据远远快于AOF的方式。</p><h4 id="RDB的缺点："><a href="#RDB的缺点：" class="headerlink" title="RDB的缺点："></a>RDB的缺点：</h4><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</p><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p><h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><h4 id="开启方式-1"><a href="#开启方式-1" class="headerlink" title="开启方式"></a>开启方式</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/AOF.png" alt="AOF"></p><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p><h4 id="1）使用AOF"><a href="#1）使用AOF" class="headerlink" title="1）使用AOF"></a>1）使用AOF</h4><p>开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名 通过appendfilename配置设置，默认文件名是appendonly.aof。保存路径同 RDB持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp1.png" alt="img"></p><h4 id="1）所有的写入命令会追加到aof-buf（缓冲区）中。"><a href="#1）所有的写入命令会追加到aof-buf（缓冲区）中。" class="headerlink" title="1）所有的写入命令会追加到aof_buf（缓冲区）中。"></a>1）所有的写入命令会追加到aof_buf（缓冲区）中。</h4><h4 id="2）AOF缓冲区根据对应的策略向硬盘做同步操作。"><a href="#2）AOF缓冲区根据对应的策略向硬盘做同步操作。" class="headerlink" title="2）AOF缓冲区根据对应的策略向硬盘做同步操作。"></a>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</h4><p>AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如 果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负 载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡</p><h4 id="3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。"><a href="#3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。" class="headerlink" title="3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。"></a>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</h4><p>重写后的AOF文件为什么可以变小？有如下原因：</p><p>1.进程内已经超时的数据不再写入文件。</p><p>2.旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保</p><p>留最终数据的写入命令。</p><p>3.多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p><p>AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF 文件可以更快地被Redis加载</p><p>AOF重写过程可以手动触发和自动触发：</p><p>手动触发：直接调用bgrewriteaof命令。</p><p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><p>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认 为64MB。</p><p>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</p><p>自动触发时机=aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size）/aof_base_size&gt;=auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp2.png" alt="img"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。"><a href="#4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。" class="headerlink" title="4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。"></a>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp3.png" alt="img"></p><p>流程说明：</p><p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件，打印如下日志：</p><p>* DB loaded from append only file: 5.841 seconds</p><p>2）AOF关闭或者AOF文件不存在时，加载RDB文件，打印如下日志：</p><p>* DB loaded from disk: 5.586 seconds</p><p>3）加载AOF/RDB文件成功后，Redis启动成功。</p><p>4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</p><p>重点回顾</p><p>1）Redis提供了两种持久化方式：RDB和AOF。</p><p>2）RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更 高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，无法做到实</p><p>时持久化，一般用于数据冷备和复制传输。</p><p>3）save命令会阻塞主线程不建议使用，bgsave命令通过fork操作创建子 进程生成RDB避免阻塞。</p><p>4）AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以 控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。</p><p>5）AOF重写可以通过auto-aof-rewrite-min-size和auto-aof-rewritepercentage参数控制自动触发，也可以使用bgrewriteaof命令手动触发。</p><p>6）子进程执行期间使用copy-on-write机制与父进程共享内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</p><p>7）持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。</p><p>8）单机下部署多个实例时，为了防止出现多个子进程执行重写操作， 建议做隔离控制，避免CPU和IO资源竞争。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人微信公众号申请以及添加机器人</title>
      <link href="/2020/06/08/Live/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>/2020/06/08/Live/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><p>微信（<a href="https://baike.baidu.com/item/WeChat" target="_blank" rel="noopener">WeChat</a>）是<a href="https://baike.baidu.com/item/腾讯公司" target="_blank" rel="noopener">腾讯公司</a>于2011年1月21日推出的一个为<a href="https://baike.baidu.com/item/智能终端" target="_blank" rel="noopener">智能终端</a>提供<a href="https://baike.baidu.com/item/即时通讯/111144" target="_blank" rel="noopener">即时通讯</a>服务的免费<a href="https://baike.baidu.com/item/应用程序" target="_blank" rel="noopener">应用程序</a> ，由<a href="https://baike.baidu.com/item/张小龙/24795" target="_blank" rel="noopener">张小龙</a>所带领的腾讯<a href="https://baike.baidu.com/item/广州/72101" target="_blank" rel="noopener">广州</a>研发中心产品团队打造 。微信支持跨通信<a href="https://baike.baidu.com/item/运营商/4530550" target="_blank" rel="noopener">运营商</a>、跨<a href="https://baike.baidu.com/item/操作系统/192" target="_blank" rel="noopener">操作系统</a>平台通过网络快速发送免费（需消耗少量网络流量）<a href="https://baike.baidu.com/item/语音短信/8430295" target="_blank" rel="noopener">语音短信</a>、<a href="https://baike.baidu.com/item/视频/321962" target="_blank" rel="noopener">视频</a>、<a href="https://baike.baidu.com/item/图片/372416" target="_blank" rel="noopener">图片</a>和文字，同时，也可以使用通过共享<a href="https://baike.baidu.com/item/流媒体/98740" target="_blank" rel="noopener">流媒体</a>内容的资料和基于位置的社交插件“<a href="https://baike.baidu.com/item/摇一摇/14079911" target="_blank" rel="noopener">摇一摇</a>”、“<a href="https://baike.baidu.com/item/漂流瓶/5706027" target="_blank" rel="noopener">漂流瓶</a>”、“<a href="https://baike.baidu.com/item/朋友圈/17341022" target="_blank" rel="noopener">朋友圈</a>”、”<a href="https://baike.baidu.com/item/公众平台/3274590" target="_blank" rel="noopener">公众平台</a>“、”<a href="https://baike.baidu.com/item/语音记事本" target="_blank" rel="noopener">语音记事本</a>“等服务插件。</p><p>微信公众平台，简称公众号。利用公众账号平台进行自媒体活动，简单来说就是进行一对多的媒体性行为活动，如商家通过申请公众微信服务号通过二次开发展示商家微官网、微会员、微推送、<a href="https://baike.baidu.com/item/微支付/10360089" target="_blank" rel="noopener">微支付</a>、微活动、微报名、微分享、<a href="https://baike.baidu.com/item/微名片/9824840" target="_blank" rel="noopener">微名片</a>等，已经形成了一种主流的线上线下微信互动营销方式。</p><h3 id="申请微信公众号"><a href="#申请微信公众号" class="headerlink" title="申请微信公众号"></a>申请微信公众号</h3><ol><li><p>打开微信公众平台官网：<a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 右上角点击“立即注册”；</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201612/7b4101870f94370b73d5cd6aec92f22e.jpg" alt="wechar"></p></li><li><p>选择帐号类型；</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201802/9bbe5e53e78ec43d06afc8029f805d4f.png" alt="wechar"></p></li><li><p>填写邮箱，登录您的邮箱，查看激活邮件，填写邮箱验证码激活；</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201802/07fcbb9c84b54592a84c1e41c7427593.png" alt="wechar"></p></li></ol><p>   <img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201802/8adfac5a79153e3419f430e8a179a8c4.png" alt="wechar"></p><ol start="4"><li><p>了解订阅号、服务号和企业微信的区别后，选择想要的帐号类型；</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201708/e88a2daa703d10c3f65f654f9e494b4a.jpg" alt="wechar"></p></li><li><p>下图为订阅号、服务号和企业微信的在手机端展示效果</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201708/5fe805b2f2114cb1f4e5bc89192363a6.jpg" alt="wechar"></p></li><li><p>信息登记，选择个人类型之后，填写身份证信息</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201803/c6f85f4e01d0f26b8c1a3d3be8e768ad.png" alt="wechar"></p></li><li><p>填写帐号信息，包括公众号名称、功能介绍，选择运营地区</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201803/d64f5ba1ae908f4d918fd9ddc948b642.png" alt="wechar"></p></li><li><p>恭喜注册成功！可以开始使用公众号了~</p><p><img src= "/img/loading.gif" data-src="http://file.service.qq.com/user-files/uploads/201612/08b8812718edff4c23e5e21dc0f8e94d.jpg" alt="wechar"></p></li></ol><h3 id="给公众号添加机器人"><a href="#给公众号添加机器人" class="headerlink" title="给公众号添加机器人"></a>给公众号添加机器人</h3><ol><li><p>打开图灵机器人官网：<a href="http://www.turingapi.com/" target="_blank" rel="noopener">http://www.turingapi.com/</a>，进行<code>注册登陆</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling1.png" alt="gitee"></p></li><li><p>进入之后，点击<code>创建机器人</code>，每个人最多免费申请五个机器人。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling2.png" alt="gitee"></p></li><li><p>填写信息</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling3.png" alt="gitee"></p></li><li><p>创建成功之后进入创建好的机器人的<code>终端设置</code>，找到<code>添加微信公众号</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling4.png" alt="gitee"></p></li><li><p>使用之前创建公众号的管理员微信扫描，授权</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling5.png" alt="gitee"></p></li><li><p>使用效果还是挺不错的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/tuling6.png" alt="gitee"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用个人公众号有什么好处：</p><ul><li><p><strong>赞赏作者</strong></p></li><li><p><strong>广告收入</strong></p><p>很多商家都需要打广告，以前他们都是在 电视、公交车打广告，现在手机是最多人使用的，微信公众号也是最多人看的，把广告打在公众号里面，可能效果会更好，因此很多商家都会找有粉丝的公众号合作，给钱在公众号上写文章，如果他们找到你，要在你公众号投放广告，广告费就非常不错了，目前广告是公众号做着变现的最主流的方式，流量就是钱，比如，目前做的比较好的咪蒙的广告费用，一篇文章就要100万元左右。</p></li><li><p><strong>电商</strong></p><p>微信最近公众号改版后，可在公众号文章直接插入商品，可通过分销产品，公众号主获得商品提成，如果你不想帮别人打广告，可以自己做电商广告，比如我卖茶叶的，我可以自己做商品，在自己公众号打广告，这种就叫做自媒体电商，如果你的粉丝足够大，电商收入肯定非常高。</p></li><li><p><strong>知识付费</strong></p><p>很多公众号主，获得了很多忠实的粉丝，他的成功经验可以做成付费课程，通过做付费课程变现也是很常见的方式，知识付费就是包括出书、线下沙龙、线上知识、付费社群等方式。</p></li><li><p><strong>卖公众号</strong></p><p>卖公众号这种一般都是批量做号的公司做的，他们都是形成了标准化运作，只有IP主号粉丝在，不断的养号做号，把粉丝聚集起来，迁移卖给别人，这种交易模式现在很成熟，一般一个十万粉丝的质量号，能够卖三十万左右，具体看号的类型和质量，总之，卖公众号也是非常赚钱的，其实本质上，就是卖粉丝，这也是非常重要的变现方式。</p></li></ul><p><strong>当然了我们可能做不到那么好，但是成功都是慢慢积累的，如果你掌握了这个技能，并且好好运营，成功也是在情理之中的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 生活 · 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（七牛云云端存储）使用python3.7+Vue.js2.0+Django2.0.4异步前端通过api上传文件到七牛云云端存储</title>
      <link href="/2020/06/08/Blog/qiniu/"/>
      <url>/2020/06/08/Blog/qiniu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.baidu.com/item/云存储" target="_blank" rel="noopener">云存储</a>的使用范围当下是非常的广泛了。如：某宝，某东这些大型的网上购物平台，许多的商品图片以及视频都开始了云存储。</p><p><strong>那什么是云存储呢</strong></p><p><strong>云存储</strong>是一种网上<a href="https://baike.baidu.com/item/在线存储" target="_blank" rel="noopener">在线存储</a>（英语：Cloud storage）的模式，即把数据存放在通常由第三方托管的多台虚拟<a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a>，而非专属的服务器上。</p><p><a href="https://baike.baidu.com/item/云存储" target="_blank" rel="noopener">云存储</a>是在<a href="https://baike.baidu.com/item/云计算" target="_blank" rel="noopener">云计算</a>(cloud computing)概念上延伸和衍生发展出来的一个新的概念。</p><p>比如：七牛云，又拍云….这些云存储服务器</p><p>接下来我们来实现七牛云云存储</p><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><ol><li><p>首先进入七牛云官网：<a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a>，进行<code>注册登陆</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu1.png" alt="qiniu"></p></li><li><p>登陆成功后，进入<code>管理控制台</code>，找到<code>对象存储</code>，并进入</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu2.png" alt="qiniu"></p></li><li><p>进入之后<code>创建一个空间</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu3.png" alt="qiniu"></p><p><strong>注</strong>：这里值得说一下的是这个<code>区域存储</code>，分为5大区域，选择也是根据自己所在的地区选择。下图是不同区域的上传域名</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu4.png" alt="qiniu"></p></li><li><p>创建成功之后在<code>个人头像</code>处找到<code>密钥管理</code>，这里的AK,SK需保存</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu5.png" alt="qiniu"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu6.png" alt="qiniu"></p></li></ol><h4 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h4><p>使用七牛云还需要安装一个库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install qiniu</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu7.png" alt="qiniu"></p><h4 id="Django-调用接口获取七牛云token"><a href="#Django-调用接口获取七牛云token" class="headerlink" title="Django(调用接口获取七牛云token)"></a>Django(调用接口获取七牛云token)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义七牛云存储接口</span></span><br><span class="line"><span class="keyword">from</span> qiniu <span class="keyword">import</span> Auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QiNiu</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 定义密钥</span></span><br><span class="line">        q = Auth(<span class="string">'AK'</span>,<span class="string">'SK'</span>)</span><br><span class="line">        <span class="comment"># 指定上传空间</span></span><br><span class="line">        token = q.upload_token(<span class="string">'创建空间的名称'</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;</span><br><span class="line">            <span class="string">'token'</span>: token</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>接口调用返回结果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu8.png" alt="qiniu"></p><h4 id="Vue-获取到token，进行上传文件"><a href="#Vue-获取到token，进行上传文件" class="headerlink" title="Vue(获取到token，进行上传文件)"></a>Vue(获取到token，进行上传文件)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input @change=<span class="string">"upload_qiniu"</span> type=<span class="string">"file"</span> &gt;</span><br><span class="line">        上传进度：&#123;&#123;fileload&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 七牛云token</span></span><br><span class="line">      uptoken:<span class="string">''</span>,</span><br><span class="line">      <span class="comment">// 进度条图片</span></span><br><span class="line">      fileload:<span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//注册组件标签</span></span><br><span class="line">  components:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.get_uptoken()</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="comment">// 获取七牛云凭证</span></span><br><span class="line">    get_uptoken()&#123;</span><br><span class="line">      getqiniu_get().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uptoken = res.token</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 上传七牛(图片)</span></span><br><span class="line">    upload_qiniu(e)&#123;</span><br><span class="line">      <span class="comment">// 获取文件对象</span></span><br><span class="line">      <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">      <span class="keyword">let</span> param = <span class="keyword">new</span> FormData();</span><br><span class="line">      <span class="comment">// 将上传凭证添加参数</span></span><br><span class="line">      param.append(<span class="string">'token'</span>,<span class="keyword">this</span>.uptoken);</span><br><span class="line">      <span class="comment">// 添加文件</span></span><br><span class="line">      param.append(<span class="string">'file'</span>,file);</span><br><span class="line">      <span class="comment">// 定制化axios</span></span><br><span class="line">      <span class="keyword">const</span> axios_qiniu = <span class="keyword">this</span>.axios.create(&#123;<span class="attr">withCredentials</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      <span class="comment">// 发送请求</span></span><br><span class="line">      axios_qiniu(&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        url:<span class="string">'http://up-z1.qiniu.com'</span>,</span><br><span class="line">        data:param,</span><br><span class="line">        timeout:<span class="number">30000</span>,</span><br><span class="line">        <span class="comment">// 上传进度</span></span><br><span class="line">        onUploadProgress:<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 计算</span></span><br><span class="line">          <span class="keyword">var</span> com = (e.loaded / e.total);</span><br><span class="line">          <span class="comment">// 判断</span></span><br><span class="line">          <span class="keyword">if</span>(com &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.fileload = (com * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="comment">// 请求结束</span></span><br><span class="line">        <span class="keyword">this</span>.fileload = <span class="string">'100%'</span></span><br><span class="line">        <span class="comment">// this.upload_video()</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>页面效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu9.png" alt="qiniu"></p><p>上传成功，返回值</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu10.png" alt="qiniu"></p><p><strong>注</strong>：此处的<code>key</code>与<code>hash</code>是可以与你七牛云的测试域名拼接访问更上传的文件的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/qiniu11.png" alt="qiniu"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实七牛云云存储实现起来并不难，主要是通过AK,SK获取上传的token</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB与相关命令</title>
      <link href="/2020/06/04/Note/MongoDB/"/>
      <url>/2020/06/04/Note/MongoDB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用MongoDB来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2013/10/mongodb-logo.png" alt="mongo"></p><p>MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性</p><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li><li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li><li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li><li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li><li>MongoDB安装简单。</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><a href="https://www.runoob.com/mongodb/mongodb-window-install.html" target="_blank" rel="noopener">Windows</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-linux-install.html" target="_blank" rel="noopener">Linux</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-osx-install.html" target="_blank" rel="noopener">Mac OSX</a></li></ul><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li><p>创建数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME <span class="comment">#如果数据库不存在，则创建数据库，否则切换到指定数据库。</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()  <span class="comment">#删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名。</span></span><br></pre></td></tr></table></figure></li><li><p>在表中插入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br><span class="line">或</span><br><span class="line">db.COLLECTION_NAME.save(document)</span><br><span class="line"><span class="comment">#save()：如果 _id 主键存在则更新数据，如果不存在就插入数据。该方法新版本中已废弃，可以使用 db.collection.insertOne() 或 db.collection.replaceOne() 来代替。</span></span><br><span class="line"><span class="comment">#insert(): 若插入的数据主键已经存在，则会抛 org.springframework.dao.DuplicateKeyException 异常，提示主键重复，不保存当前数据。</span></span><br></pre></td></tr></table></figure></li><li><p>修改表中数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">#query : update的查询条件，类似sql update查询内where后面的。</span></span><br><span class="line"><span class="comment">#update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的</span></span><br><span class="line"><span class="comment">#upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</span></span><br><span class="line"><span class="comment">#multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span></span><br><span class="line"><span class="comment">#writeConcern :可选，抛出异常的级别。</span></span><br></pre></td></tr></table></figure></li><li><p>删除表中数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">#query :（可选）删除的文档的条件。</span></span><br><span class="line"><span class="comment">#justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</span></span><br><span class="line"><span class="comment">#writeConcern :（可选）抛出异常的级别。</span></span><br></pre></td></tr></table></figure></li><li><p>查询表中数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br><span class="line"><span class="comment">#query ：可选，使用查询操作符指定查询条件</span></span><br><span class="line"><span class="comment">#projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</span></span><br></pre></td></tr></table></figure></li><li><p>条件操作符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&gt;) 大于 - $gt</span><br><span class="line">(&lt;) 小于 - $lt</span><br><span class="line">(&gt;=) 大于等于 - $gte</span><br><span class="line">(&lt;= ) 小于等于 - $lte</span><br></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.find().sort(&#123;KEY:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">#在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MongoDB快速开发文档：</p><ol><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://www.mongodb.com/cn" target="_blank" rel="noopener">官网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中文分词 jieba</title>
      <link href="/2020/06/04/Blog/jieba/"/>
      <url>/2020/06/04/Blog/jieba/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>Python有个模块可以将一段话中的关键词提取出来，支持中文简体，繁体分词，还支持自定义词库。 –它就是Python中文分词组件<strong>jieba</strong></p><p><code>jieba</code> 支持三种分词模式：精确模式、全模式和搜索引擎模式，下面是三种模式的特点。</p><p>精确模式：试图将语句最精确的切分，不存在冗余数据，适合做文本分析</p><p>全模式：将语句中所有可能是词的词语都切分出来，速度很快，但是存在冗余数据</p><p>搜索引擎模式：在精确模式的基础上，对长词再次进行切分</p><h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><ol><li><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>因为 <code>jieba</code> 是一个第三方库，所有需要我们在本地进行安装。</p><p>Windows 下使用命令安装：在联网状态下，在命令行下输入 <code>pip install jieba</code> 进行安装，安装完成后会提示安装成功</p><p>在 pyCharm 中安装：打开 <code>settings</code>，搜索 <code>Project Interpreter</code>，在右边的窗口选择 <code>+</code> 号，点击后在搜索框搜索 <code>jieba</code>，点击安装即可</p></li><li><h4 id="三种模式使用"><a href="#三种模式使用" class="headerlink" title="三种模式使用"></a>三种模式使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">seg_str = <span class="string">'好好学习，天天向上。'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.lcut(seg_str)))    <span class="comment"># 精简模式，返回一个列表类型的结果</span></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.lcut(seg_str, cut_all=<span class="literal">True</span>)))      <span class="comment"># 全模式，使用 'cut_all=True' 指定 </span></span><br><span class="line">print(<span class="string">"/"</span>.join(jieba.lcut_for_search(seg_str)))     <span class="comment"># 搜索引擎模式</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/jieba.png" alt="gitee"></p></li><li><h4 id="jieba-analyse的使用"><a href="#jieba-analyse的使用" class="headerlink" title="jieba.analyse的使用"></a>jieba.analyse的使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line">data = <span class="string">'Python是一种跨平台的计算机程序设计语言。 Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取标签(关键词，权重) topK(权重前五)  withWeight(使用权重)</span></span><br><span class="line"><span class="keyword">for</span> keyword,weight <span class="keyword">in</span> jieba.analyse.extract_tags(data,withWeight=<span class="literal">True</span>,topK=<span class="number">5</span>):</span><br><span class="line">print(<span class="string">'%s-%s'</span>%(keyword,weight))</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/jieba1.png" alt="gitee"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jieba特点</p><ol><li>精确模式，试图将句子最精确地切开，适合文本分析；</li><li>全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；</li><li>搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。</li><li>支持繁体分词</li><li>支持自定义词典</li><li>MIT 授权协议</li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django2.0.4与Vue递归组件实现无限极分类</title>
      <link href="/2020/06/03/Blog/Django2.0.4%E4%B8%8EVue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/"/>
      <url>/2020/06/03/Blog/Django2.0.4%E4%B8%8EVue%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>什么是无限极分类，按照我的理解，就是对数据完成多次分类，如同一棵树一样，从根开始，到主干、枝干、叶子……</p><p><strong>家谱树</strong></p><p>家谱树是无限极分类的表现形式之一。家谱，现在很多地方都流行起修家谱，那怎么修家谱，按照我理解，就是给自己找一个祖宗，一代代找上去，形成了一个体系，这样编篡而成的叫家谱。家谱树就与之类似，从某个节点开始向上寻找其父节点，再找父节点的父节点，直到找不到为止。按照这种寻找，形成的一个类似树状的结构，就叫做家谱树。</p><p>完成无限极分类，主要运用了两种方法，一是递归方式，二是迭代方式。而主要运用无限极分类的地方有商品无限极分类，无限极评论等等。</p><p>某博主的无限极评论</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2017/4/23/69a03461fb2a73909f17fa17a8def891?imageslim" alt="img"></p><p>京东的商品无限极分类</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/jd.png" alt="gitee"></p><p>接下来我们先来测试一个层级效果</p><p>创建一个测试文件test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自定义一个列表，已设置好层级关系</span></span><br><span class="line">mylist = [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'在线课程'</span>, <span class="string">'pid'</span>: <span class="number">0</span>, <span class="string">'child'</span>: [&#123;<span class="string">'id'</span>: <span class="number">2</span>, <span class="string">'name'</span>: <span class="string">'Python'</span>, <span class="string">'pid'</span>: <span class="number">1</span>&#125;]&#125;, &#123;<span class="string">'id'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Django'</span>, <span class="string">'pid'</span>: <span class="number">0</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个层级显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_dic</span><span class="params">(d,n_tab=<span class="number">-1</span>)</span>:</span></span><br><span class="line"><span class="comment"># 判断数据</span></span><br><span class="line"><span class="keyword">if</span> isinstance(d,list):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">list_dic(i,n_tab)</span><br><span class="line"><span class="keyword">elif</span> isinstance(d,dict):</span><br><span class="line">n_tab += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</span><br><span class="line">print(<span class="string">'&#123;&#125;&#123;&#125;'</span>.format(<span class="string">'\t'</span>*n_tab,key))</span><br><span class="line">list_dic(value,n_tab)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'&#123;&#125;&#123;&#125;'</span>.format(<span class="string">'\t'</span>*n_tab,d))</span><br><span class="line"></span><br><span class="line">list_dic(mylist)</span><br></pre></td></tr></table></figure><p>效果很明显</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/cjtest.png" alt="gitee"></p><h3 id="实现课程无限极分类"><a href="#实现课程无限极分类" class="headerlink" title="实现课程无限极分类"></a>实现课程无限极分类</h3><ol><li><p>在Django项目里的models.py创建一个商品模型类(我这里创建的字段有点多，你们可自行选择)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Courses</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"> <span class="comment">#主键 通过参数声明主键---必选</span></span><br><span class="line">    id = models.AutoField(primary_key=<span class="literal">True</span>)   </span><br><span class="line"><span class="comment"># 课程名称---必选</span></span><br><span class="line">name = models.CharField(max_length=<span class="number">200</span>,unique=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line">desc = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 类别</span></span><br><span class="line">category = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 课程图片</span></span><br><span class="line">img = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 层级ID---必选</span></span><br><span class="line">pid = models.IntegerField()</span><br><span class="line"><span class="comment"># 课程价格</span></span><br><span class="line">price = models.IntegerField(null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 是否删除</span></span><br><span class="line">is_delete = models.IntegerField(default=<span class="number">0</span>,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">db_table = <span class="string">'course'</span></span><br></pre></td></tr></table></figure></li><li><p>并在数据库中插入数据</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mysql.png" alt="gitee"></p></li><li><p>由于我的项目基于drf框架，所以需要添加一个序列化器。如果你的项目没有用drf，可以直接用json模块来进行序列化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="comment"># 数据库导入</span></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> Courses</span><br><span class="line"><span class="comment"># 课程序列化器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseSer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Courses</span><br><span class="line">        fields = <span class="string">"__all__"</span></span><br></pre></td></tr></table></figure></li><li><p>接下来写一个递归方法，用来给序列化出来的数据展现出层级结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Ctree</span><span class="params">(data)</span>:</span></span><br><span class="line">lists = []</span><br><span class="line">tree = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">tree[item[<span class="string">'id'</span>]] = item</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line"><span class="comment"># 判断顶级分类</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> i[<span class="string">'pid'</span>]:</span><br><span class="line">lists.append(tree[i[<span class="string">'id'</span>]])</span><br><span class="line"><span class="comment"># 子分类</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p_id = i[<span class="string">'pid'</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">'children'</span> <span class="keyword">not</span> <span class="keyword">in</span> tree[p_id]:</span><br><span class="line">tree[p_id][<span class="string">'children'</span>] = []</span><br><span class="line"><span class="comment"># 将子类填充到父类child里</span></span><br><span class="line">tree[p_id][<span class="string">'children'</span>].append(tree[i[<span class="string">'id'</span>]])</span><br><span class="line"><span class="keyword">return</span> lists</span><br></pre></td></tr></table></figure></li><li><p>接下来构造接口，从数据库中获取数据，并调用递归方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span><span class="params">(APIView)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">coures = Courses.objects.filter(is_delete=<span class="number">0</span>)</span><br><span class="line">coures_ser = CourseSer(coures,many=<span class="literal">True</span>).data</span><br><span class="line">mylist = Ctree(coures_ser)</span><br><span class="line">res = &#123;&#125;</span><br><span class="line">res[<span class="string">'code'</span>] = <span class="number">200</span></span><br><span class="line">res[<span class="string">'data'</span>] = mylist</span><br><span class="line"><span class="keyword">return</span> Response(res)</span><br></pre></td></tr></table></figure></li><li><p>通过测试接口，返回数据效果(由于数据太多不易截图，所以直接复制来了)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"code"</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:32:14"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Python"</span>,</span><br><span class="line">            <span class="string">"desc"</span>: <span class="string">"Python全套带回家"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">            <span class="string">"img"</span>: <span class="string">"1.jpg"</span>,</span><br><span class="line">            <span class="string">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"price"</span>: <span class="number">600</span>,</span><br><span class="line">            <span class="string">"is_delete"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:33:02"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Python初级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Python初级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"1.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">200</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"children"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"id"</span>: <span class="number">11</span>,</span><br><span class="line">                            <span class="string">"create_time"</span>: <span class="string">"2020-06-03T11:26:56"</span>,</span><br><span class="line">                            <span class="string">"name"</span>: <span class="string">"Python初级1"</span>,</span><br><span class="line">                            <span class="string">"desc"</span>: <span class="string">"Python初级1"</span>,</span><br><span class="line">                            <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">                            <span class="string">"img"</span>: <span class="string">"1.jpg"</span>,</span><br><span class="line">                            <span class="string">"pid"</span>: <span class="number">2</span>,</span><br><span class="line">                            <span class="string">"price"</span>: <span class="number">100</span>,</span><br><span class="line">                            <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:35:08"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Python中级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Python中级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"1.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">200</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:35:12"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Python高级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Python高级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"1.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">200</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:35:48"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Java"</span>,</span><br><span class="line">            <span class="string">"desc"</span>: <span class="string">"Java全套带回家"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"限免"</span>,</span><br><span class="line">            <span class="string">"img"</span>: <span class="string">"2.jpg"</span>,</span><br><span class="line">            <span class="string">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"price"</span>: <span class="number">400</span>,</span><br><span class="line">            <span class="string">"is_delete"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">6</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:36:20"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Java初级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Java初级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"限免"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"2.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">5</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">7</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:57:06"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Java中级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Java中级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"限免"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"2.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">5</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">8</span>,</span><br><span class="line">                    <span class="string">"create_time"</span>: <span class="string">"2020-06-03T09:57:13"</span>,</span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"Java高级"</span>,</span><br><span class="line">                    <span class="string">"desc"</span>: <span class="string">"Java高级"</span>,</span><br><span class="line">                    <span class="string">"category"</span>: <span class="string">"限免"</span>,</span><br><span class="line">                    <span class="string">"img"</span>: <span class="string">"2.jpg"</span>,</span><br><span class="line">                    <span class="string">"pid"</span>: <span class="number">5</span>,</span><br><span class="line">                    <span class="string">"price"</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">"create_time"</span>: <span class="string">"2020-06-03T11:17:34"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Ubuntu"</span>,</span><br><span class="line">            <span class="string">"desc"</span>: <span class="string">"Ubuntu全套带回家"</span>,</span><br><span class="line">            <span class="string">"category"</span>: <span class="string">"会员"</span>,</span><br><span class="line">            <span class="string">"img"</span>: <span class="string">"3.jpg"</span>,</span><br><span class="line">            <span class="string">"pid"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"price"</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="string">"is_delete"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口没问题，接下来就要在前端实现效果了，我们使用vue递归组件实现效果</p><p>所谓递归组件: 就是组件可以在它们自己的模板中调用自身，不过它们只能通过 name 选项来做这件事，例如给组件设置属性 name: ‘Reply’，然后在模板中就可以使用 Reply 调用自己进行递归调用了</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reply.vue 这是个组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#x2F;&#x2F; 由于数据太多，只显示个名称就可以看到效果了</span><br><span class="line">        &lt;div :class&#x3D;&quot;[data.id&#x3D;&#x3D;0 ? &#39;root&#39;: &#39;&#39;, &#39;reply&#39;]&quot;&gt;&#123;&#123; data.name &#125;&#125;</span><br><span class="line">        &lt;li &gt;</span><br><span class="line">            &lt;ul v-if&#x3D;&quot;data.children &amp;&amp; data.children.length&gt;0&quot;&gt;</span><br><span class="line">                &lt;Reply v-for&#x3D;&quot;child in data.children&quot; :key&#x3D;&quot;child.id&quot; :data&#x3D;&quot;child&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;Reply&#39;, &#x2F;&#x2F; 递归组件需要设置 name 属性，才能在模板中调用自己</span><br><span class="line">        props:[&#39;data&#39;],</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;style &gt;</span><br><span class="line">    .reply &#123;</span><br><span class="line">        padding-left: 4px;</span><br><span class="line">        border-left: 1px solid #eee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul &#123;</span><br><span class="line">            padding-left: 20px;</span><br><span class="line">            list-style: none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .root &#123; display: none; &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>最后在其他任意组件中调用Reply.vue组件，传入数据即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;    </span><br><span class="line">                &lt;span v-for&#x3D;&quot;i in datas&quot;&gt;</span><br><span class="line">                  &lt;Reply  :data&#x3D;&quot;i&quot; &#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;span&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Reply from &#39;.&#x2F;comm&#x2F;Reply.vue&#39;;</span><br><span class="line">&#x2F;&#x2F; 我这里的axios接口进行过封装，可以直接调用，这样可以省去大量axios请求接口</span><br><span class="line">import &#123; courselist_get &#125; from &#39;.&#x2F;axios_api&#x2F;api&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123; </span><br><span class="line">          datas:&#123;&#125;,</span><br><span class="line">          online: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &#39;Reply&#39;:Reply,</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.load()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        load()&#123;</span><br><span class="line">      courselist_get().then(res&#x3D;&gt;&#123;</span><br><span class="line">        if(res.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">          this.datas &#x3D; res.data</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li><li><p>调用接口，查看效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/cexiao.png" alt="gitee"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用vue递归组件我们需要注意：</p><ol><li>组件必须含有 name 这个属性,因为没有 name 这个属性会造成控件自身不能调用自身,自身调用的时候最好有绑定 key ,因为这个 key 是唯一的标识,对于 vue   更新控件比较好.除非控件非常简单就不用 key.</li><li>另外一个需要注意就是递归组件时候,需要有一个条件来终止递归,在这里使用 v-for 隐形条件终止递归. props 这个属性其实主要传递父控件的数据的参数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归详解</title>
      <link href="/2020/06/03/Blog/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/06/03/Blog/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><h4 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h4><p><a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">递归</a>，就是在运行的过程中调用自己。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。</p><p>语言例子：</p><ol><li><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/v2-83e505b87aa8ea31a36c33a01e816599_r.jpg" alt="img"></p></li><li><p>一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到：“一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到：‘一只狗来到厨房，偷走一小块面包。厨子举起杓子，把那只狗打死了。于是所有的狗都跑来了，给那只狗掘了一个坟墓，还在墓碑上刻了墓志铭，让未来的狗可以看到……’”</p></li><li><p><a href="https://baike.baidu.com/item/%E9%87%8E%E6%AF%94%E5%A4%A7%E9%9B%84" target="_blank" rel="noopener">大雄</a>在房里，用时光电视看着从前的情况。电视画面中的那个时候，他正在房里，用时光电视，看着从前的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着从前的情况……</p></li></ol><p>代码例子：(最常见的就是斐波那契数列)</p><p>斐波那契数列 {1 1 2 3 5 8 13…n}</p><p>数学好的同学可能很容易就找到规律了：<strong>前两项之和等于第三项</strong></p><p>如果让我们求出第n项是多少，那么我们就可以很简单写出对应的递归表达式了：<code>Z = (n-2) + (n-1)</code></p><p>递归出口在本题目是需要有两个的，因为<strong>它是前两项加起来才得出第三项的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 + 1 &#x3D; 2</span><br><span class="line">1 + 2 &#x3D; 3</span><br><span class="line">2 + 3 &#x3D; 5</span><br><span class="line">3 + 5 &#x3D; 8</span><br></pre></td></tr></table></figure><p>同样地，那么我们的递归出口可以写成这样：<code>if(n==1) retrun 1 if(n==2) return 2</code></p><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feibo</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> feibo(n<span class="number">-1</span>) + feibo(n<span class="number">-2</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">print(feibo(i))</span><br></pre></td></tr></table></figure><h4 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h4><p>优点</p><ol><li>简洁</li><li>在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。</li><li>递归函数维持着一个保存每次递归调用当前状态的栈，允许函数获得子问题的结果后继续处理。</li></ol><p>缺点</p><ol><li><p>每次进入更深一层递归时，问题规模比上次递归都有所减少 。-&gt;效率</p></li><li><p>调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。-&gt;性能</p><p>栈溢出解决办法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改递归深度的值</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算。-&gt;效率</p></li><li><p>递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。-&gt;效率</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>递归思想说白了就是<a href="https://baike.baidu.com/item/%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4" target="_blank" rel="noopener">逆向思维</a>，在大部分情况下，人们所想的是都是片面，也就是有局限性。逆向思维就是突破这个局限性，从另一方面去想怎么解决这个事情。</p><p>比如我们小时候耳熟能详的故事–<a href="https://baike.baidu.com/item/%E5%8F%B8%E9%A9%AC%E5%85%89%E7%A0%B8%E7%BC%B8/10072914" target="_blank" rel="noopener">司马光砸缸</a></p><p>关于司马光砸缸：<br>讲述了司马光砸坏水缸，救出同伴的故事。<br>在大部分情况下的人，当时所想的是如何让人脱离水，从而救出人。<br>我们通过逆向思维，想到也可以使水脱离人，从而脱救，于是把水缸砸坏，使水流光从而进行救助。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django2.0.4与Vue联合实现Gitee(码云)三方登陆，以及什么是OAuth2.0认证和授权机制基本流程</title>
      <link href="/2020/06/02/Blog/gitee%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/"/>
      <url>/2020/06/02/Blog/gitee%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.baidu.com/item/开源中国" target="_blank" rel="noopener">码云(Gitee)</a>,一款强大的代码托管、质量检测、代码演示、团队协作等开发工具集成到云平台，为了构建更好的码云生态环境，推出了基于OAuth2的API V5版本。</p><h3 id="码云三方登陆"><a href="#码云三方登陆" class="headerlink" title="码云三方登陆"></a>码云三方登陆</h3><h4 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h4><ol><li><p>首先，我们注册<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a></p></li><li><p>创建完成之后点击<code>个人头像</code>，找到<code>设置</code></p></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee1.png" alt="gitee"></p><ol start="3"><li>在<code>设置</code>里找到<code>第三方应用</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee2.jpg" alt="gitee"></p><ol start="4"><li>点击<code>创建应用</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee3.png" alt="gitee"></p><ol start="5"><li><code>应用名称</code>，<code>应用描述</code>，<code>应用主页</code>，<code>回调地址</code>根据自己定义修改</li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee6.png" alt="gitee"></p><ol start="6"><li>创建完毕之后，会给你<code>APPID</code>与<code>APPkey</code>，这两样要记住</li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee7.png" alt="gitee"></p><ol start="7"><li>之后的路程可以参照<a href="https://gitee.com/api/v5/oauth_doc#/" target="_blank" rel="noopener">Gitee开发文档</a></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li><p>Vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数名()&#123;</span><br><span class="line">        var appid &#x3D; &#39;APPID&#39;</span><br><span class="line">        var redirect_uri &#x3D; &#39;码云回调地址&#39;</span><br><span class="line">        &#x2F;&#x2F; 构造url</span><br><span class="line">        var url &#x3D; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;oauth&#x2F;authorize?client_id&#x3D;&#39;+appid+&#39;&amp;redirect_uri&#x3D;&#39;+redirect_uri+&#39;&amp;response_type&#x3D;code&#39;</span><br><span class="line">        &#x2F;&#x2F; 进行跳转</span><br><span class="line">        window.location.href &#x3D; url;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Django</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayunBack</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 获取code参数</span></span><br><span class="line">        code = request.GET.get(<span class="string">"code"</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 发起调用，获取access_token</span></span><br><span class="line">        res = requests.post(<span class="string">"https://gitee.com/oauth/token?grant_type=authorization_code&amp;code=%s&amp;client_id=APPID&amp;redirect_uri=http://localhost:8000/gitee_back&amp;client_secret=APPKEY"</span> % code)</span><br><span class="line">        print(res.text)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(res.text)</span><br></pre></td></tr></table></figure></li><li><p>在获取到<code>access_token</code>之后，我们来获取Gitee的授权用户名，进入<a href="https://gitee.com/api/v5/oauth_doc#/" target="_blank" rel="noopener">Gitee开发文档</a>，点击<code>API文档</code></p></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee4.png" alt="gitee"></p><ol start="4"><li>找到<code>获取授权用户的资料</code>并打开，点击右上角<code>申请授权</code>，就可以获取到授权用户的用户名了</li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gitee5.png" alt="gitee"></p><ol start="5"><li><p>代码获取(将上面获取到的access_token传入url)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res_token = requests.get(<span class="string">"https://gitee.com/api/v5/user?access_token="</span>+access_token)</span><br><span class="line">    res_token_dict = json.loads(res_token.text)</span><br><span class="line">    name = res_token_dict[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li></ol><h3 id="OAuth2-0认证和授权机制基本流程"><a href="#OAuth2-0认证和授权机制基本流程" class="headerlink" title="OAuth2.0认证和授权机制基本流程"></a>OAuth2.0认证和授权机制基本流程</h3><p><strong>OAuth2.0</strong></p><p>第三方登录是应用开发中的常用功能，通过第三方登录，我们可以更加容易的吸引用户来到我们的应用中。现在，很多网站都提供了第三方登录的功能，在他们的官网中，都提供了如何接入第三方登录的文档。但是，不同的网站文档差别极大，各种第三方文档也是千奇百怪，同时，很多网站提供的SDK用法也是各不相同。对于不了解第三方登录的新手来说，实现一个支持多网站第三方登录的功能可以说是极其痛苦。</p><p>实际上，大多数网站提供的第三方登录都遵循OAuth协议，虽然大多数网站的细节处理都是不一致的，甚至会基于OAuth协议进行扩展，但大体上其流程是一定的。今天，我们就来看看基于OAuth2的第三方登陆功能是这样一个流程。</p><p><strong>OAuth2.0的基本流程</strong></p><p>OAuth协议目前已经升级到了2.0，大部分的网站也是支持OAuth2.0的，因此让我们先看看OAuth2。</p><p><img src= "/img/loading.gif" data-src="https://pic2.zhimg.com/80/5e27c9064ca22c7e54a1d395d679f8b5_720w.jpg" alt="oau"></p><p>上图中所涉及到的对象分别为：</p><ul><li>Client 第三方应用，我们的应用就是一个Client</li><li>Resource Owner 资源所有者，即用户</li><li>Authorization Server 授权服务器，即提供第三方登录服务的服务器，如Github</li><li>Resource Server 拥有资源信息的服务器，通常和授权服务器属于同一应用</li></ul><p>根据上图的信息，我们可以知道OAuth2的基本流程为：</p><ol><li>第三方应用请求用户授权。</li><li>用户同意授权，并返回一个凭证（code）</li><li>第三方应用通过第二步的凭证（code）向授权服务器请求授权</li><li>授权服务器验证凭证（code）通过后，同意授权，并返回一个资源访问的凭证（Access Token）。</li><li>第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</li><li>资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，码云登陆接入相对于新浪而言简单了许多</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django2.0.4与Vue联合实现钉钉三方扫码登陆</title>
      <link href="/2020/06/02/Blog/%E9%92%89%E9%92%89%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/"/>
      <url>/2020/06/02/Blog/%E9%92%89%E9%92%89%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.baidu.com/item/钉钉" target="_blank" rel="noopener">钉钉</a>，学生党的噩梦，是<a href="https://baike.baidu.com/item/阿里巴巴集团/9087864" target="_blank" rel="noopener">阿里巴巴集团</a>专为<a href="https://baike.baidu.com/item/中国企业/12412310" target="_blank" rel="noopener">中国企业</a>打造的<a href="https://baike.baidu.com/item/免费/131326" target="_blank" rel="noopener">免费</a>沟通和协同的多端平台，帮助中国企业通过系统化的解决方案，全方位提升中国企业沟通和协同效率</p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><ol><li>首先注册<a href="https://ding-doc.dingtalk.com/" target="_blank" rel="noopener">钉钉开发者平台</a>，成功之后登陆</li></ol><ol start="2"><li>登陆成功，进入<code>应用开发</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/ding1.png" alt="gitee"></p><ol start="3"><li>找到<code>移动接入应用</code>，进入<code>登陆</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/ding2.png" alt="gitee"></p><ol start="4"><li><code>创建扫码登录应用授权</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/ding3.png" alt="gitee"></p><ol start="5"><li><code>LOGO地址</code>就是你钉钉三方登陆的图片地址。<code>回调域名</code>可以自己设置</li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/ding4.png" alt="gitee"></p><ol start="6"><li>创建成功之后，会给你专属<code>APPID</code>,<code>APPKEY</code></li></ol><p>   <img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/ding5.png" alt="gitee"></p><h3 id="代码接入"><a href="#代码接入" class="headerlink" title="代码接入"></a>代码接入</h3><ol><li><p>Vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数名()&#123;</span><br><span class="line">        var appid &#x3D; &#39;APPID&#39;</span><br><span class="line">    var redirect_uri &#x3D; &#39;钉钉回调地址&#39;</span><br><span class="line">    &#x2F;&#x2F; 构成url</span><br><span class="line">var url &#x3D; &#39;https:&#x2F;&#x2F;oapi.dingtalk.com&#x2F;connect&#x2F;qrconnect?appid&#x3D;&#39;+appid+&#39;&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;STATE&amp;redirect_uri&#x3D;&#39;+redirect_uri</span><br><span class="line">&#x2F;&#x2F; 跳转</span><br><span class="line">window.location.href &#x3D; url;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>Django</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构造钉钉回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ding_back</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#获取code</span></span><br><span class="line">    code = request.GET.get(<span class="string">"code"</span>)</span><br><span class="line">    t = time.time()</span><br><span class="line">    <span class="comment">#时间戳</span></span><br><span class="line">    timestamp = str((int(round(t * <span class="number">1000</span>))))</span><br><span class="line">    appSecret =<span class="string">'钉钉APPkey'</span></span><br><span class="line">    <span class="comment">#构造签名</span></span><br><span class="line">    signature = base64.b64encode(hmac.new(appSecret.encode(<span class="string">'utf-8'</span>),timestamp.encode(<span class="string">'utf-8'</span>), digestmod=sha256).digest())</span><br><span class="line">    <span class="comment">#请求接口，换取钉钉用户名</span></span><br><span class="line">    payload = &#123;<span class="string">'tmp_auth_code'</span>:code&#125;</span><br><span class="line">    headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;</span><br><span class="line">    res = requests.post(<span class="string">'https://oapi.dingtalk.com/sns/getuserinfo_bycode?signature='</span>+urllib.parse.quote(signature.decode(<span class="string">"utf-8"</span>))+<span class="string">"&amp;timestamp="</span>+timestamp+<span class="string">"&amp;accessKey=钉钉APPID"</span>,data=json.dumps(payload),headers=headers)</span><br><span class="line">    <span class="comment">#将JSON 字符串解码为 Python 对象   </span></span><br><span class="line">    res_dict = json.loads(res.text)</span><br><span class="line">    <span class="comment">#获取用户名</span></span><br><span class="line">    name = res_dict[<span class="string">'user_info'</span>][<span class="string">'nick'</span>]</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(name)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django2.0.4与Vue联合实现新浪微博三方登陆</title>
      <link href="/2020/06/02/Blog/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/"/>
      <url>/2020/06/02/Blog/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.baidu.com/item/微博/79614" target="_blank" rel="noopener">微博</a>，又名微型博客，指的是一种基于用户关系信息分享、传播以及通过关注机制分享简短实时信息的广播式的<a href="https://baike.baidu.com/item/社交媒体/1085698" target="_blank" rel="noopener">社交媒体</a>、<a href="https://baike.baidu.com/item/网络平台/24446534" target="_blank" rel="noopener">网络平台</a>。与国外<a href="https://baike.baidu.com/item/twitter" target="_blank" rel="noopener">Twitter</a>、<a href="https://baike.baidu.com/item/Facebook?fromtitle=%E8%84%B8%E4%B9%A6&fromid=3462463" target="_blank" rel="noopener">Facebook</a>相似，在我国被广大年轻人喜爱。</p><h3 id="新浪微博三方登陆"><a href="#新浪微博三方登陆" class="headerlink" title="新浪微博三方登陆"></a>新浪微博三方登陆</h3><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><ol><li><p>首先<code>注册</code>、<code>登陆</code><a href="https://open.weibo.com/" target="_blank" rel="noopener">微博开放平台</a></p></li><li><p>登陆之后，在<code>微连接</code>找到<code>网站接入</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina1.png" alt="gitee"></p></li><li><p>进入，点击<code>立即接入</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina2.png" alt="gitee"></p></li><li><p>设置自己的<code>应用名称</code>，将<code>应用分类</code>设置成<code>网页应用</code>，点击<code>创建</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina3.png" alt="gitee"></p></li><li><p>下面这些我们不需要管，记住自己的APPID与APPKey，之后点击<code>高级设置</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina4.png" alt="gitee"></p></li><li><p>设置<code>授权回调地址</code>和<code>取消授权回调地址</code>，可以自由更改</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina5.png" alt="gitee"></p></li><li><p>由于新浪微博规定如果不通过审核，那么新浪有些接口无权限请求的，可以说你手里只有access_token和uid，却换不到别的东西。所有我们要设置其他东西，点击<code>测试信息</code>,将个人的账号添加到测试里，就可以请求相应的接口。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sina6.png" alt="gitee"></p></li></ol><h4 id="代码接入"><a href="#代码接入" class="headerlink" title="代码接入"></a>代码接入</h4><ol><li><p>Vue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数名:()&#123;</span><br><span class="line">&#x2F;&#x2F; 组装url</span><br><span class="line">let url &#x3D; &quot;https:&#x2F;&#x2F;api.weibo.com&#x2F;oauth2&#x2F;authorize?client_id&#x3D;&#39;APPID&#39;&amp;redirect_uri&#x3D;&#39;回调地址&#39;&quot;;</span><br><span class="line">&#x2F;&#x2F;跳转</span><br><span class="line">window.location.href &#x3D; url;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>Django</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_back</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 获取code</span></span><br><span class="line">    code = request.GET.get(<span class="string">'code'</span>)</span><br><span class="line">    <span class="comment"># 定义微博认证地址</span></span><br><span class="line">    access_token_url = <span class="string">"https://api.weibo.com/oauth2/access_token"</span></span><br><span class="line">    <span class="comment"># 参数</span></span><br><span class="line">    res = requests.post(</span><br><span class="line">        access_token_url,</span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">"client_id"</span>: <span class="string">'APPID'</span>,</span><br><span class="line">            <span class="string">"client_secret"</span>: <span class="string">"APPKey"</span>,</span><br><span class="line">            <span class="string">"grant_type"</span>: <span class="string">"authorization_code"</span>,</span><br><span class="line">            <span class="string">"code"</span>: code,</span><br><span class="line">            <span class="string">"redirect_uri"</span>: <span class="string">"微博回调地址"</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 转化类型</span></span><br><span class="line">    res = json.loads(res.text)</span><br><span class="line">    <span class="comment"># 换取新浪微博昵称</span></span><br><span class="line">    result = requests.get(<span class="string">'https://api.weibo.com/2/users/show.json'</span>,</span><br><span class="line">                          params=&#123;<span class="string">'access_token'</span>: res[<span class="string">'access_token'</span>], <span class="string">'uid'</span>: res[<span class="string">'uid'</span>]&#125;)</span><br><span class="line">    result = json.loads(result.text)</span><br><span class="line">    name = result[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery_Error</title>
      <link href="/2020/06/01/Note/celery_error/"/>
      <url>/2020/06/01/Note/celery_error/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、错误"><a href="#一、错误" class="headerlink" title="一、错误"></a>一、错误</h3><p>前几天给Django配置了Celery,使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A celery_task -l info -P eventlet</span><br></pre></td></tr></table></figure><p>启动Celery,没有使用POST方法测试</p><p>今天测试使用了下POST，当我启动服务访问时：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/celeryerror.png" alt="error"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: wrap_socket() got an unexpected keyword argument <span class="string">'_context'</span></span><br></pre></td></tr></table></figure><p>出现了错误</p><h3 id="二、解决"><a href="#二、解决" class="headerlink" title="二、解决"></a>二、解决</h3><p>requests包的requests.post发送后，传不回数据</p><p>所以，在改变服务器启动方法不要用eventlet，加个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A celery_task -l info -P=solo</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/2020/05/31/Note/jwt/"/>
      <url>/2020/05/31/Note/jwt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h2><ol><li><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></li><li><p>组成:</p><p> header.payload.signature 头.载荷.签名</p></li><li><p>介绍：</p><p>​    ①、 header：一般存放如何处理token的方式：声明类型，声明加密的算法 </p><p>​    ②、payload：数据的主体部分：用户信息、发行者、过期时间等</p><p>​    ③、 signature：签名：这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，    然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p></li><li><p>将这三部分连接成一个完整的jwt：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6Im93ZW4iLCJleHAiOjE1NTgzMDM1NDR9<span class="number">.4j</span>5QypLwufjpqoScwUB9LYiuhYcTw1y4dPrvnv7DUyo</span><br></pre></td></tr></table></figure></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>jwt = base64(头部).base64(载荷).hash256(base64(头部).base(载荷).密钥)</li><li>base64是可逆的算法、hash256是不可逆的算法</li><li>密钥是固定的字符串，保存在服务器</li></ol><h2 id="为什么要用JWT"><a href="#为什么要用JWT" class="headerlink" title="为什么要用JWT"></a>为什么要用JWT</h2><ol><li><p>传统的session认证：</p><p>当用户登陆时，登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</p></li><li><p>基于token的鉴权机制：</p><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p></li></ol><h2 id="如何使用JWT"><a href="#如何使用JWT" class="headerlink" title="如何使用JWT"></a>如何使用JWT</h2><p><a href="https://github.com/jpadilla/django-rest-framework-jwt" target="_blank" rel="noopener">官方文档</a></p><h3 id="安装子虚拟环境"><a href="#安装子虚拟环境" class="headerlink" title="安装子虚拟环境"></a>安装子虚拟环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="使用：urls-py"><a href="#使用：urls-py" class="headerlink" title="使用：urls.py"></a>使用：urls.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.views <span class="keyword">import</span> obtain_jwt_token</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'login/'</span>, obtain_jwt_token),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="测试接口：POST请求"><a href="#测试接口：POST请求" class="headerlink" title="测试接口：POST请求"></a>测试接口：POST请求</h3><p>postman发送post请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口：http://api.luffy.cn:<span class="number">8000</span>/user/login/</span><br><span class="line"></span><br><span class="line">数据：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"username"</span>:<span class="string">"admin"</span>,</span><br><span class="line">    <span class="string">"password"</span>:<span class="string">"admin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h3 id="配置信息：settings-py"><a href="#配置信息：settings-py" class="headerlink" title="配置信息：settings.py"></a>配置信息：settings.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_AUTH_HEADER_PREFIX'</span>: <span class="string">'JWT'</span>,</span><br><span class="line">    <span class="comment"># 过期时间</span></span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">    <span class="comment"># 自定义认证结果：见下方序列化user和自定义response</span></span><br><span class="line">    <span class="string">'JWT_RESPONSE_PAYLOAD_HANDLER'</span>: <span class="string">'user.utils.jwt_response_payload_handler'</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化USER：serializers-py-自己创建"><a href="#序列化USER：serializers-py-自己创建" class="headerlink" title="序列化USER：serializers.py(自己创建)"></a>序列化USER：serializers.py(自己创建)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModelSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""轮播图序列化器"""</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = [<span class="string">"username"</span>, <span class="string">"mobile"</span>]</span><br></pre></td></tr></table></figure><h3 id="自定义response：user-py"><a href="#自定义response：user-py" class="headerlink" title="自定义response：user.py"></a>自定义response：user.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> UserModelSerializers</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jwt_response_payload_handler</span><span class="params">(token, user=None, request=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'token'</span>: token,</span><br><span class="line">        <span class="string">'user'</span>: UserModelSerializer(user).data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># restful 规范</span></span><br><span class="line">    <span class="comment"># return &#123;</span></span><br><span class="line">    <span class="comment">#     'status': 0,</span></span><br><span class="line">    <span class="comment">#     'msg': 'OK',</span></span><br><span class="line">    <span class="comment">#     'data': &#123;</span></span><br><span class="line">    <span class="comment">#         'token': token,</span></span><br><span class="line">    <span class="comment">#         'username': user.username</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br></pre></td></tr></table></figure><h3 id="在登陆的时候使用：user-py"><a href="#在登陆的时候使用：user-py" class="headerlink" title="在登陆的时候使用：user.py"></a>在登陆的时候使用：user.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成jwt</span></span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure><h3 id="解析token中的数据：user-py"><a href="#解析token中的数据：user-py" class="headerlink" title="解析token中的数据：user.py"></a>解析token中的数据：user.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取token</span></span><br><span class="line">jwt_token = request.GET.get(<span class="string">"token"</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="comment">#解析数据</span></span><br><span class="line">user_json = jwt_decode_handler(jwt_token)</span><br><span class="line"><span class="comment"># 获取token中的uid</span></span><br><span class="line">user_id = user_json.get(<span class="string">"user_id"</span>)</span><br></pre></td></tr></table></figure><h3 id="多方式登录：user-py"><a href="#多方式登录：user-py" class="headerlink" title="多方式登录：user.py"></a>多方式登录：user.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JWTModelBackend</span><span class="params">(ModelBackend)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request, username=None, password=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :param username: 前台传入的用户名</span></span><br><span class="line"><span class="string">        :param password: 前台传入的密码</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r'^1[3-9]\d&#123;9&#125;$'</span>, username):</span><br><span class="line">                user = User.objects.get(mobile=username)</span><br><span class="line">            <span class="keyword">elif</span> re.match(<span class="string">r'.*@.*'</span>, username):</span><br><span class="line">                user = User.objects.get(email=username)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                user = User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 认证失败就返回None即可，jwt就无法删除token</span></span><br><span class="line">        <span class="comment"># 用户存在，密码校验通过，是活着的用户 is_active字段为1</span></span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">and</span> user.check_password(password) <span class="keyword">and</span> self.user_can_authenticate(user):</span><br><span class="line">            <span class="keyword">return</span> user  <span class="comment"># 认证通过返回用户，交给jwt生成token</span></span><br></pre></td></tr></table></figure><h3 id="配置多方式登录：settings-py"><a href="#配置多方式登录：settings-py" class="headerlink" title="配置多方式登录：settings.py"></a>配置多方式登录：settings.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS = [<span class="string">'user.JWTModelBackend'</span>]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</p><p>2.因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</p><p>3.便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</p><p>4.它不需要在服务端保存会话信息, 所以它易于应用的扩展</p><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>1.不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</p><p>2.保护好secret私钥，该私钥非常重要。</p><p>3.如果可以，请使用https协议</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thunder无版权</title>
      <link href="/2020/05/31/Live/Thunder%E4%B8%8B%E8%BD%BD%E6%97%A0%E7%89%88%E6%9D%83/"/>
      <url>/2020/05/31/Live/Thunder%E4%B8%8B%E8%BD%BD%E6%97%A0%E7%89%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、序幕"><a href="#一、序幕" class="headerlink" title="一、序幕"></a>一、序幕</h3><p>再现当今各大影视平台推出的各种VIP制度，使我们是我们这些‘穷人’已无法生存。</p><p>于是出现了<a href="https://baike.baidu.com/item/BT种子" target="_blank" rel="noopener">BT种子</a>，在这个BT种子泛滥的时代，影视VIP已经在有的人心中抹去。</p><p>说道BT种子好像很多男人都很喜欢比如：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/%E4%B8%8B%E8%BD%BD.jpg" alt="img"></p><p>这个。。。。真是太棒了！！！</p><p><img src= "/img/loading.gif" data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590941992507&di=63b5d874d792dc40037d532a08e1ca9d&imgtype=0&src=http%3A%2F%2Fwww.baduqq.com%2Fuploads%2Fallimg%2F121219%2F225400E37-9.gif" alt="img"></p><p>有了BT种子我们还需要有一个解析工具<a href="https://baike.baidu.com/item/迅雷/33354" target="_blank" rel="noopener">迅雷(Thunder)</a>，迅雷应该是大多数人的电脑或者手机里必备的软件吧！！</p><p>但是：</p><p><img src= "/img/loading.gif" data-src="https://pic4.zhimg.com/80/v2-d5d664989af1c5915c32241df9f71f83_720w.jpg" alt="img"></p><p>这个是不是很讨厌。。</p><hr><h3 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h3><p>同样，今天我一如既往的在网上搜索BT种子：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder3.png" alt="img"></p><p>来到迅雷解析：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder1.png" alt="img"></p><p>这。。。这又不是什么搞颜色的视频，为啥也没有版权？？</p><p>之后，我在网上一顿操作，找到了解决办法！！</p><hr><h3 id="三、解决"><a href="#三、解决" class="headerlink" title="三、解决"></a>三、解决</h3><ul><li><p>首先我们先下载BT种子到桌面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder2.png" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder3.png" alt="img"></p></li><li><p>之后我们来到百度云盘（可以是网页版的，也可以是端游版的，我用的是网页版的）</p></li><li><p>找到离线下载</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder4.png" alt="img"></p></li><li><p>进去，点击新建BT任务</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder5.png" alt="img"></p></li><li><p>找到你的BT种子位置，并打开</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder6.png" alt="img"></p></li><li><p>之后选择视频文件，开始下载</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder7.png" alt="img"></p></li><li><p>可以看到下载速度是非常快的（我用的是网页版的，客户端应该会更快）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder8.png" alt="img"></p></li><li><p>下载完成，点击播放</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder9.png" alt="img"></p></li><li><p>就可以开开心心的看电影了（悄悄拿上纸巾）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/live/Thunder10.png" alt="img"></p></li></ul><p>是不是帮你们解决了没有女朋友的问题呢</p><p><img src= "/img/loading.gif" data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590941992507&di=63b5d874d792dc40037d532a08e1ca9d&imgtype=0&src=http%3A%2F%2Fwww.baduqq.com%2Fuploads%2Fallimg%2F121219%2F225400E37-9.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 · 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《绿皮书》：拿到奥斯卡最佳影片，就因为“涉黑”?</title>
      <link href="/2020/05/30/Movie/Green%20Book/"/>
      <url>/2020/05/30/Movie/Green%20Book/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><em>不管是在上届届奥斯卡颁奖典礼之前，还是在颁奖典礼之后，对于《绿皮书》能够拿到最佳影片奖，很多人都不会感到稀奇。貌似打上届届奥斯卡获奖提名名单一曝光，《绿皮书》就已经内定，不管是同样大热门的《罗马》，还是其他六部电影，都像是可怜的陪跑运动员，没有丝毫挣扎的可能性。</em></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/green.png" alt="move"></p><p>不管是在上届届奥斯卡颁奖典礼之前，还是在颁奖典礼之后，对于《绿皮书》能够拿到最佳影片奖，很多人都不会感到稀奇。</p><p>貌似打上届届奥斯卡获奖提名名单一曝光，《绿皮书》就已经内定，不管是同样大热门的《罗马》，还是其他六部电影，都像是可怜的陪跑运动员，没有丝毫挣扎的可能性。</p><p>《黑豹》看似有着纯正的黑皮肤，但是说到底，它也只是一部漫威超级英雄电影。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/heibao.jpg" alt="move"></p><p>《绿皮书》是一种均衡，它不仅为学院的评委们提供了一组最大公约数，而且，它也让观众在观看的瞬间品尝到了百香果的滋味，用舌头尝，是甜，用牙齿咬，是脆。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>《绿皮书》是由彼得·法拉利执导，维果·莫特森、马赫沙拉·阿里主演的剧情片，于2018年9月11日在多伦多国际电影节首映；2019年3月1日在中国内地上映。</p><p>该片改编自真人真事，讲述了保镖托尼被聘用为世界上优秀的爵士钢琴家唐开车。钢琴家将从纽约开始举办巡回演奏，俩人之间一段跨越种族、阶级的友谊的故事。</p><h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><p>托尼由于夜总会关门装修，也亟需一份工作。有个朋友建议他去参加一位音乐博士为了寻找司机所举办的面试。当他到达豪华公寓后，发现这位博士是个名叫唐的黑人古典乐钢琴家，钢琴家正需要一个司机，负责在他举办南方巡演时的接送工作。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/green1.png" alt="move"></p><p>当然，两人心里都十分清楚，在二十世纪六十年代种族隔离严重的南部地区，他们很容易身陷麻烦之中，但托尼需要钱，而唐需要一个能照顾他的专业司机。给托尼付钱的唱片公司给了他一本“绿皮书”指南，上面列着当地黑人可以吃饭睡觉的地方，因为很多旅馆和餐厅都是只限白人。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:EE565D3FC1721A9DF468CC6DC4A3467CBF6EE54B</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode插件-Draw.io</title>
      <link href="/2020/05/30/Blog/vscode%E6%8F%92%E4%BB%B6-Draw.io/"/>
      <url>/2020/05/30/Blog/vscode%E6%8F%92%E4%BB%B6-Draw.io/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近呢，每次写代码之前都必须要画流程图，再画的时候很是烦恼，使用<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>效果很好，但是有文件数量限制，如果想要增加数量的话还必须花钱，这就很烦恼，于是我找到一款非常棒的VSCode的插件–Draw.io</p><hr><p>作为一款开源的主流代码编辑器，VSCode 在发布之后一直受到不少开发者的喜爱。</p><p>VSCode，它不仅有提升开发体验的界面、轻量化的编辑器，还有丰富而强大的插件，超多的插件让水友调侃道，这个世界上没有VSCode做不到的事。</p><p>今天我就给大家介绍一款实用的 VSCode 插件：VSCode Drawio。</p><p>这个draw.io其实我也不太了解，上网找了下资料大概和<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a>一样的支持在线绘图的网站工具</p><hr><h3 id="接下来进入主题—VSCode-Drawio"><a href="#接下来进入主题—VSCode-Drawio" class="headerlink" title="接下来进入主题—VSCode Drawio"></a>接下来进入主题—<em>VSCode Drawio</em></h3><p>话不多说先看它的效果吧</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/drawio.gif" alt="drawio"></p><p>怎么样是不是心动了</p><p>赶快去VSCode里面下载吧</p><h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><p>打开你的VSCode，在拓展商店里搜索Draw.io，下载即可</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/drawio.png" alt="drawio"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery</title>
      <link href="/2020/05/30/Note/celery/"/>
      <url>/2020/05/30/Note/celery/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、什么是Celery"><a href="#一、什么是Celery" class="headerlink" title="一、什么是Celery"></a>一、什么是Celery</h3><p>Celery的框架图：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/celery.png" alt="celery"></p><p>Celery是一个专注于实时处理和任务调度的分布式任务队列。所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。</p><p>在程序的运行过程中，我们经常会碰到一些耗时耗资源的操作，为了避免它们阻塞主程序的运行，我们经常会采用多线程或异步任务。</p><p>通常的使用场景：</p><ul><li>Web开发中。当一个操作需要很长时间才能执行完成是，可以用celery去异步处理</li><li>定时任务。Celery可以帮助我们快速在不同的机器设定不同种任务。</li><li>同时完成多项工作。</li></ul><h3 id="二、为什么要用Celery"><a href="#二、为什么要用Celery" class="headerlink" title="二、为什么要用Celery"></a>二、为什么要用Celery</h3><p>Celery其特性是：</p><ul><li><p>简单。Celery 易于使用和维护，并且它 <em>不需要配置文件</em> 。</p><p>Celery 有一个活跃、友好的社区来让你寻求帮助，包括一个 邮件列表 和一个 IRC 频道 。</p><p>下面是一个你可以实现的最简应用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.task <span class="keyword">import</span> task</span><br><span class="line"><span class="comment"># 自定义要执行的task任务</span></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_test</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"nict try"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span></span><br></pre></td></tr></table></figure></li><li><p>可用性高。若连接丢失或失败，会自动连接。并且通过主/从方式复制提高可用性</p></li><li><p>快速。单个celery进程可以在短时间完成上百万任务。</p></li><li><p>灵活。所有celery部分都可以拓展和单独使用</p></li></ul><h3 id="三、缺点"><a href="#三、缺点" class="headerlink" title="三、缺点"></a>三、缺点</h3><p>Celery很好用，可以快速完成任务，对用户的体验是特别好的。但是，任何事物都是两面性的。它的缺点就是会增加Redis的缓存量，每次请求都会将数据存入Redis里面。而且依赖eventlet的库</p><p>使用我们要定期清理自己的Redis数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure><p>注：flushall会清空所有数据库数据；flushdb只清空当前数据库数据</p><h3 id="四、怎样用Celery"><a href="#四、怎样用Celery" class="headerlink" title="四、怎样用Celery"></a>四、怎样用Celery</h3><p>1、安装对应的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install celery==<span class="number">4.4</span><span class="number">.2</span></span><br><span class="line">pip3 install eventlet==<span class="number">0.25</span><span class="number">.2</span></span><br><span class="line">pip3 install Django==<span class="number">2.0</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>2、配置settings文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis</span></span><br><span class="line">CELERY_BROKER_URL = <span class="string">'redis://localhost:6379/'</span></span><br><span class="line"><span class="comment">#broker配置redis</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://localhost:6379/'</span></span><br><span class="line"><span class="comment">#文件格式为：json</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br></pre></td></tr></table></figure><p>3、在settings文件同级目录创建celery.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'Django项目名称.settings'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册Celery的APP</span></span><br><span class="line">app = Celery(<span class="string">'Django项目名称'</span>)</span><br><span class="line"><span class="comment"># 绑定配置文件</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>, namespace=<span class="string">'CELERY'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发现各个app下的tasks.py文件</span></span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果有需要可以将该任务设置成定时任务</span></span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line">CELERY_BEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="comment"># 周期性任务</span></span><br><span class="line">    <span class="string">'task-one'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'myapp.tasks.print_test'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: 周期时间,</span><br><span class="line">        <span class="comment"># 'args': ()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修改settings文件同级目录的init.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line"></span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'celery_app'</span>]</span><br></pre></td></tr></table></figure><p>5、在应用中创建tasks.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.task <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义要执行的task任务</span></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_test</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"nict try"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>6、在视图页面进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> tasks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ctest</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">    res=tasks.print_test.delay()</span><br><span class="line">    <span class="comment">#delay方法就是异步方式请求</span></span><br><span class="line">    <span class="comment">#任务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'status'</span>:<span class="string">'successful'</span>,<span class="string">'task_id'</span>:res.task_id&#125;)</span><br></pre></td></tr></table></figure><p>7、 在manage.py的目录下启动celery服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A mydjango -l info -P eventlet</span><br></pre></td></tr></table></figure><p>8、 在浏览器中调用异步服务接口</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/celery1.png" alt="celery"></p><p> 同时也可以在backend中查询任务结果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/celery2.png" alt="celery"></p><p>*****注：redis中的key并不是单纯的task_id，而是需要加上前缀celery-task-meta-</p><p> 9、最后，如果需要启动定时任务，就需要在manage.py所在的文件夹内单独启动beat服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A mydjango beat -l info</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Redis </tag>
            
            <tag> Celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful API</title>
      <link href="/2020/05/29/Note/restful/"/>
      <url>/2020/05/29/Note/restful/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、什么是REST"><a href="#一、什么是REST" class="headerlink" title="一、什么是REST"></a>一、什么是REST</h3><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/restful.gif" alt="restful"></p><p>REST全称是Representational State Transfer(表述性状态转移)，是HTTP规范的标准。REST指的是一组架构约束条件和原则。如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p><h3 id="二、为什么要用REST框架"><a href="#二、为什么要用REST框架" class="headerlink" title="二、为什么要用REST框架"></a>二、为什么要用REST框架</h3><p>在初学者眼中HTTP只不过是一种通道，他们通常不会遵循REST风格，而将代码乱写一通，想起一个接口写一个。代码整体效果给人看上去是杂烂无章，无从下手。</p><p>就像我们去餐厅点餐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">顾客A：‘给我来一份海鲜大咖’</span><br><span class="line">传参</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'ordername'</span>:<span class="string">'海鲜大咖'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">前台接收到信息</span><br><span class="line"></span><br><span class="line">给你返回的信息(订单编号)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'orederid'</span>:<span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">这样一次点餐流程完成</span><br><span class="line"></span><br><span class="line">顾客A：‘再给我来一份烧烤’</span><br><span class="line">传参</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">'ordername'</span>:<span class="string">'烧烤'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">前台接收到信息</span><br><span class="line"></span><br><span class="line">再次给你返回的信息(订单编号)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'orderid'</span>:<span class="number">456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每个顾客来点餐都会再次传参，再次生产订单。</p><p>像这个样子<strong>面向过程</strong>写出的代码不仅量大，复杂，而且给其他人看不一定能看懂，所以初学者开始进阶了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/order  <span class="comment">#订单相关</span></span><br><span class="line">/cards  <span class="comment">#会员卡</span></span><br><span class="line">顾客A：‘给我来一份海鲜大咖，我有会员卡’</span><br><span class="line"></span><br><span class="line">传参</span><br><span class="line"></span><br><span class="line">/order</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'addoreder'</span>:&#123;</span><br><span class="line">        <span class="string">'ordername'</span>:<span class="string">'海鲜大咖'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">前台接收到信息</span><br><span class="line"></span><br><span class="line">再次给你返回的信息(订单编号)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'orederid'</span>:<span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/cards</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'cardis'</span>:<span class="number">666</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次<strong>面向资源</strong>通过参数把订单与会员卡分开，是代码清晰了不少但是代码量还是太多了</p><p>当初学者初次理解rest与http协议，开始使用method控制代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">顾客A：‘给我来个海鲜大咖，我有会员卡’</span><br><span class="line"></span><br><span class="line">GET /orders</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /orders 新增</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"ordername"</span>:<span class="string">"海鲜大咖"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">顾客A：‘算了，我不想要海鲜大咖了，给我换一份烧烤’</span><br><span class="line"></span><br><span class="line">PUT /orders 修改</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123</span></span><br><span class="line"><span class="string">"ordername"</span>:<span class="string">"烧烤"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">过了很长时间，顾客A的烧烤还没好！！！</span><br><span class="line"></span><br><span class="line">顾客A：‘怎么还没好，我不要了，走了’</span><br><span class="line"></span><br><span class="line">DELETE /orders 删除</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过method控制代码，代码以及变得很清晰，简单了</p><p>但是<strong>大佬</strong>都是这样写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders  orderid=&#123;orderid&#125;</span><br><span class="line"></span><br><span class="line">POST /orders</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123123</span>,</span><br><span class="line"><span class="string">"delete"</span>:&#123;</span><br><span class="line"><span class="string">"method"</span>:<span class="string">"DELETE"</span></span><br><span class="line"><span class="string">"url"</span>:<span class="string">'/orders'</span></span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123123</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"edit"</span>:&#123;</span><br><span class="line"><span class="string">"method"</span>:<span class="string">"PUT"</span></span><br><span class="line"><span class="string">"url"</span>:<span class="string">'/orders'</span></span><br><span class="line"><span class="string">"orderid"</span>:<span class="number">123123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个接口，就能让别人知道他这个接口还可以做很多操作，真正实api,restful风格的接口 给用户使用者带来很大便利和最高的用户体验</p><h3 id="三、怎么使用REST风格写接口"><a href="#三、怎么使用REST风格写接口" class="headerlink" title="三、怎么使用REST风格写接口"></a>三、怎么使用REST风格写接口</h3><p>1.把<strong>资源</strong>和<strong>URL</strong>结合</p><p>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URIURI既可以看成是资源的地址，也可以看成是资源的名称。把资源和URL结合起来，使资源充分利用。就像GitHub上的URL：</p><ul><li><a href="https://github.com/git" target="_blank" rel="noopener">https://github.com/git</a></li><li><a href="https://github.com/git/git" target="_blank" rel="noopener">https://github.com/git/git</a></li><li><a href="https://github.com/git/git/blob/master/block-sha1/sha1.h" target="_blank" rel="noopener">https://github.com/git/git/blob/master/block-sha1/sha1.h</a></li><li><a href="https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08" target="_blank" rel="noopener">https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08</a></li><li><a href="https://github.com/git/git/pulls" target="_blank" rel="noopener">https://github.com/git/git/pulls</a></li><li><a href="https://github.com/git/git/pulls?state=closed" target="_blank" rel="noopener">https://github.com/git/git/pulls?state=closed</a></li><li><a href="https://github.com/git/git/compare/master…next" target="_blank" rel="noopener">https://github.com/git/git/compare/master…next</a></li></ul><p>2.统一资源接口</p><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p><p>下面列出了GET，DELETE，PUT和POST的典型用法:</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><ul><li><p>安全且幂等</p></li><li><p>获取表示</p></li><li><p>变更时获取表示（缓存）</p></li><li><p>200（OK） - 表示已在响应中发出</p></li><li><p>204（无内容） - 资源有空表示</p></li><li><p>301（Moved Permanently） - 资源的URI已被更新</p></li><li><p>303（See Other） - 其他（如，负载均衡）</p></li><li><p>304（not modified）- 资源未更改（缓存）</p></li><li><p>400 （bad request）- 指代坏请求（如，参数错误）</p></li><li><p>404 （not found）- 资源不存在</p></li><li><p>406 （not acceptable）- 服务端不支持所需表示</p></li><li><p>500 （internal server error）- 通用错误响应</p></li><li><p>503 （Service Unavailable）- 服务端当前无法处理请求</p></li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><ul><li><p>不安全且不幂等</p></li><li><p>使用服务端管理的（自动产生）的实例号创建资源</p></li><li><p>创建子资源</p></li><li><p>部分更新资源</p></li><li><p>如果没有被修改，则不过更新资源（乐观锁）</p></li><li><p>200（OK）- 如果现有资源已被更改</p></li><li><p>201（created）- 如果新资源被创建</p></li><li><p>202（accepted）- 已接受处理请求但尚未完成（异步处理）</p></li><li><p>301（Moved Permanently）- 资源的URI被更新</p></li><li><p>303（See Other）- 其他（如，负载均衡）</p></li><li><p>400（bad request）- 指代坏请求</p></li><li><p>404 （not found）- 资源不存在</p></li><li><p>406 （not acceptable）- 服务端不支持所需表示</p></li><li><p>409 （conflict）- 通用冲突</p></li><li><p>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p></li><li><p>415 （unsupported media type）- 接受到的表示不受支持</p></li><li><p>500 （internal server error）- 通用错误响应</p></li><li><p>503 （Service Unavailable）- 服务当前无法处理请求</p></li></ul><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><ul><li><p>不安全但幂等</p></li><li><p>用客户端管理的实例号创建一个资源</p></li><li><p>通过替换的方式更新资源</p></li><li><p>如果未被修改，则更新资源（乐观锁）</p></li><li><p>200 （OK）- 如果已存在资源被更改</p></li><li><p>201 （created）- 如果新资源被创建</p></li><li><p>301（Moved Permanently）- 资源的URI已更改</p></li><li><p>303 （See Other）- 其他（如，负载均衡）</p></li><li><p>400 （bad request）- 指代坏请求</p></li><li><p>404 （not found）- 资源不存在</p></li><li><p>406 （not acceptable）- 服务端不支持所需表示</p></li><li><p>409 （conflict）- 通用冲突</p></li><li><p>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</p></li><li><p>415 （unsupported media type）- 接受到的表示不受支持</p></li><li><p>500 （internal server error）- 通用错误响应</p></li><li><p>503 （Service Unavailable）- 服务当前无法处理请求</p></li></ul><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><ul><li><p>不安全但幂等</p></li><li><p>删除资源</p></li><li><p>200 （OK）- 资源已被删除</p></li><li><p>301 （Moved Permanently）- 资源的URI已更改</p></li><li><p>303 （See Other）- 其他，如负载均衡</p></li><li><p>400 （bad request）- 指代坏请求</p></li><li><p>404 （not found）- 资源不存在</p></li><li><p>409 （conflict）- 通用冲突</p></li><li><p>500 （internal server error）- 通用错误响应</p></li><li><p>503 （Service Unavailable）- 服务端当前无法处理请求</p></li></ul><p>  *注：GitHubURL，典型用法来自菜鸟教程</p><h3 id="四、RESTful-详解"><a href="#四、RESTful-详解" class="headerlink" title="四、RESTful 详解"></a>四、RESTful 详解</h3><ol><li><a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://www.jianshu.com/p/84568e364ee8" target="_blank" rel="noopener">简书</a></li><li><a href="https://juejin.im/entry/58c0fa6b128fe100601f4735" target="_blank" rel="noopener">掘金</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3短信验证</title>
      <link href="/2020/05/28/Blog/Python3%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/05/28/Blog/Python3%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>短信服务验证服务已经不是什么新鲜事了，但是免费的手机短信服务却不多见，本次利用Python3.0基于阿里云服务和腾讯云服务分别来体验一下国际短信和国内短信接口。</p><h3 id="一、阿里云短信服务"><a href="#一、阿里云短信服务" class="headerlink" title="一、阿里云短信服务"></a>一、阿里云短信服务</h3><p>首先是阿里云，注册：<a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a></p><p>短信服务：<a href="https://www.aliyun.com/product/sms?spm=5176.10695662.1128094.2.2a6b4bee30Yrlc" target="_blank" rel="noopener">https://www.aliyun.com/product/sms?spm=5176.10695662.1128094.2.2a6b4bee30Yrlc</a></p><p>搜索<em>短信服务</em>，注册成功后可以免费领取（注意：这个只有中午10点以后才开放，而且每人只有100条短信，超出会扣钱的）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali1.jpg" alt="ali"></p><p>之后找到<em>国内短信，标签管理<em>，并</em>添加标签</em></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali2.jpg" alt="ali"></p><p>进入添加签名后<em>使用场景</em>选择验证码（注意：这个验证码用户级的只能创建一个，且用且珍惜）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali3.jpg" alt="ali"></p><p>签名添加完毕后，退出添加模板</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali4.jpg" alt="ali"></p><p>模板添加完成之后阿里云上基本以操作完毕。之后点击个人头像，找到<em>AccessKey管理</em></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali5.jpg" alt="ali"></p><p>进入之后会有一个<em>用户</em>AccessKey*，如果没有可以自行创建</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali6.jpg" alt="ali"></p><p>完成之后找到<em>快速学习</em>，这里可以查看API Demo，里面可以查看文档和测试短信发送</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ali7.jpg" alt="ali"></p><p>这些完成之后就差不多了。。。。</p><p>接下里安装阿里云短信的sdk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aliyun-python-sdk-core</span><br></pre></td></tr></table></figure><p>编写脚本，并测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将需要的包导入</span></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.request <span class="keyword">import</span> CommonRequest</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本</span></span><br><span class="line"><span class="comment">#个人的appid和appkey以及地区</span></span><br><span class="line">client = AcsClient(<span class="string">'&lt;accessKeyId&gt;'</span>, <span class="string">'&lt;accessSecret&gt;'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">request = CommonRequest()</span><br><span class="line"><span class="comment"># 设置接收格式</span></span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"><span class="comment"># 设置域（阿里云的域名）</span></span><br><span class="line">request.set_domain(<span class="string">'dysmsapi.aliyuncs.com'</span>)</span><br><span class="line"><span class="comment"># 设置发送方式</span></span><br><span class="line">request.set_method(<span class="string">'POST'</span>)</span><br><span class="line"><span class="comment"># 设置协议类型</span></span><br><span class="line">request.set_protocol_type(<span class="string">'https'</span>) <span class="comment"># https | http</span></span><br><span class="line"><span class="comment"># 设置版本</span></span><br><span class="line">request.set_version(<span class="string">'2017-05-25'</span>)</span><br><span class="line"><span class="comment"># 设置操作名称</span></span><br><span class="line">request.set_action_name(<span class="string">'SendSms'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">"cn-hangzhou"</span>) <span class="comment">#地区</span></span><br><span class="line">request.add_query_param(<span class="string">'PhoneNumbers'</span>, <span class="string">"接收手机号"</span>) <span class="comment"># 三方接收手机号</span></span><br><span class="line">request.add_query_param(<span class="string">'SignName'</span>, <span class="string">"标签名称"</span>) <span class="comment"># 创建的标签名称</span></span><br><span class="line">request.add_query_param(<span class="string">'TemplateCode'</span>, <span class="string">" 模版CODE"</span>) <span class="comment"># 创建的模板code</span></span><br><span class="line">request.add_query_param(<span class="string">'TemplateParam'</span>, <span class="string">"&#123;‘code’:&#125;"</span>) <span class="comment">#模板参数</span></span><br><span class="line"><span class="comment">#发送请求</span></span><br><span class="line">response = client.do_action(request)</span><br><span class="line"><span class="comment"># python2:  print(response) </span></span><br><span class="line">print(str(response, encoding = <span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><h3 id="二、腾讯云短信服务"><a href="#二、腾讯云短信服务" class="headerlink" title="二、腾讯云短信服务"></a>二、腾讯云短信服务</h3><p>第一步，注册腾讯云  <a href="https://cloud.tencent.com" target="_blank" rel="noopener">https://cloud.tencent.com</a></p><p>（注意：注册时有点复杂）</p><p>注册成功之后搜索<em>短信</em>，在这个我们需要进行一系列的认证操作</p><p>认证成功之后点击<em>应用管理</em>找到<em>应用列表</em>，之后你就会看到有一个默认应用，但是你也可以自己创建一个</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/txun1.png" alt="ali"></p><p>创建完成之后查看自己的APPID与appkey，并保存</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/txun2.png" alt="ali"></p><p>之后找到<em>国内短信</em>并创建自己的签名（注意：这个个人需要小程序）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/txun3.png" alt="ali"></p><p>签名创建之后，创建模板</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/txun4.png" alt="ali"></p><p>接下里安装腾讯云短信的sdk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install qcloudsms_py</span><br></pre></td></tr></table></figure><p>编写脚本测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短信应用SDK AppID</span></span><br><span class="line">appid = 你的appid  <span class="comment"># SDK AppID是1400开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 短信应用SDK AppKey</span></span><br><span class="line">appkey = <span class="string">"你的appkey"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要发送短信的手机号码</span></span><br><span class="line">phone_numbers = [<span class="string">"你要发送的手机号"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 短信模板ID，需要在短信应用中申请</span></span><br><span class="line">template_id = 在模板列表里获取  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名</span></span><br><span class="line">sms_sign = <span class="string">"签名名称"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qcloudsms_py <span class="keyword">import</span> SmsSingleSender</span><br><span class="line"><span class="keyword">from</span> qcloudsms_py.httpclient <span class="keyword">import</span> HTTPError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">ssender = SmsSingleSender(appid, appkey)</span><br><span class="line">params = [<span class="string">"6666"</span>,<span class="string">"5"</span>]  <span class="comment"># 当模板没有参数时，`params = []`</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = ssender.send_with_param(<span class="number">86</span>, phone_numbers[<span class="number">0</span>],</span><br><span class="line">        template_id, params, sign=sms_sign, extend=<span class="string">""</span>, ext=<span class="string">""</span>)  <span class="comment"># 签名参数不允许为空串</span></span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git相关命令</title>
      <link href="/2020/05/27/Note/git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/05/27/Note/git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、Git的相关命令以及在公司中git的用处"><a href="#一、Git的相关命令以及在公司中git的用处" class="headerlink" title="一、Git的相关命令以及在公司中git的用处"></a>一、Git的相关命令以及在公司中git的用处</h3><p>总所周知<a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git</a> 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。它不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>一般我们每到一家公司都会创建属于自己的分支（前提是你们公司使用git开发），因为如果不创建自己的分支我们所写的代码就没有办法保存。所以第一个命令</p><p>查看本地分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>通常在克隆下来的代码中只有master的分支，不要慌，我们创建一个develop分支，用于代码的测试</p><p>git创建分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 自己的分支名称（develop）</span><br></pre></td></tr></table></figure><p>创建完develop分支后创建自己的分支，有的同学会问为什么不在develop分支上直接写代码呢？—-原因很简单如果你在develop分支上写完代码提交的时候发现别人也修改了develop分支上的代码，会发生冲突，你说用你的好还是用他的好！！</p><p>git分支开发就像漫威宇宙一样，一个主宇宙，多个分宇宙。当其中一个分宇宙发生变化是不会影响到主宇宙和其他分宇宙。</p><p>我们在本地创建自己分支后也要在线上创建分支</p><p>在线上创建分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin 分支名称</span><br></pre></td></tr></table></figure><p>当你一顿操作完之后，就要开始写代码了</p><p>先查看当前分支，然后切换到自己的分支</p><p>切换分支 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout  分支名称</span><br></pre></td></tr></table></figure><p>写完代码之后提交到自己的分支（素质三连）</p><p>将本地代码暂存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure><p>将本地代码提交 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">'提交内容'</span></span><br></pre></td></tr></table></figure><p>推送本地到线上 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin  分支名称</span><br></pre></td></tr></table></figure><p>最后是合并代码（这个操作一般不是我们操作）</p><p>合并分支代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名称</span><br></pre></td></tr></table></figure><h3 id="二、Git-快速入门"><a href="#二、Git-快速入门" class="headerlink" title="二、Git 快速入门"></a>二、Git 快速入门</h3><p>Git 完整命令手册地址：<a href="https://git-scm.com/docs" target="_blank" rel="noopener">https://git-scm.com/docs</a></p><p>联合开发注意文章：<a href="[https://www.sirxs.cn/2020/04/21/Note/git%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/](https://www.sirxs.cn/2020/04/21/Note/git联合开发/)"><a href="https://www.sirxs.cn/2020/04/21/Note/git联合开发/">https://www.sirxs.cn/2020/04/21/Note/git%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/</a></a></p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用QQ邮箱发送验证码</title>
      <link href="/2020/05/27/Blog/%E4%BD%BF%E7%94%A8QQ%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2020/05/27/Blog/%E4%BD%BF%E7%94%A8QQ%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Python3实现发送邮件验证码功能</p><p>这个其实非常简单</p><p>首先我们需要有一个QQ邮箱，然后进入QQ邮箱，点击设置</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/QQem1.png" alt="img"></p><p>点击账户，找到<strong>POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务</strong>，并将图片中的服务开启</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/QQem2.png" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/QQem3.png" alt="img"></p><p>之后就会获取到一个QQ邮箱获取授权码</p><p>之后进入我们的django中，在setting中配置以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_USE_SSL = <span class="literal">True</span>  <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址 ， 如果是163改成smtp.163.com</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span>  <span class="comment"># 邮件服务器端口</span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'xxxxxxxxxxx@qq.com'</span>  <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'xxxxxxxxxxx'</span>  <span class="comment"># 登陆邮件服务器的授权密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER  <span class="comment"># 邮件的发送者</span></span><br><span class="line"><span class="comment"># # 允许哪些人可以请求你和请求方式</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span>  <span class="comment"># 改为true是所有人都可以访问我</span></span><br></pre></td></tr></table></figure><p>之后在我们需要使用的文件中导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail  <span class="comment"># 用来发送用</span></span><br><span class="line"><span class="keyword">from</span> django_test.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"><span class="keyword">from</span> django_test.settings <span class="keyword">import</span> EMAIL_HOST_USER</span><br></pre></td></tr></table></figure><p>写一个随机验证码demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成随机验证码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 验证码是由 字母a~z  A~Z 数字 0~9 组成</span></span><br><span class="line">    <span class="comment"># 在 ascii 码中 小写a的起点是97 大写A起点是65</span></span><br><span class="line">    a_ = [chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>, <span class="number">123</span>)]  <span class="comment"># 小写a的列表推导式</span></span><br><span class="line">    A_ = [chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">91</span>)]  <span class="comment"># 大写A的列表推导式</span></span><br><span class="line">    num_ = [str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># 数字的</span></span><br><span class="line">    <span class="comment"># 使用sample 在列表中随机生成6个任意字母数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_ + A_ + num_, <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p>接下来就是发送邮件的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailVerify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        email = request.data.get(<span class="string">'email'</span>)  <span class="comment"># 接收到用户发来的邮箱</span></span><br><span class="line">        token = get_random_str()  <span class="comment"># 生成验证码</span></span><br><span class="line">        print(token)</span><br><span class="line">        subject = <span class="string">'通过邮箱找回密码！！'</span></span><br><span class="line">        message = <span class="string">'你的验证码是:%s'</span> % token</span><br><span class="line">        send_mail(subject, message, DEFAULT_FROM_EMAIL,</span><br><span class="line">                  [email])  <span class="comment"># 把邮件发过去</span></span><br><span class="line">        res[<span class="string">'code'</span>] = <span class="number">200</span></span><br><span class="line">        res[<span class="string">'message'</span>] = <span class="string">"验证码已发送"</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(res)</span><br></pre></td></tr></table></figure><p>这样就可以实现QQ邮箱发送验证码了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的集群管理sentinel</title>
      <link href="/2020/05/24/Note/redis%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86sentinel/"/>
      <url>/2020/05/24/Note/redis%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86sentinel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>不想当元帅的士兵，不是好士兵。——拿破仑 </p><hr><h2 id="sentinel哨兵模式介绍"><a href="#sentinel哨兵模式介绍" class="headerlink" title="sentinel哨兵模式介绍"></a>sentinel哨兵模式介绍</h2><p>Sentinel(哨兵)是用于监控redis集群中Master状态的工具，是Redis 的高可用性解决方案，sentinel哨兵模式已经被集成在redis2.4之后的版本中。sentinel是redis高可用的解决方案，sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。</p><p>sentinel可以让redis实现主从复制，当一个集群中的master失效之后，sentinel可以选举出一个新的master用于自动接替master的工作，集群中的其他redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换。</p><p><strong>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案</strong>，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。Sentinel由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p><p><strong>Sentinel版本</strong><br>Sentinel当前最新的稳定版本称为Sentinel 2(与之前的Sentinel 1区分开来）。随着redis2.8的安装包一起发行。安装完Redis2.8后，可以在redis2.8/src/里面找到Redis-sentinel的启动程序。<br>强烈建议：如果你使用的是redis2.6(sentinel版本为sentinel 1)，你最好应该使用redis2.8版本的sentinel 2，因为sentinel 1有很多的Bug，已经被官方弃用，所以强烈建议使用redis2.8以及sentinel 2。</p><p><strong>Sentinel状态持久化</strong><br>snetinel的状态会被持久化地写入sentinel的配置文件中。每次当收到一个新的配置时，或者新创建一个配置时，配置会被持久化到硬盘中，并带上配置的版本戳。这意味着，可以安全的停止和重启sentinel进程。</p><p><strong>Sentinel作用：</strong><br>1）Master状态检测<br>2）如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave。<br>3）Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p><p><strong>Sentinel工作方式（每个Sentinel实例都执行的定时任务）</strong><br>1）每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个PING命令。<br>2）如果一个实例（instance）距离最后一次有效回复PING命令的时间超过 own-after-milliseconds 选项所指定的值，则这个实例会被Sentinel标记为主观下线。<br>3）如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。<br>4）当有足够数量的Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态，则Master会被标记为客观下线。<br>5）在一般情况下，每个Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。<br>6）当Master被Sentinel标记为客观下线时，Sentinel 向下线的 Master 的所有Slave发送 INFO命令的频率会从10秒一次改为每秒一次。<br>7）若没有足够数量的Sentinel同意Master已经下线，Master的客观下线状态就会被移除。 若 Master重新向Sentinel 的PING命令返回有效回复，Master的主观下线状态就会被移除。</p><p><strong>三个定时任务</strong><br>sentinel在内部有3个定时任务<br>1）每10秒每个sentinel会对master和slave执行info命令，这个任务达到两个目的：<br>a）发现slave节点<br>b）确认主从关系<br>2）每2秒每个sentinel通过master节点的channel交换信息（pub/sub）。master节点上有一个发布订阅的频道(<strong>sentinel</strong>:hello)。sentinel节点通过<strong>sentinel</strong>:hello频道进行信息交换(对节点的”看法”和自身的信息)，达成共识。<br>3）每1秒每个sentinel对其他sentinel和redis节点执行ping操作（相互监控），这个其实是一个心跳检测，是失败判定的依据。</p><p><strong>主观下线</strong><br>所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。<br>主观下线就是说如果服务器在down-after-milliseconds给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（SDOWN ）。<br>sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（master，从服务，其他sentinel）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。<br>sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度，如果实例在down-after-milliseconds毫秒内，返回的都是无效回复，那么sentinel回认为该实例已（主观）下线，修改其flags状态为SRI_S_DOWN。如果多个sentinel监视一个服务，有可能存在多个sentinel的down-after-milliseconds配置不同，这个在实际生产中要注意。</p><p><strong>客观下线</strong><br>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断，然后开启failover。<br>客观下线就是说只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。<br>只有当master被认定为客观下线时，才会发生故障迁移。<br>当sentinel监视的某个服务主观下线后，sentinel会询问其它监视该服务的sentinel，看它们是否也认为该服务主观下线，接收到足够数量（这个值可以配置）的sentinel判断为主观下线，既任务该服务客观下线，并对其做故障转移操作。<br>sentinel通过发送 SENTINEL is-master-down-by-addr ip port current_epoch runid，（ip：主观下线的服务id，port：主观下线的服务端口，current_epoch：sentinel的纪元，runid：*表示检测服务下线状态，如果是sentinel 运行id，表示用来选举领头sentinel）来询问其它sentinel是否同意服务下线。<br>一个sentinel接收另一个sentinel发来的is-master-down-by-addr后，提取参数，根据ip和端口，检测该服务时候在该sentinel主观下线，并且回复is-master-down-by-addr，回复包含三个参数：down_state（1表示已下线，0表示未下线），leader_runid（领头sentinal id），leader_epoch（领头sentinel纪元）。<br>sentinel接收到回复后，根据配置设置的下线最小数量，达到这个值，既认为该服务客观下线。<br>客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。</p><p>在redis-sentinel的conf文件里有这么两个配置：<br>*<em>1）sentinel monitor    *</em></p><p>四个参数含义：<br>masterName这个是对某个master+slave组合的一个区分标识（一套sentinel是可以监听多套master+slave这样的组合的）。<br>ip 和 port 就是master节点的 ip 和 端口号。<br>quorum这个参数是进行<strong>客观下线的一个依据</strong>，意思是至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。</p><p><strong>2）sentinel down-after-milliseconds  **<br>这个配置其实就是进行</strong>主观下线的一个依据**，masterName这个参数不用说了，timeout是一个毫秒值，表示：如果这台sentinel超过timeout这个时间都无法连通master包括slave（slave不需要客观下线，因为不需要故障转移）的话，就会主观认为该master已经下线（实际下线需要客观下线的判断通过才会下线）</p><p>那么，多个sentinel之间是如何达到共识的呢？<br>这就是依赖于前面说的第二个定时任务，某个sentinel先将master节点进行一个主观下线，然后会将这个判定通过sentinel is-master-down-by-addr这个命令问对应的节点是否也同样认为该addr的master节点要做客观下线。最后当达成这一共识的sentinel个数达到前面说的quorum设置的这个值时，就会对该master节点下线进行故障转移。quorum的值一般设置为sentinel个数的二分之一加1，例如3个sentinel就设置2。</p><p><strong>主观下线（SDOWN）和客观下线（ODOWN）的更多细节</strong><br>sentinel对于不可用有两种不同的看法，一个叫主观不可用(SDOWN),另外一个叫客观不可用(ODOWN)。SDOWN是sentinel自己主观上检测到的关于master的状态，ODOWN需要一定数量的sentinel达成一致意见才能认为一个master客观上已经宕掉，各个sentinel之间通过命令SENTINEL is_master_down_by_addr来获得其它sentinel对master的检测结果。<br>从sentinel的角度来看，如果发送了PING心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。这个时间在配置中通过is-master-down-after-milliseconds参数配置。<br>当sentinel发送PING后，以下回复之一都被认为是合法的：<br>PING replied with +PONG.<br>PING replied with -LOADING error.<br>PING replied with -MASTERDOWN error.<br>其它任何回复（或者根本没有回复）都是不合法的。</p><p>从SDOWN切换到ODOWN不需要任何一致性算法，只需要一个gossip协议：如果一个sentinel收到了足够多的sentinel发来消息告诉它某个master已经down掉了，SDOWN状态就会变成ODOWN状态。如果之后master可用了，这个状态就会相应地被清理掉。<br>正如之前已经解释过了，真正进行failover需要一个授权的过程，但是所有的failover都开始于一个ODOWN状态。<br>ODOWN状态只适用于master，对于不是master的redis节点sentinel之间不需要任何协商，slaves和sentinel不会有ODOWN状态。</p><p><strong>配置版本号</strong><br>为什么要先获得大多数sentinel的认可时才能真正去执行failover呢？<br>当一个sentinel被授权后，它将会获得宕掉的master的一份最新配置版本号，当failover执行结束以后，这个版本号将会被用于最新的配置。因为大多数sentinel都已经知道该版本号已经被要执行failover的sentinel拿走了，所以其他的sentinel都不能再去使用这个版本号。这意味着，每次failover都会附带有一个独一无二的版本号。我们将会看到这样做的重要性。而且，sentinel集群都遵守一个规则：如果sentinel A推荐sentinel B去执行failover，B会等待一段时间后，自行再次去对同一个master执行failover，这个等待的时间是通过failover-timeout配置项去配置的。从这个规则可以看出，sentinel集群中的sentinel不会再同一时刻并发去failover同一个master，第一个进行failover的sentinel如果失败了，另外一个将会在一定时间内进行重新进行failover，以此类推。<br>redis sentinel保证了活跃性：如果大多数sentinel能够互相通信，最终将会有一个被授权去进行failover.<br>redis sentinel也保证了安全性：每个试图去failover同一个master的sentinel都会得到一个独一无二的版本号。</p><p><strong>配置传播</strong><br>一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。<br>一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送SLAVEOF NO ONE命令，然后能够通过INFO命令看到新master的配置信息。<br>当将一个slave选举为master并发送SLAVEOF NO ONE后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的，然后所有sentinels将会发布新的配置信息。<br>新配在集群中相互传播的方式，就是为什么我们需要当一个sentinel进行failover时必须被授权一个版本号的原因。<br>每个sentinel使用##发布/订阅##的方式持续地传播master的配置版本信息，配置传播的##发布/订阅##管道是：<strong>sentinel</strong>:hello。<br>因为每一个配置都有一个版本号，所以以版本号最大的那个为标准。</p><p>举个例子：<br>假设有一个名为mymaster的地址为192.168.10.202:6379。一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。如果failover成功了，假设地址改为了192.168.10.202:9000，此时配置的版本号为2，进行failover的sentinel会将新配置广播给其他的sentinel，由于其他sentinel维护的版本号为1，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。<br>这意味着sentinel集群保证了第二种活跃性：一个能够互相通信的sentinel集群最终会采用版本号最高且相同的配置。</p><p><strong>sentinel的”仲裁会”</strong><br>前面我们谈到，当一个master被sentinel集群监控时，需要为它指定一个参数，这个参数指定了当需要判决master为不可用，并且进行failover时，所需要的sentinel数量，可以称这个参数为票数</p><p>不过，当failover主备切换真正被触发后，failover并不会马上进行，还需要sentinel中的大多数sentinel授权后才可以进行failover。<br>当ODOWN时，failover被触发。failover一旦被触发，尝试去进行failover的sentinel会去获得“大多数”sentinel的授权（如果票数比大多数还要大的时候，则询问更多的sentinel)<br>这个区别看起来很微妙，但是很容易理解和使用。例如，集群中有5个sentinel，票数被设置为2，当2个sentinel认为一个master已经不可用了以后，将会触发failover，但是，进行failover的那个sentinel必须先获得至少3个sentinel的授权才可以实行failover。<br>如果票数被设置为5，要达到ODOWN状态，必须所有5个sentinel都主观认为master为不可用，要进行failover，那么得获得所有5个sentinel的授权。</p><p><strong>选举领头sentinel（即领导者选举）</strong><br>一个redis服务被判断为客观下线时，多个监视该服务的sentinel协商，选举一个领头sentinel，对该redis服务进行故障转移操作。<strong>选举领头sentinel遵循以下规则：</strong><br>1）所有的sentinel都有公平被选举成领头的资格。<br>2）所有的sentinel都有且只有一次将某个sentinel选举成领头的机会（在一轮选举中），一旦选举某个sentinel为领头，不能更改。<br>3）sentinel设置领头sentinel是先到先得，一旦当前sentinel设置了领头sentinel，以后要求设置sentinel为领头请求都会被拒绝。<br>4）每个发现服务客观下线的sentinel，都会要求其他sentinel将自己设置成领头。<br>5）当一个sentinel（源sentinel）向另一个sentinel（目sentinel）发送is-master-down-by-addr ip port current_epoch runid命令的时候，runid参数不是*，而是sentinel运行id，就表示源sentinel要求目标sentinel选举其为领头。<br>6）源sentinel会检查目标sentinel对其要求设置成领头的回复，如果回复的leader_runid和leader_epoch为源sentinel，表示目标sentinel同意将源sentinel设置成领头。<br>7）如果某个sentinel被半数以上的sentinel设置成领头，那么该sentinel既为领头。<br>8）如果在限定时间内，没有选举出领头sentinel，暂定一段时间，再选举。</p><p><strong>为什么要选领导者？</strong><br>简单来说，就是因为只能有一个sentinel节点去完成故障转移。<br>sentinel is-master-down-by-addr这个命令有两个作用，一是确认下线判定，二是进行领导者选举。<br><strong>选举过程：</strong><br>1）每个做主观下线的sentinel节点向其他sentinel节点发送上面那条命令，要求将它设置为领导者。<br>2）收到命令的sentinel节点如果还没有同意过其他的sentinel发送的命令（还未投过票），那么就会同意，否则拒绝。<br>3）如果该sentinel节点发现自己的票数已经过半且达到了quorum的值，就会成为领导者<br>4）如果这个过程出现多个sentinel成为领导者，则会等待一段时间重新选举。</p><p><strong>Redis Sentinel的主从切换方案</strong><br>Redis 2.8版开始正式提供名为Sentinel的主从切换方案，通俗的来讲，Sentinel可以用来管理多个Redis服务器实例，可以实现一个功能上实现HA的集群，<strong>Sentinel主要负责三个方面的任务</strong>：<br><strong>1）监控（Monitoring）</strong>： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br><strong>2）提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br><strong>3）自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</p><p>Redis Sentinel 是一个分布式系统， 可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。<br>一个简单的主从结构加sentinel集群的架构图如下：</p><p>上图是一主一从节点，加上两个部署了sentinel的集群，sentinel集群之间会互相通信，沟通交流redis节点的状态，做出相应的判断并进行处理，这里的主观下线状态和客观下线状态是比较重要的状态，它们决定了是否进行故障转移<br>可以 通过订阅指定的频道信息，当服务器出现故障得时候通知管理员<br>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器，你不可以使用 PUBLISH 命令向这个服务器发送信息，但你可以用 SUBSCRIBE 命令或者 PSUBSCRIBE 命令， 通过订阅给定的频道来获取相应的事件提醒。 一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p><p>个人认为，Sentinel实现的最主要的一个功能就是能做到自动故障迁移，即当某一个master挂了的时候，可以自动的将某一个slave提升为新的master，且原master的所有slave也都自动的将自己的master改为新提升的master，这样我们的程序的可用性大大提高了。只要redis安装完成，Sentinel就安装完成了，Sentinel集成在redis里了。</p><p><strong>Sentinel支持集群</strong>（可以部署在多台机器上，也可以在一台物理机上通过多端口实现伪集群部署）<br>很显然，只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后(sentinel本身也有单点问题，single-point-of-failure)整个集群系统将无法按照预期的方式运行。所以有必要将sentinel集群，这样有几个好处：<br>1）即使有一些sentinel进程宕掉了，依然可以进行redis集群的主备切换；<br>2）如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现redis集群的主备切换（单点问题）;<br>3）如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。</p><p><strong>sentinel集群注意事项</strong><br>1）只有Sentinel 集群中大多数服务器认定master主观下线时master才会被认定为客观下线，才可以进行故障迁移，也就是说，即使不管我们在sentinel monitor中设置的数是多少，就算是满足了该值，只要达不到大多数，就不会发生故障迁移。<br>2）官方建议sentinel至少部署三台，且分布在不同机器。这里主要考虑到sentinel的可用性，假如我们只部署了两台sentinel，且quorum设置为1，也可以实现自动故障迁移，但假如其中一台sentinel挂了，就永远不会触发自动故障迁移，因为永远达不到大多数sentinel认定master主观下线了。<br>3）sentinel monitor配置中的master IP尽量不要写127.0.0.1或localhost，因为客户端，如jedis获取master是根据这个获取的，若这样配置，jedis获取的ip则是127.0.0.1，这样就可能导致程序连接不上master<br>4）当sentinel 启动后会自动的修改sentinel.conf文件，如已发现的master的slave信息，和集群中其它sentinel 的信息等,这样即使重启sentinel也能保持原来的状态。注意，当集群服务器调整时，如更换sentinel的机器，或者新配置一个sentinel，请不要直接复制原来运行过得sentinel配置文件，因为其里面自动生成了以上说的那些信息，我们应该复制一个新的配置文件或者把自动生成的信息给删掉。<br>5）当发生故障迁移的时候，master的变更记录与slave更换master的修改会自动同步到redis的配置文件，这样即使重启redis也能保持变更后的状态。</p><p><strong>每个 Sentinel 都需要定期执行的任务</strong><br>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。<br>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。<br>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。<br>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。<br>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。<br>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</p><p><strong>Sentinel之间和Slaves之间的自动发现机制</strong><br>虽然sentinel集群中各个sentinel都互相连接彼此来检查对方的可用性以及互相发送消息。但是你不用在任何一个sentinel配置任何其它的sentinel的节点。因为sentinel利用了master的发布/订阅机制去自动发现其它也监控了统一master的sentinel节点。<br>通过向名为<strong>sentinel</strong>:hello的管道中发送消息来实现。<br>同样，你也不需要在sentinel中配置某个master的所有slave的地址，sentinel会通过询问master来得到这些slave的地址的。<br>每个sentinel通过向每个master和slave的发布/订阅频道<strong>sentinel</strong>:hello每秒发送一次消息，来宣布它的存在。<br>每个sentinel也订阅了每个master和slave的频道<strong>sentinel</strong>:hello的内容，来发现未知的sentinel，当检测到了新的sentinel，则将其加入到自身维护的master监控列表中。<br>每个sentinel发送的消息中也包含了其当前维护的最新的master配置。如果某个sentinel发现<br>自己的配置版本低于接收到的配置版本，则会用新的配置更新自己的master配置。<br>在为一个master添加一个新的sentinel前，sentinel总是检查是否已经有sentinel与新的sentinel的进程号或者是地址是一样的。如果是那样，这个sentinel将会被删除，而把新的sentinel添加上去。</p><p><strong>sentinel和redis身份验证</strong><br>当一个master配置为需要密码才能连接时，客户端和slave在连接时都需要提供密码。<br>master通过requirepass设置自身的密码，不提供密码无法连接到这个master。<br>slave通过masterauth来设置访问master时的密码。<br>但是当使用了sentinel时，由于一个master可能会变成一个slave，一个slave也可能会变成master，所以需要同时设置上述两个配置项。</p><p><strong>Sentinel API</strong><br>在默认情况下， Sentinel 使用 TCP 端口 26379 （普通 Redis 服务器使用的是 6379 ）。Sentinel 接受 Redis 协议格式的命令请求， 所以你可以使用 redis-cli 或者任何其他 Redis 客户端来与 Sentinel 进行通讯。有两种方式可以和 Sentinel 进行通讯：<br>1）是通过直接发送命令来查询被监视 Redis 服务器的当前状态， 以及 Sentinel 所知道的关于其他 Sentinel 的信息， 诸如此类。<br>2）是使用发布与订阅功能， 通过接收 Sentinel 发送的通知： 当执行故障转移操作， 或者某个被监视的服务器被判断为主观下线或者客观下线时， Sentinel 就会发送相应的信息。</p><p><strong>Sentinel命令</strong>（即登录到sentinel节点后执行的命令，比如执行”redis-cli -h 192.168.10.203 -p 26379”命令后，才可以执行下面命令）<br>PING ：返回 PONG 。<br>SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态；<br>SENTINEL slaves <master name> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态；<br>SENTINEL get-master-addr-by-name <master name> ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号；<br>SENTINEL reset <pattern> ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清楚主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel ；<br>SENTINEL failover <master name> ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移。 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）</p><p>SENTINEL MONITOR <name> <ip> <port> <quorum> 这个命令告诉sentinel去监听一个新的master<br>SENTINEL REMOVE <name> 命令sentinel放弃对某个master的监听<br>SENTINEL SET <name> <option> <value> 这个命令很像Redis的CONFIG SET命令，用来改变指定master的配置。支持多个<option><value>。例如以下实例：SENTINEL SET objects-cache-master down-after-milliseconds 1000<br>只要是配置文件中存在的配置项，都可以用SENTINEL SET命令来设置。这个还可以用来设置master的属性，比如说quorum(票数)，而不需要先删除master，再重新添加master。例如：SENTINEL SET objects-cache-master quorum 5</p><p>客户端可以通过SENTINEL get-master-addr-by-name <master name>获取当前的主服务器IP地址和端口号，以及SENTINEL slaves <master name>获取所有的Slaves信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.202 -p 6379 INFO|grep role</span><br><span class="line">role:slave</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.203 -p 6379 INFO|grep role</span><br><span class="line">role:slave</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 6379 INFO|grep role</span><br><span class="line">role:master</span><br><span class="line"> </span><br><span class="line">登录任意一个节点的sentinel，进行相关命令的操作（下面命令例子中的redisMaster是sentinel监控redis主从状态时定义的master名称）</span><br><span class="line"> </span><br><span class="line">1）sentinel masters   罗列所有sentinel 监视相关的master</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 26379</span><br><span class="line">192.168.10.205:26379&gt; sentinel masters</span><br><span class="line"> </span><br><span class="line">2）sentinel master masterName   列出一个master相关的的信息</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 26379</span><br><span class="line">192.168.10.205:26379&gt; sentinel master redisMaster</span><br><span class="line"> </span><br><span class="line">3）sentinel slaves masterName   列出一个master相应的slave组相关的数据</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 26379</span><br><span class="line">192.168.10.205:26379&gt; sentinel slaves redisMaster</span><br><span class="line"> </span><br><span class="line">4）sentinel sentinels masterName   列出master相关的sentinels组其他相关的信息</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 26379</span><br><span class="line">192.168.10.205:26379&gt; sentinel sentinels redisMaster</span><br><span class="line"> </span><br><span class="line">5）sentinel get-master-addr-by-name masterName   获取master-name相关的 ip addr 的信息</span><br><span class="line">[root@redis-master ~]# redis-cli -h 192.168.10.205 -p 26379</span><br><span class="line">192.168.10.205:26379&gt; sentinel get-master-addr-by-name redisMaster</span><br><span class="line">1) "192.168.10.205"</span><br><span class="line">2) "6379"</span><br></pre></td></tr></table></figure><p><strong>增加或删除Sentinel</strong><br>由于有sentinel自动发现机制，所以添加一个sentinel到你的集群中非常容易，你所需要做的只是监控到某个Master上，然后新添加的sentinel就能获得其他sentinel的信息以及master所有的slaves。<br>如果你需要添加多个sentinel，建议你一个接着一个添加，这样可以预防网络隔离带来的问题。你可以每个30秒添加一个sentinel。最后你可以用SENTINEL MASTER mastername来检查一下是否所有的sentinel都已经监控到了master。<br><strong>删除一个sentinel显得有点复杂：因为sentinel永远不会删除一个已经存在过的sentinel，即使它已经与组织失去联系很久了。</strong><br>要想删除一个sentinel，应该遵循如下步骤：<br>1）停止所要删除的sentinel<br>2）发送一个SENTINEL RESET * 命令给所有其它的sentinel实例，如果你想要重置指定master上面的sentinel，只需要把*号改为特定的名字，注意，需要一个接一个发，每次发送的间隔不低于30秒。<br>3）检查一下所有的sentinels是否都有一致的当前sentinel数。使用SENTINEL MASTER mastername 来查询。</p><p><strong>删除旧master或者不可达slave</strong><br><strong>sentinel永远会记录好一个Master的slaves，即使slave已经与组织失联好久了。这是很有用的，因为sentinel集群必须有能力把一个恢复可用的slave进行重新配置。</strong><br>并且，failover后，失效的master将会被标记为新master的一个slave，这样的话，当它变得可用时，就会从新master上复制数据。<br>然后，有时候你想要永久地删除掉一个slave(有可能它曾经是个master)，你只需要发送一个SENTINEL RESET master命令给所有的sentinels，它们将会更新列表里能够正确地复制master数据的slave。</p><p><strong>发布与订阅信息</strong>（sentinel的日志文件里可以看到这些信息）<br>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器： 你不可以使用 PUBLISH 命令向这个服务器发送信息， 但你可以用 SUBSCRIBE 命令或者 PSUBSCRIBE 命令， 通过订阅给定的频道来获取相应的事件提醒。</p><p>一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p><p>通过执行 “PSUBSCRIBE * “命令可以接收所有事件信息（即订阅所有消息）。</p><p>以下列出的是客户端可以通过订阅来获得的频道和信息的格式： 第一个英文单词是频道/事件的名字， 其余的是数据的格式。</p><p>注意， 当格式中包含 instance details 字样时， 表示频道所返回的信息中包含了以下用于识别目标实例的内容.</p><p>以下是所有可以收到的消息的消息格式，如果你订阅了所有消息的话。第一个单词是频道的名字，其它是数据的格式。<br>注意：以下的instance details的格式是：<br><instance-type> <name> <ip> <port> @ <master-name> <master-ip> <master-port><br>如果这个redis实例是一个master，那么@之后的消息就不会显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+reset-master &lt;instance details&gt; -- 当master被重置时.</span><br><span class="line">    +slave &lt;instance details&gt; -- 当检测到一个slave并添加进slave列表时.</span><br><span class="line">    +failover-state-reconf-slaves &lt;instance details&gt; -- Failover状态变为reconf-slaves状态时</span><br><span class="line">    +failover-detected &lt;instance details&gt; -- 当failover发生时</span><br><span class="line">    +slave-reconf-sent &lt;instance details&gt; -- sentinel发送SLAVEOF命令把它重新配置时</span><br><span class="line">    +slave-reconf-inprog &lt;instance details&gt; -- slave被重新配置为另外一个master的slave，但数据复制还未发生时。</span><br><span class="line">    +slave-reconf-done &lt;instance details&gt; -- slave被重新配置为另外一个master的slave并且数据复制已经与master同步时。</span><br><span class="line">    -dup-sentinel &lt;instance details&gt; -- 删除指定master上的冗余sentinel时 (当一个sentinel重新启动时，可能会发生这个事件).</span><br><span class="line">    +sentinel &lt;instance details&gt; -- 当master增加了一个sentinel时。</span><br><span class="line">    +sdown &lt;instance details&gt; -- 进入SDOWN状态时;</span><br><span class="line">    -sdown &lt;instance details&gt; -- 离开SDOWN状态时。</span><br><span class="line">    +odown &lt;instance details&gt; -- 进入ODOWN状态时。</span><br><span class="line">    -odown &lt;instance details&gt; -- 离开ODOWN状态时。</span><br><span class="line">    +new-epoch &lt;instance details&gt; -- 当前配置版本被更新时。</span><br><span class="line">    +<span class="keyword">try</span>-failover &lt;instance details&gt; -- 达到failover条件，正等待其他sentinel的选举。</span><br><span class="line">    +elected-leader &lt;instance details&gt; -- 被选举为去执行failover的时候。</span><br><span class="line">    +failover-state-select-slave &lt;instance details&gt; -- 开始要选择一个slave当选新master时。</span><br><span class="line">    no-good-slave &lt;instance details&gt; -- 没有合适的slave来担当新master</span><br><span class="line">    selected-slave &lt;instance details&gt; -- 找到了一个适合的slave来担当新master</span><br><span class="line">    failover-state-send-slaveof-noone &lt;instance details&gt; -- 当把选择为新master的slave的身份进行切换的时候。</span><br><span class="line">    failover-end-<span class="keyword">for</span>-timeout &lt;instance details&gt; -- failover由于超时而失败时。</span><br><span class="line">    failover-end &lt;instance details&gt; -- failover成功完成时。</span><br><span class="line">    switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt; -- 当master的地址发生变化时。通常这是客户端最感兴趣的消息了。</span><br><span class="line">    +tilt -- 进入Tilt模式。</span><br><span class="line">    -tilt -- 退出Tilt模式。</span><br></pre></td></tr></table></figure><p>可以看出，使用Sentinel命令和发布订阅两种机制就能很好的实现和客户端的集成整合：<br>使用get-master-addr-by-name和slaves指令可以获取当前的Master和Slaves的地址和信息；而当发生故障转移时，即Master发生切换，可以通过订阅的+switch-master事件获得最新的Master信息。</p><p>sentinel.conf中的notification-script<br>在sentinel.conf中可以配置多个sentinel notification-script <master name> <shell script-path>, 如sentinel notification-script mymaster ./check.sh<br>这个是在群集failover时会触发执行指定的脚本。脚本的执行结果若为1，即稍后重试（最大重试次数为10）；若为2，则执行结束。并且脚本最大执行时间为60秒，超时会被终止执行。</p><p>目前会存在该脚本被执行多次的问题，网上查找资料获得的解释是：脚本分为两个级别， SENTINEL_LEADER 和 SENTINEL_OBSERVER ，前者仅由领头 Sentinel 执行（一个 Sentinel），而后者由监视同一个 master 的所有 Sentinel 执行（多个 Sentinel）。</p><p><strong>无failover时的配置纠正</strong><br>即使当前没有failover正在进行，sentinel依然会使用当前配置去设置监控的master。特别是：<br>1）根据最新配置确认为slaves的节点却声称自己是master(上文例子中被网络隔离后的的redis3)，这时它们会被重新配置为当前master的slave。<br>2）如果slaves连接了一个错误的master，将会被改正过来，连接到正确的master。</p><p><strong>Slave选举与优先级</strong><br>当一个sentinel准备好了要进行failover，并且收到了其他sentinel的授权，那么就需要选举出一个合适的slave来做为新的master。</p><p>slave的选举主要会评估slave的以下几个方面：<br>1）与master断开连接的次数<br>2）Slave的优先级<br>3）数据复制的下标(用来评估slave当前拥有多少master的数据)<br>4）进程ID</p><p>如果一个slave与master失去联系超过10次，并且每次都超过了配置的最大失联时间(down-after-milliseconds)，如果sentinel在进行failover时发现slave失联，那么这个slave就会被sentinel认为不适合用来做新master的。<br>更严格的定义是，如果一个slave持续断开连接的时间超过<br>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state<br>就会被认为失去选举资格。</p><p>符合上述条件的slave才会被列入master候选人列表，并根据以下顺序来进行排序：<br>1）sentinel首先会根据slaves的优先级来进行排序，优先级越小排名越靠前。<br>2）如果优先级相同，则查看复制的下标，哪个从master接收的复制数据多，哪个就靠前。<br>3）如果优先级和下标都相同，就选择进程ID较小的那个。</p><p>一个redis无论是master还是slave，都必须在配置中指定一个slave优先级。要注意到master也是有可能通过failover变成slave的。<br>如果一个redis的slave优先级配置为0，那么它将永远不会被选为master。但是它依然会从master哪里复制数据。</p><p><strong>故障转移</strong><br>所谓故障转移就是当master宕机，选一个合适的slave来晋升为master的操作，redis-sentinel会自动完成这个，不需要我们手动来实现。</p><p>一次故障转移操作大致分为以下流程：<br>发现主服务器已经进入客观下线状态。<br>对我们的当前集群进行自增， 并尝试在这个集群中当选。<br>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤：<br>选出一个从服务器，并将它升级为主服务器。<br>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。<br>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。<br>向已下线主服务器的从服务器发送 SLAVEOF 命令， 让它们去复制新的主服务器。<br>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。<br>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</p><p>Sentinel 使用以下规则来选择新的主服务器：<br>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。<br>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。<br>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</p><p>Sentinel 自动故障迁移的一致性特质<br>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p><p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p><p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p><p>简单来说， 可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p><p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p><p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p><p>Sentinel 状态的持久化<br>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。这意味着停止和重启 Sentinel 进程都是安全的。</p><p>Sentinel 在非故障迁移的情况下对实例进行重新配置<br>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p><p>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。<br>那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。<br>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</p><p><strong>总结来说，故障转移分为三个步骤：</strong></p><p>1）从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务<br>sentinel状态数据结构中保存了主服务的所有从服务信息，领头sentinel按照如下的规则从从服务列表中挑选出新的主服务；<br>删除列表中处于下线状态的从服务；<br>删除最近5秒没有回复过领头sentinel info信息的从服务；<br>删除与已下线的主服务断开连接时间超过 down-after-milliseconds*10毫秒的从服务，这样就能保留从的数据比较新（没有过早的与主断开连接）；<br>领头sentinel从剩下的从列表中选择优先级高的，如果优先级一样，选择偏移量最大的（偏移量大说明复制的数据比较新），如果偏移量一样，选择运行id最小的从服务。</p><p>2）已下线主服务的所有从服务改为复制新的主服务<br>挑选出新的主服务之后，领头sentinel 向原主服务的从服务发送 slaveof 新主服务 的命令，复制新master。</p><p>3）将已下线的主服务设置成新的主服务的从服务，当其回复正常时，复制新的主服务，变成新的主服务的从服务<br>同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从。</p><p>温馨提示：<strong>还可以向任意sentinel发生sentinel failover  进行手动故障转移，这样就不需要经过上述主客观和选举的过程。</strong></p><p><strong>sentinel.conf文件配置参数解释</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）sentinel monitor mymaster <span class="number">192.168</span><span class="number">.10</span><span class="number">.202</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">Sentine监听的maste地址，第一个参数是给master起的名字，第二个参数为master IP，第三个为master端口，第四个为当该master挂了的时候，若想将该master判为失效，</span><br><span class="line">在Sentine集群中必须至少<span class="number">2</span>个Sentine同意才行，只要该数量不达标，则就不会发生故障迁移。也就是说只要有<span class="number">2</span>个sentinel认为master下线，就认为该master客观下线，</span><br><span class="line">启动failover并选举产生新的master。通常最后一个参数不能多于启动的sentinel实例数。</span><br><span class="line"> </span><br><span class="line">这个配置是sentinel需要监控的master/slaver信息，格式为sentinel monitor &lt;mastername&gt; &lt;masterIP&gt; &lt;masterPort&gt; &lt;quorum&gt; </span><br><span class="line">其中&lt;quorum&gt;应该小于集群中slave的个数，当失效的节点数超过了&lt;quorum&gt;,则认为整个体系结构失效</span><br><span class="line"> </span><br><span class="line">不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移，</span><br><span class="line">并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</span><br><span class="line">  </span><br><span class="line">换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">2</span>）sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">表示master被当前sentinel实例认定为失效的间隔时间。</span><br><span class="line">master在多长时间内一直没有给Sentine返回有效信息，则认定该master主观下线。也就是说如果多久没联系上redis-servevr，认为这个redis-server进入到失效（SDOWN）状态。</span><br><span class="line">  </span><br><span class="line">如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</span><br><span class="line">不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移： 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线</span><br><span class="line">（objectively down， 简称 ODOWN ）， 这时自动故障迁移才会执行。</span><br><span class="line">将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">3</span>）sentinel parallel-syncs mymaster <span class="number">2</span></span><br><span class="line">当在执行故障转移时，设置几个slave同时进行切换master，该值越大，则可能就有越多的slave在切换master时不可用，可以将该值设置为<span class="number">1</span>，即一个一个来，这样在某个</span><br><span class="line">slave进行切换master同步数据时，其余的slave还能正常工作，以此保证每次只有一个从服务器处于不能处理命令请求的状态。</span><br><span class="line">  </span><br><span class="line">parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</span><br><span class="line">  </span><br><span class="line">如果从服务器被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明）， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求，</span><br><span class="line">因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求： 如果全部从服务器一起对新的主</span><br><span class="line">服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。</span><br><span class="line"> </span><br><span class="line">当新master产生时，同时进行<span class="string">"slaveof"</span>到新master并进行<span class="string">"SYNC"</span>的slave个数。 </span><br><span class="line">默认为<span class="number">1</span>,建议保持默认值 </span><br><span class="line">在salve执行salveof与同步时，将会终止客户端请求。 </span><br><span class="line">此值较大，意味着<span class="string">"集群"</span>终止客户端请求的时间总和和较大。 </span><br><span class="line">此值较小,意味着<span class="string">"集群"</span>在故障转移期间，多个salve向客户端提供服务时仍然使用旧数据。 </span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">4</span>）sentinel can-failover mymaster yes</span><br><span class="line">在sentinel检测到O_DOWN后，是否对这台redis启动failover机制</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">5</span>）sentinel auth-<span class="keyword">pass</span> mymaster <span class="number">20180408</span></span><br><span class="line">设置sentinel连接的master和slave的密码，这个需要和redis.conf文件中设置的密码一样</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">6</span>）sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line">failover过期时间，当failover开始后，在此时间内仍然没有触发任何failover操作，当前sentinel将会认为此次failoer失败。 </span><br><span class="line">执行故障迁移超时时间，即在指定时间内没有大多数的sentinel 反馈master下线，该故障迁移计划则失效</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">7</span>）sentinel config-epoch mymaster <span class="number">0</span></span><br><span class="line">选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步。这个数字越小， 完成故障转移所需的时间就越长。</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">8</span>）sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line">当failover时，可以指定一个<span class="string">"通知"</span>脚本用来告知当前集群的情况。</span><br><span class="line">脚本被允许执行的最大时间为<span class="number">60</span>秒，如果超时，脚本将会被终止(KILL)</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">9</span>）sentinel leader-epoch mymaster <span class="number">0</span></span><br><span class="line">同时一时间最多<span class="number">0</span>个slave可同时更新配置,建议数字不要太大,以免影响正常对外提供服务。</span><br></pre></td></tr></table></figure><h3 id="Sentinel工作原理"><a href="#Sentinel工作原理" class="headerlink" title="Sentinel工作原理"></a>Sentinel工作原理</h3><p>​        首先要能理解SDOWN和ODOWN这两个词的含义，上面已经详细介绍了它们俩。在此再提一下：<br>SDOWN:subjectively down,直接翻译的为”主观”失效,即当前sentinel实例认为某个redis服务为”不可用”状态.<br>ODOWN:objectively down,直接翻译为”客观”失效,即多个sentinel实例都认为master处于”SDOWN”状态,那么此时master将处于ODOWN,ODOWN可以简单理解为master已经被集群确定<br>为”不可用”,将会开启failover.</p><p>SDOWN适合于master和slave,但是ODOWN只会使用于master;当slave失效超过”down-after-milliseconds”后,那么所有sentinel实例都会将其标记为”SDOWN”。</p><p>​        1) SDOWN与ODOWN转换过程:<br>每个sentinel实例在启动后,都会和已知的slaves/master以及其他sentinels建立TCP连接,并周期性发送PING(默认为1秒)<br>在交互中,如果redis-server无法在”down-after-milliseconds”时间内响应或者响应错误信息,都会被认为此redis-server处于SDOWN状态。<br>如果SDOWN的server为master,那么此时sentinel实例将会向其他sentinel间歇性(一秒)发送”is-master-down-by-addr <ip> <port>“指令并获取响应信息,如果足够多的<br>sentinel实例检测到master处于SDOWN,那么此时当前sentinel实例标记master为ODOWN…其他sentinel实例做同样的交互操作。<br>配置项”sentinel monitor <mastername> <masterip> <masterport> <quorum>“,如果检测到master处于SDOWN状态的slave个数达到<quorum>,那么此时此sentinel实例将会认为<br>master处于ODOWN。每个sentinel实例将会间歇性(10秒)向master和slaves发送”INFO”指令,如果master失效且没有新master选出时,每1秒发送一次”INFO”;”INFO”的主要目的就是<br>获取并确认当前集群环境中slaves和master的存活情况。</p><p>经过上述过程后,所有的sentinel对master失效达成一致后,开始failover.</p><p>​        2) Sentinel与slaves”自动发现”机制:<br>在sentinel的配置文件中(local-sentinel.conf),都指定了port,此port就是sentinel实例侦听其他sentinel实例建立链接的端口.在集群稳定后,最终会每个sentinel实例之间都<br>会建立一个tcp链接,此链接中发送”PING”以及类似于”is-master-down-by-addr”指令集,可用用来检测其他sentinel实例的有效性以及”ODOWN”和”failover”过程中信息的交互.</p><p>在sentinel之间建立连接之前,sentinel将会尽力和配置文件中指定的master建立连接.sentinel与master的连接中的通信主要是基于pub/sub来发布和接收信息,发布的信息内容包<br>括当前sentinel实例的侦听端口:<br>+sentinel sentinel 127.0.0.1:26579 127.0.0.1 26579 …. </p><p>发布的主题名称为”<strong>sentinel</strong>:hello”;同时sentinel实例也是”订阅”此主题,以获得其他sentinel实例的信息.由此可见,环境首次构建时,在默认master存活的情况下,所有的<br>sentinel实例可以通过pub/sub即可获得所有的sentinel信息,此后每个sentinel实例即可以根据+sentinel信息中的”ip+port”和其他sentinel逐个建立tcp连接即可.不过需要提醒<br>的是,每个sentinel实例均会间歇性(5秒)向”<strong>sentinel</strong>:hello”主题中发布自己的ip+port,目的就是让后续加入集群的sentinel实例也能或得到自己的信息。<br>根据上文,我们知道在master有效的情况下,即可通过”INFO”指令获得当前master中已有的slave列表;此后任何slave加入集群,master都会向”主题中”发布”+slave 127.0.0.1:6579 ..”,<br>那么所有的sentinel也将立即获得slave信息,并和slave建立链接并通过PING检测其存活性.</p><p>补充一下,每个sentinel实例都会保存其他sentinel实例的列表以及现存的master/slaves列表,各自的列表中不会有重复的信息(不可能出现多个tcp连接),对于sentinel将使用ip+port<br>做唯一性标记,<br>对于master/slaver将使用runid做唯一性标记,其中redis-server的runid在每次启动时都不同.</p><p>​        3) Leader选举:<br>其实在sentinels故障转移中，仍然需要一个”Leader”来调度整个过程：master的选举以及slave的重配置和同步。当集群中有多个sentinel实例时，如何选举其中一个sentinel为leader呢？</p><p>在配置文件中”can-failover””quorum”参数，以及”is-master-down-by-addr”指令配合来完成整个过程。<br>A) “can-failover”用来表明当前sentinel是否可以参与”failover”过程，如果为”YES”则表明它将有能力参与”Leader”的选举，否则它将作为”Observer”，observer参与leader选举投票但<br>不能被选举；<br>B) “quorum”不仅用来控制master ODOWN状态确认，同时还用来选举leader时最小”赞同票”数；<br>C) “is-master-down-by-addr”，它可以用来检测”ip + port”的master是否已经处于SDOWN状态，不过此指令不仅能够获得master是否处于SDOWN，同时它还额外的返回当前sentinel<br>本地”投票选举”的Leader信息(runid);</p><p>每个sentinel实例都持有其他的sentinels信息，在Leader选举过程中(当为leader的sentinel实例失效时，有可能master server并没失效，注意分开理解)，sentinel实例将从所有的<br>sentinels集合中去除”can-failover = no”和状态为SDOWN的sentinels，在剩余的sentinels列表中按照runid按照”字典”顺序排序后，取出runid最小的sentinel实例，并将它”投票选举”<br>为Leader，并在其他sentinel发送的”is-master-down-by-addr”指令时将推选的runid追加到响应中。每个sentinel实例都会检测”is-master-down-by-addr”的响应结果，如果”投票选举”的<br>leader为自己，且状态正常的sentinels实例中，”赞同者”的自己的sentinel个数不小于(&gt;=) 50% + 1,且不小与<quorum>，那么此sentinel就会认为选举成功且leader为自己。<br>在sentinel.conf文件中，我们期望有足够多的sentinel实例配置”can-failover yes”，这样能够确保当leader失效时，能够选举某个sentinel为leader，以便进行failover。如果leader无法产生，<br>比如较少的sentinels实例有效，那么failover过程将无法继续.</p><p>​        4) failover过程:<br>在Leader触发failover之前，首先wait数秒(随即0~5)，以便让其他sentinel实例准备和调整(有可能多个leader??),如果一切正常，那么leader就需要开始将一个salve提升为master，此slave<br>必须为状态良好(不能处于SDOWN/ODOWN状态)且权重值最低(redis.conf中)的，当master身份被确认后，开始failover<br>A）”+failover-triggered”: Leader开始进行failover，此后紧跟着”+failover-state-wait-start”，wait数秒。<br>B）”+failover-state-select-slave”: Leader开始查找合适的slave<br>C）”+selected-slave”: 已经找到合适的slave<br>D） “+failover-state-sen-slaveof-noone”: Leader向slave发送”slaveof no one”指令，此时slave已经完成角色转换，此slave即为master<br>E） “+failover-state-wait-promotition”: 等待其他sentinel确认slave<br>F）”+promoted-slave”：确认成功<br>G）”+failover-state-reconf-slaves”: 开始对slaves进行reconfig操作。<br>H）”+slave-reconf-sent”:向指定的slave发送”slaveof”指令，告知此slave跟随新的master<br>I）”+slave-reconf-inprog”: 此slave正在执行slaveof + SYNC过程，如过slave收到”+slave-reconf-sent”之后将会执行slaveof操作。<br>J）”+slave-reconf-done”: 此slave同步完成，此后leader可以继续下一个slave的reconfig操作。循环G）<br>K）”+failover-end”: 故障转移结束<br>L）”+switch-master”：故障转移成功后，各个sentinel实例开始监控新的master。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis雪崩，击穿，穿透</title>
      <link href="/2020/05/23/Note/redis%E9%9B%AA%E5%B4%A9%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%A9%BF%E9%80%8F/"/>
      <url>/2020/05/23/Note/redis%E9%9B%AA%E5%B4%A9%EF%BC%8C%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>聪明出于勤奋，天才在于积累。——华罗庚 </p><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。</p><p>(</p><p>1、缓存中大批量热点数据过期后系统涌入大量查询请求</p><p>2、因为大部分数据在Redis层已经失效，请求渗透到数据库层</p><p>3、大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p><p>)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/xuebeng.jpg" alt="img"></p><p>缓存雪崩的事前事中事后的解决方案如下。</p><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p>(</p><p>1、事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃</p><p>2、事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</p><p>3、事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><p>4、用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p><p>5、 限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。这样可以保证数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 -只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。 - 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</p><p>)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/xuebeng1.jpg" alt="img"></p><p>好处：</p><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li><li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li></ul><p><strong>缓存穿透</strong></p><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。</p><p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p><p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“<strong>视缓存于无物</strong>”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/chuantou.jpg" alt="img"></p><p>解决方式很简单。</p><p>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p><strong>缓存击穿</strong></p><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><p>解决方式。</p><p>1、可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><p>2、有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p><p>3、另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis优化</title>
      <link href="/2020/05/23/Note/redis%E4%BC%98%E5%8C%96/"/>
      <url>/2020/05/23/Note/redis%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>聪明出于勤奋，天才在于积累。——华罗庚 </p><hr><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><strong>数据持久化</strong></h3><p><a href="https://www.sirxs.cn/2020/05/21/Note/reids%E6%8C%81%E4%B9%85%E5%8C%96/">数据持久化</a></p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a><strong>内存优化</strong></h3><p>设置<em>maxmemory</em>。设置Redis使用的最大物理内存，即Redis在占用<em>maxmemory</em>大小的内存之后就开始拒绝后续的写入请求，该参数可以确保Redis因为使用了大量内存严重影响速度或者发生<em>OOM</em>。此外，可以使用<code>info</code>命令查看Redis占用的内存及其它信息。</p><p>让键名保持简短。键的长度越长，<code>Redis</code>需要存储的数据也就越多</p><p>使用短结构。主要Redis的<em>list</em>、<em>hash</em>、<em>set</em>、<em>zset</em>这四种数据结构的存储优化。在<em>Redis3.2</em>之前，如果列表、散列或者有序集合的长度或者体积较小，<em>Redis</em>会选择一种名为<em>ziplist</em>的数据结构来存储它们。该结构是列表、散列和有序集合三种不同类型的对象的一种非结构化表示，与Redis在通常情况下使用双向链表来表示列表、使用散列表示散列、使用散列加跳跃表表示有序集合相比，它更加紧凑，避免了存储额外的指针和元数据（比如字符串值的剩余可用空间和结束符”\0”）。但是压缩列表需要在存储的时候进行序列化，读取的时候进行反序列化。以散列为例，在<code>redis.conf</code>中，可以进行如下设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><h3 id="拓展读写能力"><a href="#拓展读写能力" class="headerlink" title="拓展读写能力"></a><strong>拓展读写能力</strong></h3><p>扩展读性能。在<code>redis.conf</code>中添加<code>slaveof host port</code>即可将其配置为另一台Redis服务器的从服务器。注意，在从服务器连接主服务器的时候，从服务器之前的数据会被清空。可以用这种方式建立从服务器树，扩展其读能力。但这种方式并未做故障转移，高可用Redis部署方案可以参考<a href="https://www.jianshu.com/p/afb678794a0e" target="_blank" rel="noopener">Redis Sentinel</a>,<a href="https://link.jianshu.com?t=http%3A%2F%2Fredis.io%2Ftopics%2Fcluster-tutorial" target="_blank" rel="noopener">Redis Cluster</a>和<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FCodisLabs%2Fcodis" target="_blank" rel="noopener">Codis</a>。</p><p>扩展写性能。(1)使用集群分片技术，比如Redis Cluster;(2)单机上运行多个Redis实例。由于Redis是单线程设计，在涉及到cpu bound的操作的时候，可能速度会大大降低。如果服务器的cpu、io资源充足，可以在同一台机器上运行多个Redis服务器。</p><h3 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a><strong>应用程序优化</strong></h3><p>应用程序优化部分主要是客户端和Redis交互的一些建议。主要思想是<strong>尽可能减少操作Redis往返的通信次数</strong>。</p><p>Redis提供了<em>Slow Log</em>功能，可以自动记录耗时较长的命令，<code>redis.conf</code>中的配置如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#执行时间慢于10000毫秒的命令计入Slow Log</span></span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span>  </span><br><span class="line"><span class="comment">#最大纪录多少条Slow Log</span></span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br></pre></td></tr></table></figure><p>使用<code>SLOWLOG GET n</code>命令，可以输出最近n条慢查询日志。使用<code>SLOWLOG RESET</code>命令，可以重置<em>Slow Log</em>。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从</title>
      <link href="/2020/05/23/Note/redis%E4%B8%BB%E4%BB%8E/"/>
      <url>/2020/05/23/Note/redis%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>聪明出于勤奋，天才在于积累。——华罗庚 </p><hr><h2 id="redis主从原理"><a href="#redis主从原理" class="headerlink" title="redis主从原理"></a>redis主从原理</h2><h3 id="一、复制过程"><a href="#一、复制过程" class="headerlink" title="一、复制过程"></a>一、复制过程</h3><p>　1、从节点执行 slaveof 命令</p><p>　2、从节点只是保存了 slaveof 命令中主节点的信息，并没有立即发起复制</p><p>　3、从节点内部的定时任务发现有主节点的信息，开始使用 socket 连接主节点</p><p>　4、连接建立成功后，发送 ping 命令，希望得到 pong 命令响应，否则会进行重连</p><p>　5、如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。</p><p>　6、权限验证通过后，进行数据同步，这是耗时最长的操作，主节点将把所有的数据全部发送给从节点。</p><p>　7、当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</p><h3 id="二、数据间的同步"><a href="#二、数据间的同步" class="headerlink" title="二、数据间的同步"></a>二、数据间的同步</h3><h4 id="redis-同步有-2-个命令："><a href="#redis-同步有-2-个命令：" class="headerlink" title="　redis 同步有 2 个命令："></a>　redis 同步有 2 个命令：</h4><p>　　　sync 和 psync，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。　　　　　　</p><h4 id="psync-命令需要-3-个组件支持："><a href="#psync-命令需要-3-个组件支持：" class="headerlink" title="　psync 命令需要 3 个组件支持："></a>　psync 命令需要 3 个组件支持：</h4><p>　　　a、主从节点各自复制偏移量</p><p>　　　b、主节点复制积压缓冲区</p><p>　　　c、主节点运行 ID</p><h4 id="主从节点各自复制偏移量："><a href="#主从节点各自复制偏移量：" class="headerlink" title="主从节点各自复制偏移量："></a>主从节点各自复制偏移量：</h4><p>　　　1、参与复制的主从节点都会维护自身的复制偏移量。</p><p>　　　2、主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication 中的 masterreploffset 指标中。</p><p>　　　3、从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</p><p>　　　4、从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。</p><p>　　　5、通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</p><h4 id="主节点复制积压缓冲区："><a href="#主节点复制积压缓冲区：" class="headerlink" title="　主节点复制积压缓冲区："></a>　主节点复制积压缓冲区：</h4><p>　　　1、复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1MB。</p><p>　　　2、这个队列在 slave 连接时创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。</p><p>　　　3、他的作用就是用于部分复制和复制命令丢失的数据补救。通过 info replication 可以看到相关信息。</p><h4 id="主节点运行-ID："><a href="#主节点运行-ID：" class="headerlink" title="主节点运行 ID："></a>主节点运行 ID：</h4><p>　　　1、每个 redis 启动的时候，都会生成一个 40 位的运行 ID。</p><p>　　　2、运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。</p><h4 id="如果在重启时不改变运行-ID-呢？"><a href="#如果在重启时不改变运行-ID-呢？" class="headerlink" title="　如果在重启时不改变运行 ID 呢？"></a>　如果在重启时不改变运行 ID 呢？</h4><p>​    　　1、可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。</p><p>　　　2、他的缺点则是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者无法容忍阻塞的节点，需要谨慎使用。一般通过故障转移机制可以解决这个问题。</p><h4 id="psync-命令的使用方式："><a href="#psync-命令的使用方式：" class="headerlink" title="　psync 命令的使用方式："></a>　psync 命令的使用方式：</h4><p>　　　命令格式为 psync{runId}{offset}</p><p>　　　runId：从节点所复制主节点的运行</p><p>　　　id offset：当前从节点已复制的数据偏移量</p><h4 id="psync-执行流程："><a href="#psync-执行流程：" class="headerlink" title="psync 执行流程："></a>psync 执行流程：</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/psync.png" alt="img"></p><p><strong>流程说明：</strong>从节点发送 psync 命令给主节点，runId 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的复制偏移量，如果是第一次复制则为 -1.</p><h4 id="主节点会根据-runid-和-offset-决定返回结果："><a href="#主节点会根据-runid-和-offset-决定返回结果：" class="headerlink" title="　主节点会根据 runid 和 offset 决定返回结果："></a>　主节点会根据 runid 和 offset 决定返回结果：</h4><p>　　　1、如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。</p><p>　　　2、如果回复 +CONTINUE，从节点将触发部分复制。</p><p>　　　3、如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。</p><p>　　　4、到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。</p><h3 id="三、全量复制"><a href="#三、全量复制" class="headerlink" title="三、全量复制　　　　"></a>三、全量复制　　　　</h3><p>　    1、全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的的阶段。</p><p>　　2、触发全量复制的命令是 sync 和 psync。</p><p>　　3、之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，2.8 之后同时支持全量同步和部分同步。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="img"></p><p>a、发送 psync 命令（spync ？ -1）</p><p>b、主节点根据命令返回 FULLRESYNC</p><p>c、从节点记录主节点 ID 和 offset</p><p><strong>d、主节点 bgsave 并保存 RDB 到本地</strong></p><p><strong>e、主节点发送 RBD 文件到从节点</strong></p><p><strong>f、从节点收到 RDB 文件并加载到内存中</strong></p><p>g、主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）</p><p><strong>h、从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭.</strong></p><p><strong>i、从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof。</strong></p><p><strong>注意：</strong></p><p>　　1、如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。<strong>可以通过调大 repl-timeout 参数来解决此问题</strong>。</p><p>　　2、Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。</p><h3 id="四、部分复制"><a href="#四、部分复制" class="headerlink" title="四、部分复制"></a>四、部分复制</h3><p>　　1、当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据　</p><p>　　2、主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。　</p><p>​    a、当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。</p><p>　b、主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。</p><p>　c、当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点</p><p>　d、主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —— 表示可以进行部分复制</p><p>　e、主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。</p><h3 id="五、心跳"><a href="#五、心跳" class="headerlink" title="五、心跳"></a>五、心跳</h3><p>　主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。</p><p>　心跳的关键机制如下：</p><p>　　    1、主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。</p><p>　　    2、主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。</p><p>　　　3、从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。</p><p>　　　4、主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。</p><p>注意：为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>　<strong>Redis主从同步策略</strong></p><p>　　1、主从刚刚连接的时候，进行全量同步；</p><p>　　2、全同步结束后，进行增量同步。</p><p>　　3、如果有需要，slave 在任何时候都可以发起全量同步。</p><p>　　4、redis 策略是，无论如何，首先会尝试进行增量同步；</p><p>　　5、不成功，要求从机进行全量同步。</p><p>　<strong>注意点：</strong></p><p>　　1、如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，</p><p>　　2、当多个同时出现的时候，可能会导致Master IO剧增宕机。</p><h4 id="主从复制的特点"><a href="#主从复制的特点" class="headerlink" title="主从复制的特点"></a>主从复制的特点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）采用异步复制；</span><br><span class="line"><span class="number">2</span>）一个主redis可以含有多个从redis；</span><br><span class="line"><span class="number">3</span>）每个从redis可以接收来自其他从redis服务器的连接；</span><br><span class="line"><span class="number">4</span>）主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；</span><br><span class="line"><span class="number">5</span>）主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，只不过这时候从redis返回的是以前老的数据，</span><br><span class="line">   如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis在复制同步过程中来自外界的查询请求都会返回错误给客户端；（虽然说主从复制过程中</span><br><span class="line">   对于从redis是非阻塞的，但是当从redis从主redis同步过来最新的数据后还需要将新数据加载到内存中，在加载到内存的过程中是阻塞的，在这段时间内的请求将会被阻，</span><br><span class="line">   但是即使对于大数据集，加载到内存的时间也是比较多的）；</span><br><span class="line"><span class="number">6</span>）主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；</span><br><span class="line"><span class="number">7</span>）为了编码主redis服务器写磁盘压力带来的开销，可以配置让主redis不在将数据持久化到磁盘，而是通过连接让一个配置的从redis服务器及时的将相关数据持久化到磁盘，</span><br><span class="line">   不过这样会存在一个问题，就是主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空；</span><br></pre></td></tr></table></figure><h4 id="主从同步时的几个问题"><a href="#主从同步时的几个问题" class="headerlink" title="主从同步时的几个问题"></a>主从同步时的几个问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）在上面的全量同步过程中，master会将数据保存在rdb文件中然后发送给slave服务器，但是如果master上的磁盘空间有效怎么办呢？那么此时全部同步对于master来说</span><br><span class="line">将是一份十分有压力的操作了。此时可以通过无盘复制来达到目的，由master直接开启一个socket将rdb文件发送给slave服务器。（无盘复制一般应用在磁盘空间有限但是网</span><br><span class="line">络状态良好的情况下）</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>）主从复制结构，一般slave服务器不能进行写操作，但是这不是死的，之所以这样是为了更容易的保证主和各个从之间数据的一致性，如果slave服务器上数据进行了修改，</span><br><span class="line">那么要保证所有主从服务器都能一致，可能在结构上和处理逻辑上更为负责。不过你也可以通过配置文件让从服务器支持写操作。（不过所带来的影响还得自己承担哦。。。）</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>）主从服务器之间会定期进行通话，但是如果master上设置了密码，那么如果不给slave设置密码就会导致slave不能跟master进行任何操作，所以如果你的master服务器</span><br><span class="line">上有密码，那么也给slave相应的设置一下密码吧（通过设置配置文件中的masterauth）;</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>）关于slave服务器上过期键的处理，由master服务器负责键的过期删除处理，然后将相关删除命令已数据同步的方式同步给slave服务器，slave服务器根据删除命令删除</span><br><span class="line">本地的key。</span><br></pre></td></tr></table></figure><h4 id="当主服务器不能持久化时复制的安全性"><a href="#当主服务器不能持久化时复制的安全性" class="headerlink" title="当主服务器不能持久化时复制的安全性"></a>当主服务器不能持久化时复制的安全性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</span><br><span class="line"> </span><br><span class="line">为什么不持久化的主服务器自动重启非常危险呢？</span><br><span class="line">为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</span><br><span class="line"> </span><br><span class="line">设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</span><br><span class="line">这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</span><br><span class="line">节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</span><br><span class="line">当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。</span><br><span class="line">比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</span><br><span class="line"> </span><br><span class="line">如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</span><br></pre></td></tr></table></figure><h4 id="只读服务器"><a href="#只读服务器" class="headerlink" title="只读服务器"></a>只读服务器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从Redis <span class="number">2.6</span>开始，从服务器支持只读模式，并且是默认模式。这个行为是由Redis.conf文件中的slave-read-only 参数控制的，</span><br><span class="line">可以在运行中通过CONFIG SET来启用或者禁用。</span><br><span class="line"> </span><br><span class="line">只读的从服务器会拒绝所有写命令，所以对从服务器不会有误写操作。但这不表示可以把从服务器实例暴露在危险的网络环境下，</span><br><span class="line">因为像DEBUG或者CONFIG这样的管理命令还是可以运行的。不过你可以通过使用rename-command命令来为这些命令改名来增加安全性。</span><br><span class="line"> </span><br><span class="line">你可能想知道为什么只读限制还可以被还原，使得从服务器还可以进行写操作。虽然当主从服务器进行重新同步或者从服务器重启后，</span><br><span class="line">这些写操作都会失效，还是有一些使用场景会想从服务器中写入临时数据的，但将来这个特性可能会被去掉。</span><br></pre></td></tr></table></figure><h4 id="限制有N个以上服务器才允许写入"><a href="#限制有N个以上服务器才允许写入" class="headerlink" title="限制有N个以上服务器才允许写入"></a>限制有N个以上服务器才允许写入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">从Redis <span class="number">2.8</span>版本开始，可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。但是，因为Redis使用的是异步主从复制，</span><br><span class="line">没办法确保从服务器确实收到了要写入的数据，所以还是有一定的数据丢失的可能性。</span><br><span class="line"> </span><br><span class="line">这一特性的工作原理如下：</span><br><span class="line"><span class="number">1</span>）从服务器每秒钟ping一次主服务器，确认处理的复制流数量。</span><br><span class="line"><span class="number">2</span>）主服务器记住每个从服务器最近一次ping的时间。</span><br><span class="line"><span class="number">3</span>）用户可以配置最少要有N个服务器有小于M秒的确认延迟。</span><br><span class="line"><span class="number">4</span>）如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。</span><br><span class="line"> </span><br><span class="line">还可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的一致性实现，虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。</span><br><span class="line"> </span><br><span class="line">如果条件不满足，主服务器会拒绝写操作并返回一个错误。</span><br><span class="line"><span class="number">1</span>）min-slaves-to-write（最小从服务器数）</span><br><span class="line"><span class="number">2</span>）min-slaves-max-lag（从服务器最大确认延迟）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《小丑》 （美国2019年托德·菲利普斯执导电影）</title>
      <link href="/2020/05/22/Movie/joker/"/>
      <url>/2020/05/22/Movie/joker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="电影背景"><a href="#电影背景" class="headerlink" title="电影背景"></a>电影背景</h3><p>《<a href="https://baike.baidu.com/item/%E5%B0%8F%E4%B8%91/22867904?fr=aladdin" target="_blank" rel="noopener">小丑</a>》是由托德·菲利普斯执导，杰昆·菲尼克斯、莎姬·贝兹、罗伯特·德尼罗、弗兰西丝·康罗伊、布莱特·卡伦等联袂出演的犯罪剧情片。2019年8月31日在威尼斯电影节主竞赛单元首映。</p><p>《小丑》的故事背景设定在1980年代，讲述小丑的起源故事 。该片是华纳和DC所独立开发的影片，与DC扩展宇宙并无关联。</p><p>该片于2019年10月4日在美国上映，随即以9620万美元的收入登顶北美周末票房榜，创下北美影史10月份上映影片首周末最高票房纪录。截至2019年11月8日，《小丑》全球票房将超过9.57亿美元，成为了影史上最赚钱的漫改电影</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/joker1.jpg" alt="move"></p><h3 id="剧情简介"><a href="#剧情简介" class="headerlink" title="剧情简介"></a>剧情简介</h3><p>亚瑟·弗莱克是一个和母亲住在老旧公寓里，需要靠社会福利组织帮助，不断服用精神疾病药物的小丑。他想成为一个脱口秀演员，但并不成功。人们只是嘲笑他。他在地铁上爆发式地犯下了谋杀案。他的世界，就此一点一滴地开始崩塌了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/joker2.jpg" alt="move"></p><h3 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h3><p>导演兼编剧的托德·菲利普斯透露，《小丑》取材并不遵循任何漫画。托德·菲利普斯按照自己的认知，创造了一个故事，没有从漫画书中汲取任何灵感。讲述了小丑这样的角色是如何产生的，这就是托德·菲利普斯感兴趣的地方。<br>该片的故事背景设定在1980年代。托德·菲利普斯打造一个纯粹全新的小丑起源故事</p><h3 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h3><p>《小丑》电影2019剧情简介 菲尼克斯演绎不一样的丑爷。</p><p>《小丑》新剧照正面亮相！由杰昆·菲尼克斯主演、托德·菲利普斯执导的DC漫改电影《小丑》登上了《il Venerdì》8月刊封面。</p><p>新剧照中，小丑妆容粗糙，蓝色的眼部装饰上面蜿蜒着高低不一的红色眉毛，猩红的嘴唇难掩从鼻翼两侧延伸出的法令纹。区别于以往的嚣张和邪恶，该剧照中小丑的双眼暗含平静的力量，这或许与该片讲述的是小丑亚瑟·弗莱克的起源故事有关。其实，DC反派小丑的形象已被多次搬上大银幕，杰昆·菲尼克斯版的小丑能否超越希斯·莱杰这座“大山”，演绎属于自己的丑爷经典？</p><p>《小丑》虽然被定为R级电影，但强大的阵容依然是高票房的加持力量。主演杰昆·菲尼克斯曾多次获得奥斯卡提名，并将被多伦多电影节组委会授予年度演员荣誉奖。导演托德·菲利普斯曾执导《宿醉》系列，编剧斯科特·西尔弗曾担任“姆爷”埃米纳姆的自传电影《8英里》的编剧。</p><p>该片讲述了小丑亚瑟·弗莱克的起源故事。上世纪80年代，一位生活陷入困境的喜剧演员渐渐走向精神的崩溃，在哥谭市开始了疯狂的犯罪生涯，最终成为了蝙蝠侠的宿敌“小丑”。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:F9D6CD6E5D93FC013D079981387D8E556FF139A4</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据淘汰机制</title>
      <link href="/2020/05/22/Note/Redis%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/05/22/Note/Redis%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>书痴者文必工，艺痴者技必良。——蒲松龄 </p><hr><h1 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h1><h3 id="一、五种数据淘汰机制的具体实现"><a href="#一、五种数据淘汰机制的具体实现" class="headerlink" title="一、五种数据淘汰机制的具体实现"></a><strong>一、五种数据淘汰机制的具体实现</strong></h3><ul><li>volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰，从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>volatile-random：随机淘汰数据，只淘汰设定了有效期的key，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-random：随机淘汰数据，所有的key都可以被淘汰，从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>volatile-ttl：淘汰剩余有效期最短的key，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li></li></ul><h3 id="二、设置redis的最大存储空间"><a href="#二、设置redis的最大存储空间" class="headerlink" title="二、设置redis的最大存储空间"></a><strong>二、设置redis的最大存储空间</strong></h3><p>内存的淘汰机制的初衷是为了更好地使用内存，用一定的缓存miss来换取内存的使用效率。</p><p><strong>首先要配置maxmemory值</strong></p><p>1.客户端发起了需要申请更多内存的命令（如set）。</p><p>2.Redis检查内存使用情况，如果已使用的内存大于maxmemory则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存。</p><p>3.如果上面都没问题，则这个命令执行成功。</p><p>maxmemory为0的时候表示我们对Redis的内存使用没有限制。</p><p>配置方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru   <span class="comment">#默认是noeviction，即不进行数据淘汰</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis五大数据类型</title>
      <link href="/2020/05/21/Note/redis/"/>
      <url>/2020/05/21/Note/redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>读不在三更五鼓,功只怕一曝十寒。——郭沫若</p><hr><h2 id="一、redis的五大数据类型实现原理"><a href="#一、redis的五大数据类型实现原理" class="headerlink" title="一、redis的五大数据类型实现原理"></a>一、redis的五大数据类型实现原理</h2><p><strong>说明</strong></p><p>1、redis中所有的数据结构都已唯一的key字符串作为名称，然后通过这个唯一的key来获取对应的value</p><p>2、不同的数据类型数据结构差异就在于value的结构不一样</p><h3 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a><strong>字符串（string）</strong></h3><p>1、value的数据结构（数组）</p><p>​    ①、字符串value数据结构类似于数组，采用与分配容易空间来减少内存频繁分配</p><p>​    ②、当字符串长度小于1M时，扩容就是加倍现有空间</p><p>​    ③、如果字符串长度操作1M时，扩容时最多扩容1M空间，字符串最大长度为 512M</p><p>2、字符串的使用场景（缓存）</p><p>​    ①、字符串一个常见的用途是缓存用户信息，我们将用户信息使用JSON序列化成字符串</p><p>​    ②、取用户信息时会经过一次反序列化的过程</p><h3 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a><strong>list（列表）</strong></h3><p>1、value的数据结构（双向链表）</p><p>​    ①、列表的数据结构是双向链表，这意味着插入和删除的时间复杂度是0(1)，索引的时间复杂度位0(n)</p><p>​    ②、当列表弹出最后一个元素后，该数据结构会被自动删除，内存被回手</p><p>2、列表的使用场景（队列，栈）</p><h3 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a><strong>hash（字典）</strong></h3><p>1、value的数据结构（HashMap）</p><p>​    ①、 redis中的字典也是HashMap（数组+列表）的二维结构</p><p>​    ②、不同的是redis的字典的值只能是字符串</p><p>2、hash的使用场景（缓存）</p><p>​    ①、hash可以用来缓存用户信息，与字符串一次性全部序列化整个对象不同，hash可以对每个字段进行单独存储</p><p>​    ②、这样可以部分获取用户信息，节约网络流量</p><p>​    ③、hash也有缺点，hash结构的存储消耗要高于单个字符串</p><h3 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a><strong>set（集合）</strong></h3><p>1、集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p><h3 id="zset-（有序集合）"><a href="#zset-（有序集合）" class="headerlink" title="zset （有序集合）"></a><strong>zset （有序集合）</strong></h3><p>1、和上面的集合对象相比，有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p><h2 id="二、五大数据类型的应用场景"><a href="#二、五大数据类型的应用场景" class="headerlink" title="二、五大数据类型的应用场景"></a>二、五大数据类型的应用场景</h2><p>1、对于string 数据类型，因为string 类型是二进制安全的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作计数器（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。</p><p>2、对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。</p><p>3、对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能</p><p>4、对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>5、对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆地理编码</title>
      <link href="/2020/05/19/Blog/1/"/>
      <url>/2020/05/19/Blog/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="根据经纬度获取地理位置（逆地理编码）"><a href="#根据经纬度获取地理位置（逆地理编码）" class="headerlink" title="根据经纬度获取地理位置（逆地理编码）"></a>根据经纬度获取地理位置（逆地理编码）</h3><h4 id="获取高德key"><a href="#获取高德key" class="headerlink" title="获取高德key"></a>获取高德key</h4><table><thead><tr><th>url</th><th><a href="https://restapi.amap.com/v3/geocode/regeo?parameters" target="_blank" rel="noopener">https://restapi.amap.com/v3/geocode/regeo?parameters</a></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr></tbody></table><h4 id="通过key与经纬度来获取地理位置"><a href="#通过key与经纬度来获取地理位置" class="headerlink" title="通过key与经纬度来获取地理位置"></a>通过key与经纬度来获取地理位置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#run"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          $.<span class="keyword">get</span>(&#123;</span><br><span class="line">              url: <span class="string">"https://restapi.amap.com/v3/place/around"</span>,</span><br><span class="line">              dataType: <span class="string">"json"</span>,</span><br><span class="line">              data: &#123;<span class="attr">key</span>:<span class="string">"04c0e3f51ca3ef8a45ec00ac9e57150c"</span>,<span class="attr">location</span>:<span class="string">"120.045846,30.231004"</span>,<span class="attr">radius</span>:<span class="number">100</span>,<span class="attr">types</span>:<span class="string">"190000"</span>,<span class="attr">extensions</span>:<span class="string">"all"</span>&#125;,</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合索引的意义，作用，以及使用方式（ORM）</title>
      <link href="/2020/05/19/Note/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95(orm)/"/>
      <url>/2020/05/19/Note/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95(orm)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、为什么要用联合索引"><a href="#一、为什么要用联合索引" class="headerlink" title="一、为什么要用联合索引"></a>一、为什么要用联合索引</h3><p>1、每多创建一个索引，都会增加操作的开销和磁盘空间的开销。对于大量数据的表，这可是不小的开销。</p><p>2、覆盖索引。数据库可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</p><p>3、索引列越多，通过索引筛选出的数据越少。如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知。</p><h3 id="二、联合索引的使用"><a href="#二、联合索引的使用" class="headerlink" title="二、联合索引的使用"></a>二、联合索引的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    #一.常用字段：</span><br><span class="line"></span><br><span class="line">    #1.字符字段</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">    #2.数字字段</span><br><span class="line">    age &#x3D; models.IntegerField()#整数</span><br><span class="line">    num &#x3D; models.DecimalField(max_digits&#x3D;10,decimal_places&#x3D;2)#小数，长度10，小数点位数2</span><br><span class="line"></span><br><span class="line">    #3.时间字段</span><br><span class="line">    ctime &#x3D; models.DateTimeField()</span><br><span class="line">    # 时间字段通过models.User.objects.create(ctime&#x3D;&#39;2020-4-29&#39;)来添加数据</span><br><span class="line"></span><br><span class="line">    #二.常用参数：</span><br><span class="line">    null &#x3D; True</span><br><span class="line">    default &#x3D; xx</span><br><span class="line">    max_length &#x3D; 32</span><br><span class="line">    db_index &#x3D; True #普通索引</span><br><span class="line">    unique &#x3D; True #唯一索引</span><br><span class="line"></span><br><span class="line">    #class Meta是固定写法，并且必须写在class User里面，只要写在它里面就可以起作用。</span><br><span class="line">    class Meta:</span><br><span class="line">        #联合唯一索引</span><br><span class="line">        unique_together &#x3D; (</span><br><span class="line">            (&#39;username&#39;,&#39;age&#39;),</span><br><span class="line">        )</span><br><span class="line">        #联合索引(不唯一)</span><br><span class="line">        index_together &#x3D; (</span><br><span class="line">            (&#39;username&#39;, &#39;age&#39;),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h3><p>1、联合索引不要以主键开头，不然联合索引和主键索引作用是一样的</p><p>2、当你的查询sql where条件中用到的多个字段在联合索引中的查询速度优于在单列索引的速度</p><p>3、使用联合索引时，当你的where条件中不包含联合索引中的第一个字段时，无法用到索引</p><p>4、根据最左原则，联合索引可以使用部分生效的索引。(a,b,c) 当 where a=1 and c=2 a 索引是生效的</p><p>5、单列索引不受字段最左原则限制,但受内容最左原则限制</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RBAC权限管理</title>
      <link href="/2020/05/18/Note/RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/18/Note/RBAC%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="一、RBAC模型是什么？"><a href="#一、RBAC模型是什么？" class="headerlink" title="一、RBAC模型是什么？"></a>一、RBAC模型是什么？</h3><p>RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。我们可以根据自家产品权限的复杂程度，选取适合的权限模型。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca1.png" alt="RBAC"></p><h3 id="二、基本模型RBAC0"><a href="#二、基本模型RBAC0" class="headerlink" title="二、基本模型RBAC0"></a>二、基本模型RBAC0</h3><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>RBAC0是基础，很多产品只需基于RBAC0就可以搭建权限模型了。在这个模型中，我们把权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。用户拥有的权限等于他所有的角色持有权限之和。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca2.png" alt="RBAC"></p><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><p>譬如我们做一款企业管理产品，如果按传统权限模型，给每一个用户赋予权限则会非常麻烦，并且做不到批量修改用户权限。这时候，可以抽象出几个角色，譬如销售经理、财务经理、市场经理等，然后把权限分配给这些角色，再把角色赋予用户。这样无论是分配权限还是以后的修改权限，只需要修改用户和角色的关系，或角色和权限的关系即可，更加灵活方便。此外，如果一个用户有多个角色，譬如王先生既负责销售部也负责市场部，那么可以给王先生赋予两个角色，即销售经理+市场经理，这样他就拥有这两个角色的所有权限。</p><h3 id="三、角色分层模型RBAC1"><a href="#三、角色分层模型RBAC1" class="headerlink" title="三、角色分层模型RBAC1"></a>三、角色分层模型RBAC1</h3><h5 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h5><p>RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。简单理解就是，给角色可以分成几个等级，每个等级权限不同，从而实现更细粒度的权限管理</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca3.png" alt="RBAC"></p><h5 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h5><p>基于之前RBAC0的例子，我们又发现一个公司的销售经理可能是分几个等级的，譬如除了销售经理，还有销售副经理，而销售副经理只有销售经理的部分权限。这时候，我们就可以采用RBAC1的分级模型，把销售经理这个角色分成多个等级，给销售副经理赋予较低的等级即可。</p><h3 id="四、角色限制模型RBAC2"><a href="#四、角色限制模型RBAC2" class="headerlink" title="四、角色限制模型RBAC2"></a>四、角色限制模型RBAC2</h3><h5 id="解析：-2"><a href="#解析：-2" class="headerlink" title="解析："></a>解析：</h5><p>RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。具体限制如下图：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca4.png" alt="RBAC"></p><h5 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h5><p>还是基于之前RBAC0的例子，我们又发现有些角色之间是需要互斥的，譬如给一个用户分配了销售经理的角色，就不能给他再赋予财务经理的角色了，否则他即可以录入合同又能自己审核合同；再譬如，有些公司对角色的升级十分看重，一个销售员要想升级到销售经理，必须先升级到销售主管，这时候就要采用先决条件限制了。</p><h3 id="五、统一模型RBAC3"><a href="#五、统一模型RBAC3" class="headerlink" title="五、统一模型RBAC3"></a>五、统一模型RBAC3</h3><h5 id="解析：-3"><a href="#解析：-3" class="headerlink" title="解析："></a>解析：</h5><p>RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca5.png" alt="RBAC"></p><h5 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h5><p>这个就不举例了，统一模型RBAC3可以解决上面三个例子的所有问题。当然，只有在系统对权限要求非常复杂时，才考虑使用此权限模型。</p><h3 id="六、基于RBAC的延展–用户组"><a href="#六、基于RBAC的延展–用户组" class="headerlink" title="六、基于RBAC的延展–用户组"></a>六、基于RBAC的延展–用户组</h3><h5 id="解析：-4"><a href="#解析：-4" class="headerlink" title="解析："></a>解析：</h5><p>基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/rbca6.png" alt="RBAC"></p><h5 id="举例：-4"><a href="#举例：-4" class="headerlink" title="举例："></a>举例：</h5><p>譬如，我们可以把一个部门看成一个用户组，如销售部，财务部，再给这个部门直接赋予角色，使部门拥有部门权限，这样这个部门的所有用户都有了部门权限。用户组概念可以更方便的给群体用户授权，且不影响用户本来就拥有的角色权限。</p><h1 id="设计表结构"><a href="#设计表结构" class="headerlink" title="设计表结构"></a>设计表结构</h1><p>models中创建类：五个类，七张表</p><p>　角色表：<br>　用户表：<br>　权限表：<br>　组表：<br>　菜单表：</p><p>角色表和权限表是多对多的关系（一个角色可以有多个权限，一个权限可以对应多个角色）</p><p>用户表和角色表是多对多的关系（一个用户可以有多个角色，一个角色有多个用户）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class Role(models.Model):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    角色表</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;角色名&quot;)</span><br><span class="line">    permissions &#x3D; models.ManyToManyField(to&#x3D;&quot;Permission&quot;,verbose_name&#x3D;&quot;具有的所有权限&quot;, blank&#x3D;True)  # 建立用户表和角色表的多对多关系</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;角色表&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line">    caption &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;组名称&quot;)</span><br><span class="line">    menu &#x3D; models.ForeignKey(to&#x3D;&quot;Menu&quot;,verbose_name&#x3D;&quot;所属菜单&quot;,default&#x3D;1,related_name&#x3D;&quot;menu&quot;)</span><br><span class="line">class Menu(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">class Permission(models.Model):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    权限表</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;标题&quot;)</span><br><span class="line">    url &#x3D; models.CharField(max_length&#x3D;64,verbose_name&#x3D;&quot;带正则的URL&quot;)</span><br><span class="line">    # is_mune &#x3D; models.BooleanField(verbose_name&#x3D;&quot;是否是菜单&quot;,default&#x3D;0)</span><br><span class="line">    menu_gp &#x3D; models.ForeignKey(verbose_name&#x3D;&quot;组内菜单&quot;,to&#x3D;&quot;Permission&quot;,blank&#x3D;True,null&#x3D;True)  #自关联</span><br><span class="line">    #主页就可以设置为菜单，当点击菜单的时候才可以做具体的操作</span><br><span class="line">    codes &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;代码&quot;,default&#x3D;1)</span><br><span class="line">    group &#x3D; models.ForeignKey(to&#x3D;&quot;Group&quot;,verbose_name&#x3D;&quot;所属组&quot;,null&#x3D;True)  #新添加的字段记得设置默认值</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        &#39;&#39;&#39;中文显示&#39;&#39;&#39;</span><br><span class="line">        verbose_name_plural &#x3D; &quot;权限表&quot;</span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    用户表</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;用户名&quot;)</span><br><span class="line">    password &#x3D; models.CharField(max_length&#x3D;64,verbose_name&#x3D;&quot;密码&quot;)</span><br><span class="line">    email &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&quot;邮箱&quot;)</span><br><span class="line">    roles &#x3D; models.ManyToManyField(to&#x3D;&quot;Role&quot;,verbose_name&#x3D;&quot;具有的所有角色&quot;,blank&#x3D;True)  #建立用户和角色的多对多关系</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;用户表&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《哪吒之魔童降世》国漫的崛起？</title>
      <link href="/2020/05/15/Movie/nezha/"/>
      <url>/2020/05/15/Movie/nezha/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《哪吒之魔童降世》是由霍尔果斯彩条屋影业有限公司出品的动画电影，由饺子执导兼编剧，吕艳婷、囧森瑟夫、瀚墨、陈浩、绿绮、张珈铭、杨卫担任主要配音。</p><p>该片改编自中国神话故事，讲述了哪吒虽“生而为魔”却“逆天而行斗到底”的成长经历的故事。该片于2019年7月26日在中国内地上映。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ne1.jpg" alt="move"></p><p>2019年9月6日，第十二届中国国际漫画节开幕式暨第16届中国动漫金龙奖颁奖大会于广州举行。《哪吒之魔童降世》获得最佳动画长片奖金奖、最佳动画导演奖、最佳动画编剧奖、最佳动画配音奖</p><p>2019年10月8日，电影《哪吒之魔童降世》将代表中国内地参选2020年第92届奥斯卡最佳国际影片（原最佳外语片）。《哪吒之魔童降世》被授予推介委员会特别荣誉推介电影。</p><p>2019年1月17日，片方发布“是他，就是他”版预告  。同年5月30日，片方发布首款定档预告及海报   。7月10日，片方发布一组中国风人物海报 。7月13日，该片在成都开展全国首批观影和路演 。7月21日，该片在成都举办千人首映礼 。7月23日，该片与动画电影《西游记之大圣归来》发布联动短片。7月23日，片方在北京举办“做自己的英雄”主题首映礼。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/ne2.jpg" alt="move"></p><p>天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王，这调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对哪吒的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔，他将何去何从。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:EA381AE8A4E5F86850BE3929DF8734E69089ACC7</p><p>该片在前作的基础上大胆创新，既保留了中国传统文化的精髓，又加入了流行元素，让所要展现的文化更易于被受众接受。它打破成见，强调自我的独立性，更兼顾有隐喻的现实。片中有不少世俗丑恶的一面，比起真相，很多人更愿意去相信道听途说，然后带着有色眼镜去看人。反叛型超级英雄，虽看起来反叛传统却依然保留着最中正的热血和感动，依然有着奉献和担当的着中华文化的价值取向。</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django + Uwsgi + Nginx 的生产环境部署</title>
      <link href="/2020/05/10/Blog/fourteen/"/>
      <url>/2020/05/10/Blog/fourteen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、什么是WSGI（WSGI是一种python专用的web协议  和http类似）:</p><p>　　　　　　1. WSGI是一种规范，它定义了使用python编写的web app(django)与web server（uWSGI）之间接口格式，实现web app与web server间的解耦。</p><p>　　　　　　2. WSGI 没有官方的实现, 因为WSGI更像一个协议. 只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行</p><p>　　　　　　3. WSGI实质：WSGI是一种描述web服务器（如nginx，uWSGI等服务器）如何与web应用程序（如用Django、Flask框架写的程序）通信的规范、协议。 </p><p>2、为什么需要web协议：</p><p>　　　　　　　　1）不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。</p><p>　　　　　　　　2） 这样，服务器程序就需要为不同的框架提供不同的支持,只有支持它的服务器才能被开发出的应用使用，显然这是不可行的。</p><p>　　　　　　　　3）web协议本质：就是定义了Web服务器和Web应用程序或框架之间的一种简单而通用的接口规范。</p><p>3、Web协议介绍</p><p>　　　　Web协议出现顺序： CGI -&gt; FCGI -&gt; WSGI -&gt; uwsgi</p><p>　　　　　　　　1. CGI：  最早的协议</p><p>　　　　　　　　2. FCGI：  比CGI快</p><p>　　　　　　　　3. WSGI： Python专用的协议</p><p>　　　　　　　　4. uwsgi： 比FCGI和WSGI都快，是uWSGI项目自有的协议，主要特征是采用二进制来存储数据，<br>　　　　　　　　                之前的协议都是使用字符串，所以在存储空间和解析速度上，都优于字符串型协议.</p><p>4、uWSGI（web服务器   和nginx类似）</p><p>　　　　　　1. 什么是uWSGI： uWSGI是一个全功能的HTTP服务器，实现了WSGI协议、uwsgi协议、http协议等。</p><p>　　　　　　2. uWSGI作用：它要做的就是把HTTP协议转化成语言支持的网络协议，比如把HTTP协议转化成WSGI协议，让Python可以直接使用。</p><p>　　　　　　3. uWSGI特点：轻量级，易部署，性能比nginx差很多</p><p>　　　　　　注：</p><p>　　　　　　　　如果架构是Nginx+uWSGI+APP，uWSGI是一个中间件</p><p>　　　　　　　　如果架构是uWSGI+APP，uWSGI是一个服务器</p><p>5、Nginx</p><p>　　　　　　1. Nginx是一个Web服务器,其中的HTTP服务器功能和uWSGI功能很类似</p><p>　　　　　　2. 但是Nginx还可以用作更多用途，比如最常用的反向代理、负载均衡、拦截攻击等，而且性能极高</p><p>6、Django</p><p>　　　　　　1. Django是一个Web框架，框架的作用在于处理request和 reponse，其他的不是框架所关心的内容。</p><p>　　　　　　2. 所以如何部署Django不是Django所需要关心的。</p><h3 id="1-2-Django-Uwsgi-Nginx-部署的作用"><a href="#1-2-Django-Uwsgi-Nginx-部署的作用" class="headerlink" title="1.2 Django + Uwsgi + Nginx 部署的作用"></a>1.2 Django + Uwsgi + Nginx 部署的作用</h3><p>1、Django + Uwsgi + Nginx方案</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/1.png" alt="1"></p><p>1）请求处理整体流程　　　　　</p><p>　　　　　　　　nginx接收到浏览器发送过来的http请求，将包进行解析，分析url</p><p>　　　　　　　　静态文件请求：就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件</p><p>　　　　　　　　动态接口请求：那么nginx就将请求转发给uWSGI，最后到达django处理</p><p>2）各模块作用</p><p>　　　　　　　　1. nginx：是对外的服务器，外部浏览器通过url访问nginx，nginx主要处理静态请求</p><p>　　　　　　　　2. uWSGI：是对内的服务器，主要用来处理动态请求</p><p>　　　　　　　　3. uwsgi：是一种web协议，接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi</p><p>　　　　　　　　4. wsgi：是python专用的web协议，根据请求调用应用程序（django）的某个文件，某个文件的某个函数</p><p>　　　　　　　　5. django：是真正干活的，查询数据等资源，把处理的结果再次返回给WSGI， WSGI 将返回值进行打包，打包成uwsgi能够接收的格式</p><p>　　　　　　　　6. uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器</p><p>　　2、Django + uwsgi方案</p><p>　　　　　　1. 没有nginx而只有uwsgi的服务器，则是Internet请求直接由uwsgi处理，并反馈到web项目中。</p><p>　　　　　　2. nginx可以实现安全过滤，防DDOS等保护安全的操作，并且如果配置了多台服务器，nginx可以保证服务器的负载相对均衡。</p><p>　　　　　　3. 而uwsgi则是一个web服务器，实现了WSGI协议(Web Server Gateway Interface)，http协议等，它可以接收和处理请求，发出响应等。<br>　　　　　　    所以只用uwsgi也是可以的。</p><p>　　3、nginx和uWSGI特点</p><p>　　　　1）nginx的作用</p><p>　　　　　　　　1.反向代理，可以拦截一些web攻击，保护后端的web服务器</p><p>　　　　　　　　2.负载均衡，根据轮询算法，分配请求到多节点web服务器</p><p>　　　　　　　　3.缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</p><p>　　　　2）uWSGI的适用</p><p>　　　　　　　　1.单节点服务器的简易部署</p><p>　　　　　　　　2.轻量级，好部署</p><h3 id="1-3-Django-Uwsgi-Nginx-的生产环境部署"><a href="#1-3-Django-Uwsgi-Nginx-的生产环境部署" class="headerlink" title="1.3  Django + Uwsgi + Nginx 的生产环境部署"></a>1.3  Django + Uwsgi + Nginx 的生产环境部署</h3><p>1、在centos 7中安装python3环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#安装依赖</span><br><span class="line"># 1、yum更新yum源</span><br><span class="line">yum update</span><br><span class="line"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"># 3、在官网下载所需版本，这里用的是3.7.0版本</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;3.7.0&#x2F;Python-3.7.0.tgz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#安装pycharm</span><br><span class="line"># 1、yum更新yum源</span><br><span class="line">yum update</span><br><span class="line"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"># 3、在官网下载所需版本，这里用的是3.7.0版本</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;3.7.0&#x2F;Python-3.7.0.tgz</span><br><span class="line">　　2、安装Python</span><br><span class="line"></span><br><span class="line"># 1、解压</span><br><span class="line">tar -xvf Python-3.7.0.tgz</span><br><span class="line"></span><br><span class="line">#2、配置编译</span><br><span class="line">cd Python-3.7.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3  # 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span><br><span class="line">.&#x2F;configure --enable-optimizations  # 执行该代码后，会编译安装到 &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 下，且不用添加软连接或环境变量</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3  # 添加软连接</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3</span><br><span class="line"></span><br><span class="line">#3、将&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin加入PATH</span><br><span class="line">[root@linux-node1 testProj]# vim &#x2F;etc&#x2F;profile</span><br><span class="line">#然后在文件末尾添加</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin</span><br><span class="line"></span><br><span class="line">[root@linux-node1 testProj]# source &#x2F;etc&#x2F;profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span><br></pre></td></tr></table></figure><h3 id="2、初始化一个django项目"><a href="#2、初始化一个django项目" class="headerlink" title="2、初始化一个django项目"></a>2、初始化一个django项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#初始化一个django项目</span><br><span class="line">[root@linux-node1 &#x2F;]# pip3 install django&#x3D;&#x3D;2.0.4</span><br><span class="line">[root@linux-node1 &#x2F;]# mkdir &#x2F;code&#x2F;</span><br><span class="line">[root@linux-node1 &#x2F;]# cd &#x2F;code&#x2F;</span><br><span class="line">[root@linux-node1 testProj]# django-admin startproject mmcsite</span><br><span class="line">[root@linux-node1 testProj]# cd &#x2F;code&#x2F;mmcsite</span><br><span class="line">[root@linux-node1 testProj]# python3 manage.py runserver 0.0.0.0:8000</span><br><span class="line"># 页面中访问：http:&#x2F;&#x2F;192.168.56.11:8000&#x2F;</span><br></pre></td></tr></table></figure><h3 id="3、安装uwsgi-并使用uWSGI启动这个服务"><a href="#3、安装uwsgi-并使用uWSGI启动这个服务" class="headerlink" title="3、安装uwsgi 并使用uWSGI启动这个服务"></a>3、安装uwsgi 并使用uWSGI启动这个服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;&#39;1. 安装uwsgi&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;]# pip3 install uwsgi</span><br><span class="line">[root@linux-node1 &#x2F;]# ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;uwsgi &#x2F;usr&#x2F;bin&#x2F;uwsgi</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;2. 配置uwsgi.ini启动文件&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;]# vim uwsgi.ini</span><br><span class="line">[uwsgi]</span><br><span class="line">socket &#x3D; 0.0.0.0:3031</span><br><span class="line">chdir &#x3D; &#x2F;code&#x2F;mmcsite</span><br><span class="line">wsgi-file &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;wsgi.py</span><br><span class="line">processes &#x3D; 5</span><br><span class="line">threads &#x3D; 30</span><br><span class="line">master &#x3D; true</span><br><span class="line">daemonize &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;uwsgi.log</span><br><span class="line">module&#x3D;mmcsite.wsgi</span><br><span class="line">pidfile &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;uwsgi.pid</span><br><span class="line">chmod-socket&#x3D;666</span><br><span class="line">enable-threads &#x3D; true</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;3. 使用uwsgi启动django：一定要在这个项目目录中&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;]# uwsgi --http 192.168.56.11:80 --file mmcsite&#x2F;wsgi.py --static-map&#x3D;&#x2F;static&#x3D;static</span><br><span class="line">访问项目：http:&#x2F;&#x2F;192.168.56.11</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@linux-node2 demo2]# vim &#x2F;code&#x2F;mmcsite&#x2F;uwsgi.ini  # uwsgi.ini文件</span><br><span class="line">[uwsgi]</span><br><span class="line">socket &#x3D; 0.0.0.0:3031                  # 指定socket监听的地址和端口</span><br><span class="line">chdir &#x3D; &#x2F;code&#x2F;mmcsite                  # 项目路径 </span><br><span class="line">wsgi-file &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;wsgi.py      # django的wsgi文件路径</span><br><span class="line">processes &#x3D; 5                          # 启动五个进程</span><br><span class="line">threads &#x3D; 30                           # 每个进程启动30个线程</span><br><span class="line">master &#x3D; true</span><br><span class="line">daemonize &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;uwsgi.log    # 日志存放路径</span><br><span class="line">module&#x3D;mmcsite.wsgi                    # 使用mmcsite.wsgi模块</span><br><span class="line">pidfile &#x3D; &#x2F;code&#x2F;mmcsite&#x2F;uwsgi.pid      # uwsgi启动进程id存放路径</span><br><span class="line">chmod-socket&#x3D;666                       # socket权限</span><br><span class="line">enable-threads &#x3D; true                  # 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程</span><br></pre></td></tr></table></figure><h3 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#安装nginx</span><br><span class="line">&#39;&#39;&#39;1. 配置nginx YUM源&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;] vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo</span><br></pre></td></tr></table></figure><p>[nginx]<br>name=nginx repo</p><h1 id="下面这行centos根据你自己的操作系统修改比如：OS-rehel"><a href="#下面这行centos根据你自己的操作系统修改比如：OS-rehel" class="headerlink" title="下面这行centos根据你自己的操作系统修改比如：OS/rehel"></a>下面这行centos根据你自己的操作系统修改比如：OS/rehel</h1><h1 id="6是你Linux系统的版本，可以通过URL查看路径是否正确"><a href="#6是你Linux系统的版本，可以通过URL查看路径是否正确" class="headerlink" title="6是你Linux系统的版本，可以通过URL查看路径是否正确"></a>6是你Linux系统的版本，可以通过URL查看路径是否正确</h1><p>baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a><br>gpgcheck=0<br>enabled=1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;&#39;2. 安装nginx&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;] yum -y install nginx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#配置nginx</span><br><span class="line">[root@linux-node1 &#x2F;]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;django.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888;</span><br><span class="line">    server_name  192.168.56.11;</span><br><span class="line">    client_max_body_size 5M;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_buffers 32 4K;#压缩在内存中缓冲32块 每块4K</span><br><span class="line">    gzip_comp_level 6 ;#压缩级别 推荐6</span><br><span class="line">    gzip_min_length 4000;#开始压缩的最小长度4bit</span><br><span class="line">        gzip_types text&#x2F;plain application&#x2F;json application&#x2F;javascript application&#x2F;x-javascript application&#x2F;css application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png image&#x2F;x-ms-bmp;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">              include uwsgi_params;</span><br><span class="line">              uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">              uwsgi_ignore_client_abort on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linux-node1 demo2]# systemctl restart nginx   # 开启nginx</span><br><span class="line">[root@linux-node1 demo2]# uwsgi --ini uwsgi.ini     # 启动uwsgi的django项目</span><br><span class="line"># http:&#x2F;&#x2F;192.168.56.11:8888&#x2F; 访问项目</span><br><span class="line">[root@linux-node1 demo2]# uwsgi --stop uwsgi.pid    # 关闭uwsgi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法</title>
      <link href="/2020/05/09/Blog/twelve/"/>
      <url>/2020/05/09/Blog/twelve/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="推荐算法："><a href="#推荐算法：" class="headerlink" title="推荐算法："></a>推荐算法：</h4><p>​        推荐算法是<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>专业中的一种算法，通过一些数学算法，推测出用户可能喜欢的东西，目前应用推荐算法比较好的地方主要是网络，其中淘宝做的比较好。</p><h4 id="发展背景："><a href="#发展背景：" class="headerlink" title="发展背景："></a>发展背景：</h4><p>​        推荐算法的研究起源于20世纪90年代，由美国明尼苏达大学 GroupLens研究小组最先开始研究，他们想要制作一个名为 Movielens的电影推荐系统，从而实现对用户进行电影的个性化推荐。首先研究小组让用户对自己看过的电影进行评分，然后小组对用户评价的结果进行分析，并预测出用户对并未看过的电影的兴趣度，从而向他们推荐从未看过并可能感兴趣的电影。此后， Amazon开始在网站上使用推荐系统，在实际中对用户的浏览购买行为进行分析，尝试对曾经浏览或购买商品的用户进行个性化推荐。根据 enture Beat的统计，这一举措将该网站的销售额提高了35%自此之后，个性化推荐的应用越来越广泛。</p><h4 id="推荐算法分类："><a href="#推荐算法分类：" class="headerlink" title="推荐算法分类："></a>推荐算法分类：</h4><p><strong>基于内容</strong>：项目或对象是通过相关特征的属性来定义的，系统基于用户评价对象的特征、学习用户的兴趣，考察用户资料与待预测项目的匹配程度。用户的资料模型取决于所用的学习方法，常用的有决策树、神经网络和基于向量的表示方法等。基于内容的用户资料需要有用户的历史数据，用户资料模型可能随着用户的偏好改变而发生变化。</p><p><strong>基于协同</strong>：基于协同过滤的推荐算法( Collaborative Filtering Recommendation)技术是推荐系统中应用最早和最为成功的技术之一。它一般采用最近邻技术，利用用户的历史喜好信息计算用户之间的距离，然后利用目标用户的最近邻居用户对商品评价的加权评价值来预测目标用户对特定商品的喜好程度，从而根据这一喜好程度来对目标用户进行推荐。</p><p><strong>基于关联规则</strong>：以关联规则为基础，把已购商品作为规则头，规则体为推荐对象。关联规则就是在一个交易数据库中统计购买了商品集X的交易中有多大比例的交易同时购买了商品集y，其直观的意义就是用户在购买某些商品的时候有多大倾向去购买另外一些商品。比如购买牛奶的同时很多人会购买面包。</p><p><strong>基于效用</strong>：基于效用的推荐（Utility-based Recommendation）是建立在对用户使用项目的效用情况上计算的，其核心问题是怎样为每一个用户去创建一个效用函数，因此，用户资料模型很大程度上是由系统所采用的效用函数决定的。</p><p><strong>基于知识</strong>：基于知识的方法因它们所用的功能知识不同而有明显区别。效用知识( FunctionalKnowledge)是一种关于一个项目如何满足某一特定用户的知识，因此能解释需要和推荐的关系，所以用户资料可以是任何能支持推理的知识结构，它可以是用户已经规范化的查询，也可以是一个更详细的用户需要的表示。</p><p><strong>组合推荐</strong>：由于各种推荐方法都有优缺点，所以在实际中，组合推荐( Hybrid Recommendation)经常被采用。研究和应用最多的是内容推荐和协同过滤推荐的组合。</p><table><thead><tr><th>推荐方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>基于内容推荐</td><td>推荐结果直观，容易解释；不需要领域知识</td><td>新用户问题；复杂属性不好处理；要有足够数据构造分类器</td></tr><tr><td>协同过滤推荐</td><td>新异兴趣发现、不需要领域知识；随着时间推移性能提高；推荐个性化、自动化程度高；能处理复杂的非结构化对象</td><td>稀疏问题；可扩展性问题；新用户问题；质量取决于历史数据集；系统开始时推荐质量差；</td></tr><tr><td>基于规则推荐</td><td>能发现新兴趣点；不要领域知识</td><td>规则抽取难、耗时；产品名同义性问题；个性化程度低；</td></tr><tr><td>基于效用推荐</td><td>无冷开始和稀疏问题；对用户偏好变化敏感；能考虑非产品特性</td><td>用户必须输入效用函数；推荐是静态的，灵活性差；属性重叠问题；</td></tr><tr><td>基于知识推荐</td><td>能把用户需求映射到产品上；能考虑非产品属性</td><td>知识难获得；推荐是静态的</td></tr></tbody></table><h4 id="协同过滤推荐："><a href="#协同过滤推荐：" class="headerlink" title="协同过滤推荐："></a>协同过滤推荐：</h4><p><strong>1.启发式推荐算法（Memory-based algorithms）</strong></p><p>启发式推荐算法易于实现，并且推荐结果的可解释性强。启发式推荐算法又可以分为两类：</p><p>基于用户的协同过滤（User-based collaborative filtering）：主要考虑的是用户和用户之间的相似度，只要找出相似用户喜欢的物品，并预测目标用户对对应物品的评分，就可以找到评分最高的若干个物品推荐给用户。举个例子，李老师和闫老师拥有相似的电影喜好，当新电影上映后，李老师对其表示喜欢，那么就能将这部电影推荐给闫老师。</p><p>基于物品的协同过滤（Item-based collaborative filtering）：主要考虑的是物品和物品之间的相似度，只有找到了目标用户对某些物品的评分，那么就可以对相似度高的类似物品进行预测，将评分最高的若干个相似物品推荐给用户。举个例子，如果用户A、B、C给书籍X,Y的评分都是5分，当用户D想要买Y书籍的时候，系统会为他推荐X书籍，因为基于用户A、B、C的评分，系统会认为喜欢Y书籍的人在很大程度上会喜欢X书籍。</p><p><strong>2.基于模型的推荐算法（Model-based algorithms）</strong></p><p>基于模型的推荐算法利用矩阵分解，有效的缓解了数据稀疏性的问题。矩阵分解是一种降低维度的方法，对特征进行提取，提高推荐准确度。基于模型的方法包括<a href="">决策树</a>、基于规则的模型、贝叶斯方法和潜在因素模型。</p><p>推荐框架:tensorflow,pytorch</p><h4 id="推荐系统的目的："><a href="#推荐系统的目的：" class="headerlink" title="推荐系统的目的："></a>推荐系统的目的：</h4><p>1.帮助用户快速找到想要的商品，提高用户对网站的忠诚度；</p><p>2.提高网站交叉销售能力、成交转化率；</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>首先，找到User1 喜欢的商品；</p><p>找出与User1具有相同的商品兴趣爱好的人群；</p><p>找出该人群喜欢的其他商品；</p><p>将这些商品推送给User1。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>两名用户都在某电商网站购买了A、B两种产品。当他们产生购买这个动作的时候，两名用户之间的相似度便被计算了出来。其中一名用户除了购买了产品A和B，还购买了C产品，此时推荐系统会根据两名用户之间的相似度会为另一名用户推荐项目C。</p><h4 id="难点1：如何获取兴趣相似的用户"><a href="#难点1：如何获取兴趣相似的用户" class="headerlink" title="难点1：如何获取兴趣相似的用户"></a>难点1：如何获取兴趣相似的用户</h4><p>思路：通过购买过相同商品为介质，关联用户的关系</p><h4 id="难点2：计算相似度"><a href="#难点2：计算相似度" class="headerlink" title="难点2：计算相似度"></a>难点2：计算相似度</h4><p>欧氏距离计算（计算两个点之间的直线距离）<br>$$<br>|x| = \sqrt{ (x_1^2 + x_2^2 + … + x_n^2)}<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 计算两点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eucliDist</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(sum([(a - b)**<span class="number">2</span> <span class="keyword">for</span> (a,b) <span class="keyword">in</span> zip(A,B)]))</span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Y = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(eucliDist(X,Y))</span><br></pre></td></tr></table></figure><h4 id="难点3：如何将算法落地，实现推荐功能"><a href="#难点3：如何将算法落地，实现推荐功能" class="headerlink" title="难点3：如何将算法落地，实现推荐功能"></a>难点3：如何将算法落地，实现推荐功能</h4><p>根据用户的购买/收藏关系推荐商品</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">"1"</span>:&#123;<span class="string">"诺基亚"</span>:<span class="number">4.8</span>,<span class="string">'iphone'</span>:<span class="number">5.0</span>,<span class="string">"联想"</span>:<span class="number">0.1</span>&#125;,</span><br><span class="line">    <span class="string">"2"</span>:&#123;<span class="string">"诺基亚"</span>:<span class="number">3.0</span>,<span class="string">"vivo"</span>:<span class="number">5.0</span>,<span class="string">"htc"</span>:<span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">"3"</span>:&#123;<span class="string">"锤子"</span>:<span class="number">0.1</span>,<span class="string">"魅族"</span>:<span class="number">0.3</span>,<span class="string">"一加"</span>:<span class="number">5.0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#| x | = √(x[1]2 + x[2]2 + … + x[n]2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#pow返回 xy（x的y次方） 的值</span></span><br><span class="line"><span class="comment">#sqrt返回数字x的平方根</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算用户之间的相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Euclid</span><span class="params">(user1,user2)</span>:</span></span><br><span class="line">    <span class="comment">#根据key获取value</span></span><br><span class="line">    user1_data = data[user1]</span><br><span class="line">    user2_data = data[user2]</span><br><span class="line">    distance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> user1_data.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> user2_data.keys():</span><br><span class="line">            distance += pow(float(user1_data[key]) - float(user2_data[key]),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#变成小数便于比较，值越小相似度越高</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+sqrt(distance))</span><br><span class="line"></span><br><span class="line">print(Euclid(<span class="string">"1"</span>,<span class="string">"2"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建最相似的用户top_people</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_user</span><span class="params">(user)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> uid <span class="keyword">in</span> data.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> uid == user:</span><br><span class="line">            simliar = Euclid(user,uid)</span><br><span class="line">            res.append((uid,simliar))</span><br><span class="line"></span><br><span class="line">    res.sort(key=<span class="keyword">lambda</span> val:val[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(top_user(<span class="string">'1'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建推荐商品</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend</span><span class="params">(user)</span>:</span></span><br><span class="line">    top_people = top_user(user)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取当前相似度最高的用户的商品列表</span></span><br><span class="line">    items = data[top_people]</span><br><span class="line"></span><br><span class="line">    recommed_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items.keys():</span><br><span class="line">        <span class="comment">#当这个商品不存在于目标用户的商品列表中，添加到推荐列表中</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span>  <span class="keyword">in</span> data[user].keys():</span><br><span class="line">            recommed_list.append((item,items[item]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#根据推荐列表里的打分请款从小到大排序，然后反转</span></span><br><span class="line">    recommed_list.sort(key=<span class="keyword">lambda</span> val:val[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#取出top10推荐</span></span><br><span class="line">    <span class="keyword">return</span> recommed_list[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">print(recommend(<span class="string">"1"</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2020/05/08/Blog/eleven/"/>
      <url>/2020/05/08/Blog/eleven/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="超卖解决方案？"><a href="#超卖解决方案？" class="headerlink" title="超卖解决方案？"></a>超卖解决方案？</h3><p>1、mysql悲观锁：select_for_updata()</p><p>2、mysql乐观锁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">While Ture:</span><br><span class="line">  <span class="comment">#查询</span></span><br><span class="line">  </span><br><span class="line"> 。。。</span><br><span class="line"></span><br><span class="line">User.object.filter(原来的条件).updata(现在的条件)</span><br></pre></td></tr></table></figure><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p><strong>什么是分布式锁？</strong></p><p>​        分布式锁是控制分布式系统之间同步访问共享资源的一种方式。</p><p><strong>什么实用分布式锁？</strong></p><p>​        为了保证共享资源的数据一致性。</p><p><strong>什么场景下使用分布式锁？</strong></p><p>​        数据重要且要保证一致性</p><h3 id="如何实现分布式锁？"><a href="#如何实现分布式锁？" class="headerlink" title="如何实现分布式锁？"></a><strong>如何实现分布式锁？</strong></h3><p>​    主要介绍使用redis来实现分布式锁</p><p>​    </p><h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h2><h1 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h1><h3 id="redis事务介绍："><a href="#redis事务介绍：" class="headerlink" title="redis事务介绍："></a>redis事务介绍：</h3><p>​        1.redis事务可以一次执行多个命令，本质是一组命令的集合。</p><p>​        2.一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入</p><p>​        <strong>作用：</strong>一个队列中，一次性、顺序性、排他性的执行一系列命令 </p><h3 id="multi指令的使用"><a href="#multi指令的使用" class="headerlink" title="multi指令的使用"></a>multi指令的使用</h3><p>  　　1. 下面指令演示了一个完整的事物过程，所有指令在exec前不执行，而是缓存在服务器的一个事物队列中</p><p>  　　2. 服务器一旦收到exec指令才开始执行事物队列，执行完毕后一次性返回所有结果</p><p>  　　3. 因为redis是单线程的，所以不必担心自己在执行队列是被打断，可以保证这样的“原子性”</p><p>　　注：redis事物在遇到指令失败后，后面的指令会继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Multi 命令用于标记一个事务块的开始事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性( atomic )地执行</span></span><br><span class="line">&gt; multi（开始一个redis事物）</span><br><span class="line">incr books</span><br><span class="line">incr books</span><br><span class="line">&gt; <span class="keyword">exec</span> （执行事物）</span><br><span class="line">&gt; discard （丢弃事物）</span><br></pre></td></tr></table></figure><p><strong>注：mysql的rollback与redis的discard的区别</strong></p><p>   　　　1. mysql回滚为sql全部成功才执行,一条sql失败则全部失败,执行rollback后所有语句造成的影响消失</p><p>   　　　2. redis的discard只是结束本次事务,正确命令造成的影响仍然还在.</p><p>　　　　　1）redis如果在一个事务中的<strong>命令出现错误</strong>，那么<strong>所有的命令都不会执行</strong>；<br>　　　　　2）redis如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令会被执行</strong>。</p><h3 id="watch-指令作用"><a href="#watch-指令作用" class="headerlink" title="watch 指令作用"></a><strong>watch 指令作用</strong></h3><p>　　　实质：WATCH 只会在数据被其他客户端抢先修改了的情况下通知执行命令的这个客户端（通过 WatchError 异常）但不会阻止其他客户端对数据的修改</p><p>   　　　1. <strong>watch其实就是redis提供的一种乐观锁，可以解决并发修改问题</strong></p><p>   　　　2. watch会在事物开始前盯住一个或多个关键变量，当服务器收到exec指令要顺序执行缓存中的事物队列时，redis会检查关键变量自watch后是否被修改</p><p>   　　　3. WATCH 只会在数据被其他客户端抢先修改了的情况下通知执行命令的这个客户端（通过 WatchError 异常）但不会阻止其他客户端对数据的修改</p><h3 id="setnx指令（redis的分布式锁）"><a href="#setnx指令（redis的分布式锁）" class="headerlink" title="setnx指令（redis的分布式锁）"></a>setnx指令（redis的分布式锁）</h3><p>　　<strong>1、分布式锁</strong></p><p>   　　　　1. 分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试</p><pre><code>2. 占坑一般使用 setnx(set if not exists)指令，只允许一个客户端占坑      　　　　3. 先来先占，用完了在调用del指令释放坑</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">.... do something critical ....</span><br><span class="line">&gt; <span class="keyword">del</span> lock:codehole</span><br></pre></td></tr></table></figure><p>​                4. 但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放</p><p>   　　　　5. 为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">&gt; expire lock:codehole <span class="number">5</span></span><br><span class="line">.... do something critical ....</span><br><span class="line">&gt; <span class="keyword">del</span> lock:codehole</span><br></pre></td></tr></table></figure><p>​               6. 这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁</p><p>   　　　　7. 为了治理上面乱象，在redis 2.8中加入了set指令的扩展参数，使setnx和expire指令可以一起执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; set lock:codehole true ex <span class="number">5</span> nx</span><br><span class="line"><span class="string">''' do something '''</span></span><br><span class="line">&gt; <span class="keyword">del</span> lock:codehole</span><br></pre></td></tr></table></figure><h3 id="redis解决超卖问题"><a href="#redis解决超卖问题" class="headerlink" title="redis解决超卖问题"></a>redis解决超卖问题</h3><p><strong>1、使用reids的 watch + multi 指令实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale</span><span class="params">(rs)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">with</span> rs.pipeline() <span class="keyword">as</span> p:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p.watch(<span class="string">'apple'</span>)                   <span class="comment"># 监听key值为apple的数据数量改变</span></span><br><span class="line">                count = int(rs.get(<span class="string">'apple'</span>))</span><br><span class="line">                print(<span class="string">'拿取到了苹果的数量: %d'</span> % count)</span><br><span class="line">                p.multi()                          <span class="comment"># 事务开始</span></span><br><span class="line">                <span class="keyword">if</span> count&gt; <span class="number">0</span> :                      <span class="comment"># 如果此时还有库存</span></span><br><span class="line">                    p.set(<span class="string">'apple'</span>, count - <span class="number">1</span>)</span><br><span class="line">                    p.execute()                    <span class="comment"># 执行事务</span></span><br><span class="line">                p.unwatch()</span><br><span class="line">                <span class="keyword">break</span>                              <span class="comment"># 当库存成功减一或没有库存时跳出执行循环</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:                 <span class="comment"># 当出现watch监听值出现修改时，WatchError异常抛出</span></span><br><span class="line">                print(<span class="string">'[Error]: %s'</span> % e)</span><br><span class="line">                <span class="keyword">continue</span>                           <span class="comment"># 继续尝试执行</span></span><br><span class="line"></span><br><span class="line">rs = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)      <span class="comment"># 连接redis</span></span><br><span class="line">rs.set(<span class="string">'apple'</span>,<span class="number">1000</span>)                               <span class="comment"># # 首先在redis中设置某商品apple 对应数量value值为1000</span></span><br><span class="line">sale(rs)</span><br></pre></td></tr></table></figure><p><strong>1）原理</strong></p><p>  　　1. 当用户购买时，通过 WATCH 监听用户库存，如果库存在watch监听后发生改变，就会捕获异常而放弃对库存减一操作</p><p>  　　2. 如果库存没有监听到变化并且数量大于1，则库存数量减一，并执行任务</p><p>  <strong>2）弊端</strong></p><p>  　　1. Redis 在尝试完成一个事务的时候，可能会因为事务的失败而重复尝试重新执行</p><p>  　　2. 保证商品的库存量正确是一件很重要的事情，但是单纯的使用 WATCH 这样的机制对服务器压力过大</p><p><strong>2、使用reids的 watch + multi + setnx 指令实现</strong></p><p>　　<strong>1）为什么要自己构建锁</strong></p><ol><li><p>然有类似的 SETNX 命令可以实现 Redis 中的锁的功能，但他锁提供的机制并不完整</p><p>. 并且setnx也不具备分布式锁的一些高级特性，还是得通过我们手动构建</p></li></ol><p>　　<strong>2）创建一个redis锁</strong></p><ol><li><p>在 Redis 中，可以通过使用 SETNX 命令来构建锁：<strong>rs.setnx(lock_name, uuid值)</strong></p><p>. 而锁要做的事情就是将一个随机生成的 128 位 UUID 设置位键的值，防止该锁被其他进程获取</p></li></ol><p>　　<strong>3）释放锁</strong></p><ol><li><p>锁的删除操作很简单，只需要将对应锁的 key 值获取到的 uuid 结果进行判断验证</p><p>. 符合条件（<em>判断uuid值</em>）通过 delete 在 redis 中删除即可，pipe.delete(lockname)</p></li></ol><p>　　　　　<em>3. 此外当其他用户持有同名锁时，由于 uuid 的不同，经过验证后不会错误释放掉别人的锁</em></p><p> 　<strong>4）解决锁无法释放问题</strong></p><p>   　　　　　1. 在之前的锁中，还出现这样的问题，比如某个进程持有锁之后突然程序崩溃，那么会导致锁无法释放</p><p>　　　　　<em>2. 而其他进程无法持有锁继续工作，为了解决这样的问题，可以在获取锁的时候加上锁的超时功能</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.初始化连接函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conn</span><span class="params">(host=<span class="string">"127.0.0.1"</span>,port=<span class="number">6379</span>)</span>:</span></span><br><span class="line">    rs = redis.Redis(host=host, port=port)</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 构建redis锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(rs, lock_name, expire_time=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rs: 连接对象</span></span><br><span class="line"><span class="string">    lock_name: 锁标识</span></span><br><span class="line"><span class="string">    acquire_time: 过期超时时间</span></span><br><span class="line"><span class="string">    return -&gt; False 获锁失败 or True 获锁成功</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    identifier = str(uuid.uuid4())</span><br><span class="line">    end = time.time() + expire_time</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False</span></span><br><span class="line">        <span class="keyword">if</span> rs.setnx(lock_name, identifier): <span class="comment"># 尝试取得锁</span></span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        <span class="comment"># time.sleep(.001)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_lock</span><span class="params">(rs, lockname, identifier)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rs: 连接对象</span></span><br><span class="line"><span class="string">    lockname: 锁标识</span></span><br><span class="line"><span class="string">    identifier: 锁的value值，用来校验</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rs.get(lockname).decode() == identifier:  <span class="comment"># 防止其他进程同名锁被误删</span></span><br><span class="line">        rs.delete(lockname)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>            <span class="comment"># 删除锁</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>           <span class="comment"># 删除失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有过期时间的锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_expire_lock</span><span class="params">(rs, lock_name, expire_time=<span class="number">10</span>, locked_time=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rs: 连接对象</span></span><br><span class="line"><span class="string">    lock_name: 锁标识</span></span><br><span class="line"><span class="string">    acquire_time: 过期超时时间</span></span><br><span class="line"><span class="string">    locked_time: 锁的有效时间</span></span><br><span class="line"><span class="string">    return -&gt; False 获锁失败 or True 获锁成功</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    identifier = str(uuid.uuid4())</span><br><span class="line">    end = time.time() + expire_time</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False</span></span><br><span class="line">        <span class="keyword">if</span> rs.setnx(lock_name, identifier): <span class="comment"># 尝试取得锁</span></span><br><span class="line">            <span class="comment"># print('锁已设置: %s' % identifier)</span></span><br><span class="line">            rs.expire(lock_name, locked_time)</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''在业务函数中使用上面的锁'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale</span><span class="params">(rs)</span>:</span></span><br><span class="line">    start = time.time()            <span class="comment"># 程序启动时间</span></span><br><span class="line">    <span class="keyword">with</span> rs.pipeline() <span class="keyword">as</span> p:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        通过管道方式进行连接</span></span><br><span class="line"><span class="string">        多条命令执行结束，一次性获取结果</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            lock = acquire_lock(rs, <span class="string">'lock'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lock: <span class="comment"># 持锁失败</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#开始监测"lock"</span></span><br><span class="line">            p.watch(<span class="string">"lock"</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#开启事务</span></span><br><span class="line">                p.multi()</span><br><span class="line">                count = int(rs.get(<span class="string">'apple'</span>)) <span class="comment"># 取量</span></span><br><span class="line">                p.set(<span class="string">'apple'</span>, count<span class="number">-1</span>)      <span class="comment"># 减量</span></span><br><span class="line">                <span class="comment"># time.sleep(5)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">#提交事务</span></span><br><span class="line">                p.execute()</span><br><span class="line">                print(<span class="string">'当前库存量: %s'</span> % count)</span><br><span class="line">                <span class="comment">#成功则跳出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment">#事务失败对应处理</span></span><br><span class="line">                print(<span class="string">"修改数据失败"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#无论成功与否最终都需要释放锁</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">                res = release_lock(rs, <span class="string">'lock'</span>, lock)</span><br><span class="line">                <span class="comment">#释放锁成功，</span></span><br><span class="line">                <span class="keyword">if</span> res:</span><br><span class="line">                    print(<span class="string">"删除锁成功"</span>)</span><br><span class="line">                <span class="comment">#释放锁失败，强制删除</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"删除锁失败,强制删除锁"</span>)</span><br><span class="line">                    res = rs.delete(<span class="string">'lock'</span>)</span><br><span class="line">                    print(res)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'[time]: %.2f'</span> % (time.time() - start))</span><br><span class="line"></span><br><span class="line">rs = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)      <span class="comment"># 连接redis</span></span><br><span class="line"><span class="comment"># rs.set('apple',1000)                             # # 首先在redis中设置某商品apple 对应数量value值为1000</span></span><br><span class="line">sale(rs)</span><br></pre></td></tr></table></figure><p>优化锁无法释放的问题，为锁添加过期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_expire_lock</span><span class="params">(rs, lock_name, expire_time=<span class="number">10</span>, locked_time=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    rs: 连接对象</span></span><br><span class="line"><span class="string">    lock_name: 锁标识</span></span><br><span class="line"><span class="string">    acquire_time: 过期超时时间</span></span><br><span class="line"><span class="string">    locked_time: 锁的有效时间</span></span><br><span class="line"><span class="string">    return -&gt; False 获锁失败 or True 获锁成功</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    identifier = str(uuid.uuid4())</span><br><span class="line">    end = time.time() + expire_time</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="comment"># 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False</span></span><br><span class="line">        <span class="keyword">if</span> rs.setnx(lock_name, identifier): <span class="comment"># 尝试取得锁</span></span><br><span class="line">            <span class="comment"># print('锁已设置: %s' % identifier)</span></span><br><span class="line">            rs.expire(lock_name, locked_time)</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="关于分布式锁"><a href="#关于分布式锁" class="headerlink" title="关于分布式锁"></a>关于分布式锁</h2><p>Watch：监测一个key。如果这个key的value改变，那个接下来的事务操作全部失效</p><p>multi:    开启一个事务。</p><p>Setnx:   跟set一样都往redis添加一个key。不一定的地方在于：set的时候如果这个值存在，就是修改操作。不存在就是添加操作。setnx：存在的时候不能再次添加，不存在的时候才能添加。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之列表(list)</title>
      <link href="/2020/05/07/Note/list/"/>
      <url>/2020/05/07/Note/list/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li>append用于在列表末尾追加新的对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">a.append(4)                          #the result ： [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>count方法统计某个元素在列表中出现的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;,&#39;aa&#39;,&#39;aa&#39;]</span><br><span class="line">print(a.count(&#39;aa&#39;))                 #the result ： 3</span><br></pre></td></tr></table></figure></li><li><p>extend方法可以在列表的末尾一次性追加另一个序列中的多个值</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">b &#x3D; [4,5,6]</span><br><span class="line">a.extend(b)                          #the result ：[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><ol start="4"><li><p>index函数用于从列表中找出某个值第一个匹配项的索引位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3,1]</span><br><span class="line">print(a.index(1))                   #the result ： 0</span><br></pre></td></tr></table></figure></li><li><p>insert方法用于将对象插入到列表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">a.insert(0,&#39;aa&#39;)            #the result : [&#39;aa&#39;, 1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p>pop方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,3]</span><br><span class="line">a.pop()                             #the result ： [1, 2]</span><br><span class="line">a.pop(0)</span><br></pre></td></tr></table></figure></li><li><p>remove方法用于移除列表中某个值的第一个匹配项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;,&#39;aa&#39;]</span><br><span class="line">a.remove(&#39;aa&#39;)                      #the result ： [&#39;bb&#39;, &#39;cc&#39;, &#39;aa&#39;]</span><br></pre></td></tr></table></figure></li><li><p>reverse方法将列表中的元素反向存放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span><br><span class="line">a.reverse()                         #the result ： [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]</span><br></pre></td></tr></table></figure></li><li><p>sort方法用于在原位置对列表进行排序，意味着改变原来的列表，让其中的元素按一定顺序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,1,2,3]</span><br><span class="line">a.sort()                           #the result ：[1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure></li><li><p>enumrate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li &#x3D; [11,22,33]</span><br><span class="line">for k,v in enumerate(li, 1):</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webshell</title>
      <link href="/2020/05/07/Blog/ten/"/>
      <url>/2020/05/07/Blog/ten/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h4><p>“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为通过网站端口对网站服务器的某种程度上操作的权限。</p><p>一方面，webshell被站长常常用于网站管理、<a href="https://baike.baidu.com/item/服务器管理" target="_blank" rel="noopener">服务器管理</a>等等，根据<a href="https://baike.baidu.com/item/FSO权限" target="_blank" rel="noopener">FSO权限</a>的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。</p><p>另一方面，被入侵者利用，从而达到控制网站服务器的目的。这些<a href="https://baike.baidu.com/item/网页脚本" target="_blank" rel="noopener">网页脚本</a>常称为WEB脚本木马，比较流行的<a href="https://baike.baidu.com/item/asp" target="_blank" rel="noopener">asp</a>或<a href="https://baike.baidu.com/item/php" target="_blank" rel="noopener">php</a>木马，也有基于<a href="https://baike.baidu.com/item/.NET" target="_blank" rel="noopener">.NET</a>的脚本木马与JSP脚本木马。国内常用的WebShell有海阳ASP木马，Phpspy，c99shell等。</p><p><code>web</code>端使用<code>Xterm.js</code>或者其他的<code>WebShell</code>组件和<code>websocket</code></p><p>后端只需要支持<code>WebSocket</code>和<code>SSH</code>协议的远程登录模块即可</p><h4 id="web端实现"><a href="#web端实现" class="headerlink" title="web端实现"></a>web端实现</h4><p>1.安装</p><p><code>npm install xterm@3.1.0 --save</code>  指定版本安装，最新版的xterm文件的改动很大，使用下面的方法会报错</p><p>2.导包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'xterm/dist/xterm.css'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Terminal &#125; <span class="keyword">from</span> <span class="string">'xterm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局组件 可以不用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fit <span class="keyword">from</span> <span class="string">'xterm/lib/addons/fit/fit'</span>;</span><br><span class="line">Terminal.applyAddon(fit);</span><br></pre></td></tr></table></figure><p>3.在页面中的显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div id=<span class="string">"terminal"</span> style=<span class="string">"width: 500px;height:300px;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><p>4.数据操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//实例化一个websocket，用于和django江湖</span></span><br><span class="line">      <span class="keyword">this</span>.terminalSocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8000/web/"</span>);</span><br><span class="line">      <span class="comment">//获取到后端传回的信息</span></span><br><span class="line">      <span class="keyword">this</span>.terminalSocket.onmessage = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res.data);</span><br><span class="line">          <span class="comment">// var message = JSON.parse(res.data);</span></span><br><span class="line">          <span class="comment">//将传回来的数据显示在xterm里</span></span><br><span class="line">          <span class="keyword">this</span>.term.writeln(<span class="string">"\r\n"</span>+res.data);</span><br><span class="line">          <span class="comment">//重置要发送的信息</span></span><br><span class="line">          <span class="keyword">this</span>.order = <span class="string">""</span></span><br><span class="line">          <span class="comment">//换行，显示下一个开头</span></span><br><span class="line">          <span class="keyword">this</span>.term.write(<span class="string">"\r\n$ "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//ws连接的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onopen = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('websocket is Connected...')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//ws关闭的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onclose = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('websocket is Closed...')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//ws错误的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onerror = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('damn Websocket is broken!')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// this.term.attach(this.terminalSocket)</span></span><br><span class="line">    <span class="comment">// 绑定xterm到ws流中 &#125;,</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> terminalContainer = <span class="built_in">document</span>.getElementById(<span class="string">'terminal'</span>)</span><br><span class="line">      <span class="comment">//创建xterm实例</span></span><br><span class="line">      <span class="keyword">this</span>.term = <span class="keyword">new</span> Terminal(&#123;</span><br><span class="line">        cursorBlink: <span class="literal">true</span>, <span class="comment">// 显示光标</span></span><br><span class="line">        cursorStyle: <span class="string">"underline"</span> <span class="comment">// 光标样式</span></span><br><span class="line">        &#125;)                     <span class="comment">// 创建一个新的Terminal对象</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.term.open(terminalContainer)              <span class="comment">// 将term挂载到dom节点上</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>5.web端完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"console"</span> id=<span class="string">"terminal"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; Terminal &#125; <span class="keyword">from</span> <span class="string">'xterm'</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> attach <span class="keyword">from</span> <span class="string">'xterm/lib/addons/attach/attach'</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> fit <span class="keyword">from</span> <span class="string">'xterm/lib/addons/fit/fit'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'webssh'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        </span><br><span class="line">        term: <span class="literal">null</span>,</span><br><span class="line">        terminalSocket: <span class="literal">null</span>,</span><br><span class="line">        order:<span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//实例化一个websocket，用于和django江湖</span></span><br><span class="line">      <span class="keyword">this</span>.terminalSocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8000/web/"</span>);</span><br><span class="line">      <span class="comment">//获取到后端传回的信息</span></span><br><span class="line">      <span class="keyword">this</span>.terminalSocket.onmessage = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res.data);</span><br><span class="line">          <span class="comment">// var message = JSON.parse(res.data);</span></span><br><span class="line">          <span class="comment">//将传回来的数据显示在xterm里</span></span><br><span class="line">          <span class="keyword">this</span>.term.writeln(<span class="string">"\r\n"</span>+res.data);</span><br><span class="line">          <span class="comment">//重置要发送的信息</span></span><br><span class="line">          <span class="keyword">this</span>.order = <span class="string">""</span></span><br><span class="line">          <span class="comment">//换行，显示下一个开头</span></span><br><span class="line">          <span class="keyword">this</span>.term.write(<span class="string">"\r\n$ "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//ws连接的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onopen = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('websocket is Connected...')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//ws关闭的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onclose = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('websocket is Closed...')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//ws错误的时候</span></span><br><span class="line">    <span class="comment">// this.terminalSocket.onerror = function()&#123;</span></span><br><span class="line">    <span class="comment">//     console.log('damn Websocket is broken!')</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// this.term.attach(this.terminalSocket)</span></span><br><span class="line">    <span class="comment">// 绑定xterm到ws流中 &#125;,</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> terminalContainer = <span class="built_in">document</span>.getElementById(<span class="string">'terminal'</span>)</span><br><span class="line">      <span class="comment">//创建xterm实例</span></span><br><span class="line">      <span class="keyword">this</span>.term = <span class="keyword">new</span> Terminal(&#123;</span><br><span class="line">        cursorBlink: <span class="literal">true</span>, <span class="comment">// 显示光标</span></span><br><span class="line">        cursorStyle: <span class="string">"underline"</span> <span class="comment">// 光标样式</span></span><br><span class="line">        &#125;)                     <span class="comment">// 创建一个新的Terminal对象</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.term.open(terminalContainer)              <span class="comment">// 将term挂载到dom节点上</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//在xterm上显示命令行提示</span></span><br><span class="line">      <span class="keyword">this</span>.term.write(<span class="string">'$ '</span>)</span><br><span class="line">      <span class="comment">//监听xterm的键盘事件</span></span><br><span class="line">      <span class="keyword">this</span>.term.on(<span class="string">'key'</span>, (key, ev)=&gt;&#123; </span><br><span class="line">        <span class="comment">// key是输入的字符 ev是键盘按键事件</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"key=========="</span>, ev.keyCode);</span><br><span class="line">        <span class="keyword">this</span>.term.write(key) <span class="comment">// 将输入的字符打印到黑板中</span></span><br><span class="line">        <span class="keyword">if</span> (ev.keyCode == <span class="number">13</span>) &#123; <span class="comment">// 输入回车</span></span><br><span class="line">            <span class="comment">// console.log("输入回车")</span></span><br><span class="line">            <span class="comment">// this.term.write('$ ')</span></span><br><span class="line">            <span class="comment">// console.log(this.order)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用webscoket将数据发送到django</span></span><br><span class="line">            <span class="keyword">this</span>.terminalSocket.send(<span class="keyword">this</span>.order)</span><br><span class="line">            <span class="comment">// this.order=''</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"里面的order"</span>,<span class="keyword">this</span>.order)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ev.keyCode == <span class="number">8</span>)&#123;<span class="comment">//删除按钮</span></span><br><span class="line">          <span class="comment">//截取字符串[0,lenth-1]</span></span><br><span class="line">          <span class="keyword">this</span>.order = <span class="keyword">this</span>.order.substr(<span class="number">0</span>,<span class="keyword">this</span>.order.length<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//清空当前一条的命令</span></span><br><span class="line">          <span class="keyword">this</span>.term.write(<span class="string">"\x1b[2K\r"</span>)</span><br><span class="line">          <span class="comment">//简化当前的新的命令显示上</span></span><br><span class="line">          <span class="keyword">this</span>.term.write(<span class="string">"$ "</span>+<span class="keyword">this</span>.order)</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"截取的字符串"</span>+<span class="keyword">this</span>.order)</span><br><span class="line">          <span class="keyword">typeof</span> <span class="keyword">this</span>.order</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 将每次输入的字符拼凑起来</span></span><br><span class="line">        <span class="keyword">this</span>.order += key</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"外面的order"</span>,<span class="keyword">this</span>.order)&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><h4 id="使用paramiko与服务器建立交互"><a href="#使用paramiko与服务器建立交互" class="headerlink" title="使用paramiko与服务器建立交互"></a>使用paramiko与服务器建立交互</h4><p>1.安装</p><p><code>pip install paramiko</code></p><p>2.利用<code>paramiko</code>进行<code>ssh</code>远程登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SSH客户端</span></span><br><span class="line">client = paramiko.SSHClient()</span><br><span class="line"><span class="comment"># SSH客户端Host策略,目的是接受不在本地Known_host文件下的主机。</span></span><br><span class="line">client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"><span class="comment"># SSH客户端开启连接</span></span><br><span class="line">client.connect(</span><br><span class="line">    hostname=<span class="string">"192.168.184.144"</span>,port=<span class="number">22</span>,username=<span class="string">'xterm'</span>,password=<span class="string">'123123'</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># stdout 为正确输出，stderr为错误输出,每次执行完成只有一个变量中有值</span></span><br><span class="line">stdin, stdout, stderr = client.exec_command(<span class="string">"ls"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行ls命令的结果</span></span><br><span class="line">print(stdout.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>3.结合<code>websocket</code>实现实时操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wsserver.py</span></span><br><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSSHService</span><span class="params">(WebsocketConsumer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.accept()</span><br><span class="line">        self.sh = paramiko.SSHClient()  <span class="comment"># 1 创建SSH对象</span></span><br><span class="line">        self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  <span class="comment"># 2 允许连接不在know_hosts文件中的主机</span></span><br><span class="line">        self.sh.connect(<span class="string">"192.168.184.144"</span>, username=<span class="string">"root"</span>, password=<span class="string">"beijing2018"</span>)  <span class="comment"># 3 连接服务器</span></span><br><span class="line">        print(<span class="string">"连接成功"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data=None, bytes_data=None)</span>:</span></span><br><span class="line">        print(str(text_data))  <span class="comment"># 打印收到的数据</span></span><br><span class="line">        print(type(text_data))</span><br><span class="line"></span><br><span class="line">        stdin, stdout, stderr = self.sh.exec_command(text_data)</span><br><span class="line"></span><br><span class="line">        right_info = stdout.read()</span><br><span class="line">        err_info = stderr.read()</span><br><span class="line">        print(right_info)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right_info:</span><br><span class="line">            new_data = right_info.decode(<span class="string">"utf-8"</span>).replace(<span class="string">"\n"</span>,<span class="string">"\r\n"</span>)</span><br><span class="line">            print(new_data)</span><br><span class="line">            self.send(new_data)</span><br><span class="line">        <span class="keyword">elif</span> err_info:</span><br><span class="line">            new_data = err_info.decode(<span class="string">"utf-8"</span>).replace(<span class="string">"\n"</span>, <span class="string">"\r\n"</span>)</span><br><span class="line">            print(new_data)</span><br><span class="line">            self.send(new_data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(self.send(<span class="string">"命令执行成功"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f'sorry<span class="subst">&#123;self&#125;</span>,你被女朋友抛弃了'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Websocket即时通讯</title>
      <link href="/2020/05/06/Blog/nine/"/>
      <url>/2020/05/06/Blog/nine/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Websocket-即时通讯"><a href="#Websocket-即时通讯" class="headerlink" title="Websocket 即时通讯"></a><code>Websocket</code> 即时通讯</h3><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>即时通讯工具一定要保障的是<strong>即时性</strong></p><p>基于现在的通讯协议<code>HTTP</code>要如何保障即时性呢?</p><h3 id="2-短连接型"><a href="#2-短连接型" class="headerlink" title="2.短连接型"></a>2.短连接型</h3><p>基于<code>HTTP</code>短连接如何保障数据的<strong>即时性</strong></p><p><code>HTTP</code>的特性就是无状态的短连接,即一次请求一次响应断开连接失忆,这样服务端就无法主动的去寻找客户端给客户端主动推送消息</p><p>1.轮询</p><p>即:客户端不断向服务器发起请求索取消息</p><p>优点:基本保障消息即时性</p><p>缺点:大量的请求导致客户端和服务端的压力倍增</p><p>2.长轮询</p><p>即:客户端向服务器发起请求,在<code>HTTP</code>最大超时时间内不断开请求获取消息,超时后重新发起请求</p><p>优点:基本保障消息即时性</p><p>缺点:长期占用客户端独立线程,长期占用服务端独立线程,服务器压力倍增</p><h3 id="3-长连接型"><a href="#3-长连接型" class="headerlink" title="3.长连接型"></a>3.长连接型</h3><p>基于<code>socket</code>长连接,由于长连接是双向且有状态的保持连接,所以服务端可以有效的主动的向客户端推送数据</p><p>1.<code>socketio</code>长连接协议</p><p>优点:消息即时,兼容性强</p><p>缺点:接入复杂度高,为保障兼容性冗余依赖过多较重</p><p>2.<code>websocket</code>长连接协议</p><p>优点:消息即时,轻量级,灵活适应多场景,机制更加成熟</p><p>缺点:相比<code>socket</code>兼容性较差</p><p>总体来说,<code>Socketio</code>紧紧只是为了解决通讯而存在的,而<code>Websocket</code>是为了解决更多更复杂的场景通讯而存在的</p><p>这里推荐<code>Websocket</code>的原因是因为,我们的<code>Django</code>框架甚至是<code>Flask</code>框架,都有成熟的第三方库</p><p>而且<code>Tornado</code>框架集成<code>Websocket</code></p><h3 id="4-Django实现Websocket"><a href="#4-Django实现Websocket" class="headerlink" title="4.Django实现Websocket"></a>4.<code>Django</code>实现<code>Websocket</code></h3><p>使用<code>Django</code>来实现<code>Websocket</code>服务的方法很多在这里我们推荐技术最新的<code>Channels</code>库来实现</p><h3 id="4-1-安装DjangoChannels"><a href="#4-1-安装DjangoChannels" class="headerlink" title="4.1.安装DjangoChannels"></a>4.1.安装<code>DjangoChannels</code></h3><p><code>Channels</code>安装<em>如果你是<code>Windows</code>操作系统的话,那么必要条件就是<code>Python3.7</code></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install channels</span><br></pre></td></tr></table></figure><h3 id="4-2-配置DjangoChannels"><a href="#4-2-配置DjangoChannels" class="headerlink" title="4.2.配置DjangoChannels"></a>4.2.配置<code>DjangoChannels</code></h3><p>1.创建项目<code>ChannelsReady</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startprobject ChannelsReady</span><br></pre></td></tr></table></figure><p>2.在项目的<code>settings.py</code>同级目录中,新建文件<code>routing.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># routing.py</span></span><br><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    <span class="comment"># 暂时为空</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.在项目配置文件<code>settings.py</code>中写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'channels'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ASGI_APPLICATION = <span class="string">"ChannelsReady.routing.application"</span></span><br></pre></td></tr></table></figure><h3 id="4-3-启动带有Channels提供的ASGI的Django项目"><a href="#4-3-启动带有Channels提供的ASGI的Django项目" class="headerlink" title="4.3.启动带有Channels提供的ASGI的Django项目"></a>4.3.启动带有<code>Channels</code>提供的<code>ASGI</code>的<code>Django</code>项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.</span><br><span class="line">Run &#39;python manage.py migrate&#39; to apply them.</span><br><span class="line">February 01, 2020 - 17:27:13</span><br><span class="line">Django version 3.0.2, using settings &#39;ChannelsReady.settings&#39;</span><br><span class="line">Starting ASGI&#x2F;Channels version 2.4.0 development server at http:&#x2F;&#x2F;0.0.0.0:8000&#x2F;</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br></pre></td></tr></table></figure><p>很明显可以看到<code>ASGI/Channels</code>,这样就算启动完成了</p><h3 id="4-4-创建Websocket服务"><a href="#4-4-创建Websocket服务" class="headerlink" title="4.4.创建Websocket服务"></a>4.4.创建<code>Websocket</code>服务</h3><p>1.创建一个新的应用<code>chats</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp chats</span><br></pre></td></tr></table></figure><p>2.在<code>settings.py</code>中注册<code>chats</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'chats'</span>,</span><br><span class="line">    <span class="string">'channels'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3.在<code>chats</code>应用中新建文件<code>chatService.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</span><br><span class="line"><span class="comment"># 这里除了 WebsocketConsumer 之外还有</span></span><br><span class="line"><span class="comment"># JsonWebsocketConsumer</span></span><br><span class="line"><span class="comment"># AsyncWebsocketConsumer</span></span><br><span class="line"><span class="comment"># AsyncJsonWebsocketConsumer</span></span><br><span class="line"><span class="comment"># WebsocketConsumer 与 JsonWebsocketConsumer 就是多了一个可以自动处理JSON的方法</span></span><br><span class="line"><span class="comment"># AsyncWebsocketConsumer 与 AsyncJsonWebsocketConsumer 也是多了一个JSON的方法</span></span><br><span class="line"><span class="comment"># AsyncWebsocketConsumer 与 WebsocketConsumer 才是重点</span></span><br><span class="line"><span class="comment"># 看名称似乎理解并不难 Async 无非就是异步带有 async / await</span></span><br><span class="line"><span class="comment"># 是的理解并没有错,但对与我们来说他们唯一不一样的地方,可能就是名字的长短了,用法是一模一样的</span></span><br><span class="line"><span class="comment"># 最夸张的是,基类是同一个,而且这个基类的方法也是Async异步的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span><span class="params">(WebsocketConsumer)</span>:</span></span><br><span class="line">    <span class="comment"># 当Websocket创建连接时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当Websocket接收到消息时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data=None, bytes_data=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当Websocket发生断开连接时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="4-5-为Websocket处理对象增加路由"><a href="#4-5-为Websocket处理对象增加路由" class="headerlink" title="4.5.为Websocket处理对象增加路由"></a>4.5.为<code>Websocket</code>处理对象增加路由</h3><p>1.在<code>chats</code>应用中,新建<code>urls.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> chats.chatService <span class="keyword">import</span> ChatService</span><br><span class="line">websocket_url = [</span><br><span class="line">    path(<span class="string">"ws/"</span>,ChatService)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2.回到项目<code>routing.py</code>文件中增加<code>ASGI</code>非<code>HTTP</code>请求处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter,URLRouter</span><br><span class="line"><span class="keyword">from</span> chats.urls <span class="keyword">import</span> websocket_url</span><br><span class="line"></span><br><span class="line">application = ProtocolTypeRouter(&#123;</span><br><span class="line">    <span class="string">"websocket"</span>:URLRouter(</span><br><span class="line">        websocket_url</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li>下载</li><li>注册到setting.py里的app</li><li>在setting.py同级的目录下注册channels使用的路由—–&gt;routing.py</li><li>将routing.py注册到setting.py</li><li>把urls.py的路由注册到routing.py里</li><li>编写wsserver.py来处理websocket请求</li></ol><h3 id="5-websocket客户端"><a href="#5-websocket客户端" class="headerlink" title="5.websocket客户端"></a>5.websocket客户端</h3><h4 id="5-1-基于vue的websocket客户端"><a href="#5-1-基于vue的websocket客户端" class="headerlink" title="5.1.基于vue的websocket客户端"></a>5.1.基于vue的websocket客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;send&quot; value&#x3D;&quot;发送&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;close_socket&quot; value&#x3D;&quot;关闭&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;websocket1&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message:&#39;&#39;,</span><br><span class="line">            testsocket:&#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        send()&#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;    send  发送信息</span><br><span class="line">        &#x2F;&#x2F;    close 关闭连接</span><br><span class="line"></span><br><span class="line">            this.testsocket.send(this.message)</span><br><span class="line">            this.testsocket.onmessage &#x3D; (res) &#x3D;&gt; &#123;</span><br><span class="line">                console.log(&quot;WS的返回结果&quot;,res.data);         </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        close_socket()&#123;</span><br><span class="line">            this.testsocket.close()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        this.testsocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;ws&#x2F;&quot;) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; onopen     定义打开时的函数</span><br><span class="line">        &#x2F;&#x2F; onclose    定义关闭时的函数</span><br><span class="line">        &#x2F;&#x2F; onmessage  定义接收数据时候的函数</span><br><span class="line">        &#x2F;&#x2F; this.testsocket.onopen &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;开始连接socket&quot;)</span><br><span class="line">        &#x2F;&#x2F; &#125;,</span><br><span class="line">        &#x2F;&#x2F; this.testsocket.onclose &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;socket连接已经关闭&quot;)</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="6-广播消息"><a href="#6-广播消息" class="headerlink" title="6.广播消息"></a>6.广播消息</h3><h4 id="6-1客户端保持不变，同时打开多个客户端"><a href="#6-1客户端保持不变，同时打开多个客户端" class="headerlink" title="6.1客户端保持不变，同时打开多个客户端"></a>6.1客户端保持不变，同时打开多个客户端</h4><h4 id="6-2服务端存储每个链接的对象"><a href="#6-2服务端存储每个链接的对象" class="headerlink" title="6.2服务端存储每个链接的对象"></a>6.2服务端存储每个链接的对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">socket_list = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span><span class="params">(WebsocketConsumer)</span>:</span></span><br><span class="line">    <span class="comment"># 当Websocket创建连接时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.accept()</span><br><span class="line">        socket_list.append(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当Websocket接收到消息时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data=None, bytes_data=None)</span>:</span></span><br><span class="line">        print(text_data)  <span class="comment"># 打印收到的数据</span></span><br><span class="line">        <span class="keyword">for</span> ws <span class="keyword">in</span> socket_list:  <span class="comment"># 遍历所有的WebsocketConsumer对象</span></span><br><span class="line">        ws.send(text_data)  <span class="comment"># 对每一个WebsocketConsumer对象发送数据</span></span><br></pre></td></tr></table></figure><h3 id="7-点对点消息"><a href="#7-点对点消息" class="headerlink" title="7.点对点消息"></a>7.点对点消息</h3><h4 id="7-1客户端将用户名拼接到url，并在发送的消息里指明要发送的对象"><a href="#7-1客户端将用户名拼接到url，并在发送的消息里指明要发送的对象" class="headerlink" title="7.1客户端将用户名拼接到url，并在发送的消息里指明要发送的对象"></a>7.1客户端将用户名拼接到url，并在发送的消息里指明要发送的对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;user&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;send&quot; value&#x3D;&quot;发送&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;&lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;close_socket&quot; value&#x3D;&quot;关闭&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;websocket1&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message:&#39;&#39;,</span><br><span class="line">            testsocket:&#39;&#39;,</span><br><span class="line">            user:&#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        send()&#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;    send  发送信息</span><br><span class="line">        &#x2F;&#x2F;    close 关闭连接</span><br><span class="line">            var data1 &#x3D; &#123;&quot;message&quot;:this.message,&quot;to_user&quot;:this.user&#125;</span><br><span class="line">           </span><br><span class="line">            this.testsocket.send(JSON.stringify(data1))</span><br><span class="line">            this.testsocket.onmessage &#x3D; (res) &#x3D;&gt; &#123;</span><br><span class="line">                console.log(&quot;WS的返回结果&quot;,res.data);         </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        close_socket()&#123;</span><br><span class="line">            this.testsocket.close()</span><br><span class="line">        &#125;,</span><br><span class="line">        generate_uuid: function() &#123;</span><br><span class="line">            var d &#x3D; new Date().getTime();</span><br><span class="line">            if (window.performance &amp;&amp; typeof window.performance.now &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">                d +&#x3D; performance.now(); &#x2F;&#x2F;use high-precision timer if available</span><br><span class="line">            &#125;</span><br><span class="line">            var uuid &#x3D; &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(</span><br><span class="line">                &#x2F;[xy]&#x2F;g,</span><br><span class="line">                function(c) &#123;</span><br><span class="line">                var r &#x3D; (d + Math.random() * 16) % 16 | 0;</span><br><span class="line">                d &#x3D; Math.floor(d &#x2F; 16);</span><br><span class="line">                return (c &#x3D;&#x3D; &quot;x&quot; ? r : (r &amp; 0x3) | 0x8).toString(16);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            return uuid;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        var username &#x3D; this.generate_uuid();</span><br><span class="line">        console.log(username)</span><br><span class="line">        this.testsocket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;ws&#x2F;&quot;+ username +&quot;&#x2F;&quot;) </span><br><span class="line">        console.log(this.testsocket)</span><br><span class="line"></span><br><span class="line">      this.testsocket.onmessage &#x3D; (res) &#x3D;&gt; &#123;</span><br><span class="line">                console.log(&quot;WS的返回结果&quot;,res.data);         </span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; onopen     定义打开时的函数</span><br><span class="line">        &#x2F;&#x2F; onclose    定义关闭时的函数</span><br><span class="line">        &#x2F;&#x2F; onmessage  定义接收数据时候的函数</span><br><span class="line">        &#x2F;&#x2F; this.testsocket.onopen &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;开始连接socket&quot;)</span><br><span class="line">        &#x2F;&#x2F; &#125;,</span><br><span class="line">        &#x2F;&#x2F; this.testsocket.onclose &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F;     console.log(&quot;socket连接已经关闭&quot;)</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="7-2服务端存储用户名以及websocketConsumer，然后给对应的用户发送信息"><a href="#7-2服务端存储用户名以及websocketConsumer，然后给对应的用户发送信息" class="headerlink" title="7.2服务端存储用户名以及websocketConsumer，然后给对应的用户发送信息"></a>7.2服务端存储用户名以及websocketConsumer，然后给对应的用户发送信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</span><br><span class="line">user_dict =&#123;&#125;</span><br><span class="line">list = []</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatService</span><span class="params">(WebsocketConsumer)</span>:</span></span><br><span class="line">    <span class="comment"># 当Websocket创建连接时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.accept()</span><br><span class="line">        username = self.scope.get(<span class="string">"url_route"</span>).get(<span class="string">"kwargs"</span>).get(<span class="string">"username"</span>)</span><br><span class="line">        user_dict[username] =self</span><br><span class="line">        print(user_dict)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># list.append(self)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当Websocket接收到消息时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data=None, bytes_data=None)</span>:</span></span><br><span class="line">        data = json.loads(text_data)</span><br><span class="line">        print(data)</span><br><span class="line">        to_user = data.get(<span class="string">"to_user"</span>)</span><br><span class="line">        message = data.get(<span class="string">"message"</span>)</span><br><span class="line"></span><br><span class="line">        ws = user_dict.get(to_user)</span><br><span class="line">        print(to_user)</span><br><span class="line">        print(message)</span><br><span class="line">        print(ws)</span><br><span class="line">        ws.send(text_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当Websocket发生断开连接时</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlipayDemo</title>
      <link href="/2020/05/03/Note/AlipayDemo/"/>
      <url>/2020/05/03/Note/AlipayDemo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from Crypto.PublicKey import RSA</span><br><span class="line">from Crypto.Signature import PKCS1_v1_5</span><br><span class="line">from Crypto.Hash import SHA256</span><br><span class="line">from urllib.parse import quote_plus</span><br><span class="line">from urllib.parse import urlparse, parse_qs</span><br><span class="line">from base64 import decodebytes, encodebytes</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">class AliPay(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    支付宝支付接口(PC端支付接口)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, appid, app_notify_url, app_private_key_path,</span><br><span class="line">                 alipay_public_key_path, return_url, debug&#x3D;False):</span><br><span class="line">        self.appid &#x3D; appid</span><br><span class="line">        self.app_notify_url &#x3D; app_notify_url</span><br><span class="line">        self.app_private_key_path &#x3D; app_private_key_path</span><br><span class="line">        self.app_private_key &#x3D; None</span><br><span class="line">        self.return_url &#x3D; return_url</span><br><span class="line">        with open(self.app_private_key_path) as fp:</span><br><span class="line">            self.app_private_key &#x3D; RSA.importKey(fp.read())</span><br><span class="line">        self.alipay_public_key_path &#x3D; alipay_public_key_path</span><br><span class="line">        with open(self.alipay_public_key_path) as fp:</span><br><span class="line">            self.alipay_public_key &#x3D; RSA.importKey(fp.read())</span><br><span class="line"></span><br><span class="line">        if debug is True:</span><br><span class="line">            self.__gateway &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipaydev.com&#x2F;gateway.do&quot;</span><br><span class="line">        else:</span><br><span class="line">            self.__gateway &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do&quot;</span><br><span class="line"></span><br><span class="line">    def direct_pay(self, subject, out_trade_no, total_amount, return_url&#x3D;None, **kwargs):</span><br><span class="line">        biz_content &#x3D; &#123;</span><br><span class="line">            &quot;subject&quot;: subject,</span><br><span class="line">            &quot;out_trade_no&quot;: out_trade_no,</span><br><span class="line">            &quot;total_amount&quot;: total_amount,</span><br><span class="line">            &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;,</span><br><span class="line">            # &quot;qr_pay_mode&quot;:4</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        biz_content.update(kwargs)</span><br><span class="line">        data &#x3D; self.build_body(&quot;alipay.trade.page.pay&quot;, biz_content, self.return_url)</span><br><span class="line">        return self.sign_data(data)</span><br><span class="line"></span><br><span class="line">    def build_body(self, method, biz_content, return_url&#x3D;None):</span><br><span class="line">        data &#x3D; &#123;</span><br><span class="line">            &quot;app_id&quot;: self.appid,</span><br><span class="line">            &quot;method&quot;: method,</span><br><span class="line">            &quot;charset&quot;: &quot;utf-8&quot;,</span><br><span class="line">            &quot;sign_type&quot;: &quot;RSA2&quot;,</span><br><span class="line">            &quot;timestamp&quot;: datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;),</span><br><span class="line">            &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">            &quot;biz_content&quot;: biz_content</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if return_url is not None:</span><br><span class="line">            data[&quot;notify_url&quot;] &#x3D; self.app_notify_url</span><br><span class="line">            data[&quot;return_url&quot;] &#x3D; self.return_url</span><br><span class="line"></span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">    def sign_data(self, data):</span><br><span class="line">        data.pop(&quot;sign&quot;, None)</span><br><span class="line">        # 排序后的字符串</span><br><span class="line">        unsigned_items &#x3D; self.ordered_data(data)</span><br><span class="line">        unsigned_string &#x3D; &quot;&amp;&quot;.join(&quot;&#123;0&#125;&#x3D;&#123;1&#125;&quot;.format(k, v) for k, v in unsigned_items)</span><br><span class="line">        sign &#x3D; self.sign(unsigned_string.encode(&quot;utf-8&quot;))</span><br><span class="line">        # ordered_items &#x3D; self.ordered_data(data)</span><br><span class="line">        quoted_string &#x3D; &quot;&amp;&quot;.join(&quot;&#123;0&#125;&#x3D;&#123;1&#125;&quot;.format(k, quote_plus(v)) for k, v in unsigned_items)</span><br><span class="line"></span><br><span class="line">        # 获得最终的订单信息字符串</span><br><span class="line">        signed_string &#x3D; quoted_string + &quot;&amp;sign&#x3D;&quot; + quote_plus(sign)</span><br><span class="line">        return signed_string</span><br><span class="line"></span><br><span class="line">    def ordered_data(self, data):</span><br><span class="line">        complex_keys &#x3D; []</span><br><span class="line">        for key, value in data.items():</span><br><span class="line">            if isinstance(value, dict):</span><br><span class="line">                complex_keys.append(key)</span><br><span class="line"></span><br><span class="line">        # 将字典类型的数据dump出来</span><br><span class="line">        for key in complex_keys:</span><br><span class="line">            data[key] &#x3D; json.dumps(data[key], separators&#x3D;(&#39;,&#39;, &#39;:&#39;))</span><br><span class="line"></span><br><span class="line">        return sorted([(k, v) for k, v in data.items()])</span><br><span class="line"></span><br><span class="line">    def sign(self, unsigned_string):</span><br><span class="line">        # 开始计算签名</span><br><span class="line">        key &#x3D; self.app_private_key</span><br><span class="line">        signer &#x3D; PKCS1_v1_5.new(key)</span><br><span class="line">        signature &#x3D; signer.sign(SHA256.new(unsigned_string))</span><br><span class="line">        # base64 编码，转换为unicode表示并移除回车</span><br><span class="line">        sign &#x3D; encodebytes(signature).decode(&quot;utf8&quot;).replace(&quot;\n&quot;, &quot;&quot;)</span><br><span class="line">        return sign</span><br><span class="line"></span><br><span class="line">    def _verify(self, raw_content, signature):</span><br><span class="line">        # 开始计算签名</span><br><span class="line">        key &#x3D; self.alipay_public_key</span><br><span class="line">        signer &#x3D; PKCS1_v1_5.new(key)</span><br><span class="line">        digest &#x3D; SHA256.new()</span><br><span class="line">        digest.update(raw_content.encode(&quot;utf8&quot;))</span><br><span class="line">        if signer.verify(digest, decodebytes(signature.encode(&quot;utf8&quot;))):</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def verify(self, data, signature):</span><br><span class="line">        if &quot;sign_type&quot; in data:</span><br><span class="line">            sign_type &#x3D; data.pop(&quot;sign_type&quot;)</span><br><span class="line">        # 排序后的字符串</span><br><span class="line">        unsigned_items &#x3D; self.ordered_data(data)</span><br><span class="line">        message &#x3D; &quot;&amp;&quot;.join(u&quot;&#123;&#125;&#x3D;&#123;&#125;&quot;.format(k, v) for k, v in unsigned_items)</span><br><span class="line">        return self._verify(message, signature)</span><br><span class="line"></span><br><span class="line">    #请求退款接口</span><br><span class="line">    def api_alipay_trade_refund(self,refund_amount,out_trade_no&#x3D;None,trade_no&#x3D;None,**kwargs):</span><br><span class="line"></span><br><span class="line">        #构造参数体</span><br><span class="line">        biz_content &#x3D; &#123; &quot;refund_amount&quot;:refund_amount&#125;</span><br><span class="line"></span><br><span class="line">        #传递可选参数</span><br><span class="line">        biz_content.update(**kwargs)</span><br><span class="line"></span><br><span class="line">        #判断使用站外订单还是支付宝订单</span><br><span class="line">        if out_trade_no:</span><br><span class="line">            biz_content[&quot;out_trade_no&quot;] &#x3D; out_trade_no</span><br><span class="line">        if trade_no:</span><br><span class="line">            biz_content[&quot;trade_no&quot;] &#x3D; trade_no</span><br><span class="line"></span><br><span class="line">        #构造支付接口地址</span><br><span class="line">        data &#x3D; self.build_body(&quot;alipay.trade.refund&quot;,biz_content)</span><br><span class="line"></span><br><span class="line">        #构造url</span><br><span class="line">        url &#x3D; self.__gateway+&quot;?&quot; + self.sign_data(data)</span><br><span class="line"></span><br><span class="line">        #请求接口</span><br><span class="line">        r &#x3D; requests.get(url)</span><br><span class="line">        html &#x3D; r.content.decode(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">        return html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归与无限极评论</title>
      <link href="/2020/04/30/Blog/eight/"/>
      <url>/2020/04/30/Blog/eight/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p><strong>什么是递归？</strong></p><ol><li>在数学与见算计科学中，是指在函数的定义中使用函数自身的方法。</li><li>递归算法就是一种直接或者间接的调用自身函数或者方法的算法</li><li>递归算法的实质是把问题分解规模小的同类问题的子问题</li><li>然后调用自身方法来解</li></ol><p><strong>递归的基本原理</strong></p><ol><li>每一级的函数调用都有自己的变量</li><li>每一次函数调用都会有一次返回</li><li>递归函数中，位于递归调用前的语句和各级被调用函数具有相同的执行顺序</li><li>递归函数中，位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反</li><li>虽然每一级递归都有自己的变量，但是函数的代码不会得到复制</li></ol><p><strong>递归的优缺点</strong></p><p>优点</p><ul><li>实现简单</li><li>可读性好</li></ul><p>缺点</p><ul><li>递归调用，占用空间大</li><li>递归太深，容易发生栈溢出</li><li>可能存在重复计算</li></ul><p><strong>递归的三大要素</strong></p><ol><li>明确函数要做什么</li><li>寻找递归结束条件</li><li>找出函数的等价关系式</li></ol><h2 id="python对递归的使用"><a href="#python对递归的使用" class="headerlink" title="python对递归的使用"></a>python对递归的使用</h2><p><strong>解决最大递归深度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p><strong>高斯求和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_number</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> n + count_number(n<span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_Number2</span><span class="params">(n)</span>:</span></span><br><span class="line">  sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">    sum += i</span><br><span class="line">  <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p><strong>斐波那契</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> n ==<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> fn(n<span class="number">-1</span>)+fn(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><h2 id="无限级评论"><a href="#无限级评论" class="headerlink" title="无限级评论"></a>无限级评论</h2><p><code>[{},{},{},{},{}]</code></p><p>[{    “child”:  {“child”:[ {} , {} ]    }     },  {id:5, child:[{ child:[{}],{}]    }   ]</p><p>django将数据封装为树结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_comments</span><span class="params">(data)</span>:</span></span><br><span class="line">    list = []</span><br><span class="line">    tree = &#123;&#125;</span><br><span class="line">    root = <span class="string">''</span></span><br><span class="line">    p_id = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment">#将data循环，然后加入一个dict中，key为每条数据的ID，val对应为整条数据</span></span><br><span class="line">        tree[i[<span class="string">"id"</span>]] = i</span><br><span class="line"><span class="comment">#&#123;  1:&#123;id:1&#125;,  2:&#123;id:2&#125;,  3:&#123;id:3&#125;  &#125;  </span></span><br><span class="line">        <span class="comment"># print(tree)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">      <span class="comment">#p_id==None，他就是祖先</span></span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">"p_id"</span>] == <span class="literal">None</span>:</span><br><span class="line">            root = tree[i[<span class="string">"id"</span>]]  <span class="comment">#i.di为tree里的key，将key对应的val取出</span></span><br><span class="line">            list.append(root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p_id = i[<span class="string">"p_id"</span>]</span><br><span class="line">            <span class="comment"># 判断父级是否有孩子字段（childlist），如果有将当前数据加入，如果没有添加（childlist）后再加入</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"childlist"</span> <span class="keyword">not</span> <span class="keyword">in</span> tree[p_id]:</span><br><span class="line">                tree[p_id][<span class="string">'childlist'</span>] = []</span><br><span class="line">            tree[p_id][<span class="string">"childlist"</span>].append(tree[i[<span class="string">"id"</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><p>vue使用父子组件递归展示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- zizujian.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;li&gt;&#123;&#123;data.content&#125;&#125;</span><br><span class="line">            &lt;ul v-if&#x3D;&quot;data.childlist &amp;&amp; data.childlist.length&gt;0&quot;&gt;</span><br><span class="line">            &lt;zi v-for&#x3D;&quot;i in data.childlist&quot; :key&#x3D;&quot;i.id&quot; :data&#x3D;&quot;i&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;zi&quot;,</span><br><span class="line">    props:[&quot;data&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    </span><br><span class="line">ul&#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    &#x2F;* padding-left: 20px *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- fuzujian.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;zi :data&#x3D;&quot;data&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- &lt;zizujian :data&#x3D;&quot;data&quot; &#x2F;&gt; --&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import zi from &#39;.&#x2F;zi&#39;</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;showzi&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            data:&#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        zi</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        get_info()&#123;</span><br><span class="line">            axios.get(&quot;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;comment&#x2F;com&#x2F;&quot;).then(res&#x3D;&gt;&#123;</span><br><span class="line">                var mytree &#x3D; &#123;&quot;id&quot;:0,&quot;content&quot;:&quot;&quot;&#125;</span><br><span class="line">                mytree[&quot;childlist&quot;] &#x3D; res.data.data</span><br><span class="line">                this.data&#x3D; mytree</span><br><span class="line">                &#x2F;&#x2F; this.data&#x3D; res.data.data</span><br><span class="line">                &#x2F;&#x2F; console.log(this.data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.get_info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中从数据库查询单的数据进行运算</title>
      <link href="/2020/04/28/Note/%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97/"/>
      <url>/2020/04/28/Note/%E6%95%B0%E6%8D%AE%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Vue中从数据库查询单的数据进行运算"><a href="#Vue中从数据库查询单的数据进行运算" class="headerlink" title="Vue中从数据库查询单的数据进行运算"></a>Vue中从数据库查询单的数据进行运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;商品序号&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;商品名称&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;商品价格&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;购买数量&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;总价格&lt;&#x2F;th&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr v-for&#x3D;&quot;(item,index) in carlist&quot; :key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;index +1&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;item.gname&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;item.price&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;item.num&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;商品价格*商品数量&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure><p>就像如此总价格需要<strong>商品价格*商品数量</strong> 进行乘法运算 但在模版渲染里乘法符号是个字符串，所有需要在方法里面定义和计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all:function()&#123;</span><br><span class="line">    let list &#x3D; this.carlist;</span><br><span class="line">    for(let i&#x3D;0,l&#x3D;list.length;i&lt;l;i++)&#123;</span><br><span class="line">        var total &#x3D; list[i][&#39;price&#39;] * list[i][&#39;num&#39;]</span><br><span class="line">        this.allmoney &#x3D; total</span><br><span class="line">        &#125;</span><br><span class="line">        return total</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后 将 商品价格*商品数量 换成 all()</p><p>因为这里调用的是<strong>方法</strong>使用需要加上（）</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat Premium15安装与激活</title>
      <link href="/2020/04/28/Blog/seven/"/>
      <url>/2020/04/28/Blog/seven/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天看到同学们连接数据库的可视化工具变得高大上了，由navicat for mysql 变为 <strong>Navicat Premium</strong>，所以我就搞上了</p><h3 id="一、进入官方进行下载"><a href="#一、进入官方进行下载" class="headerlink" title="一、进入官方进行下载"></a>一、进入官方进行下载</h3><p>目前官网已经更新到Navicat Premium15了，本教程为NavicatPremium的安装与使用教程。</p><p>官方下载地址为：<a href="https://www.navicat.com.cn/download/navicat-premium" target="_blank" rel="noopener">https://www.navicat.com.cn/download/navicat-premium</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium1.png" alt="Navicat-Premium"></p><p>Navicat Premium分为Windows、MacOS、Linux版，我的电脑是Windows10 64bit， 所以下载的为Windows10 64bit版的，随便选择一个位置下载即可。</p><h3 id="二、下载完成进行安装"><a href="#二、下载完成进行安装" class="headerlink" title="二、下载完成进行安装"></a>二、下载完成进行安装</h3><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium2.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium3.png" alt="Navicat-Premium"></p><p>选择安装位置，可自己选择安装位置（要记清安装的位置，后面有用）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium4.png" alt="Navicat-Premium"></p><p>此处为快捷方式的创建位置，下一步即可</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium5.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium6.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium7.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium8.png" alt="Navicat-Premium"></p><p>tip:安装完成后先不要启动软件（切记），此时为试用版（14天），下面为破解过程，仅供个人学习和使用，有能力的同学请支持正版。</p><h3 id="Navicat-Premium15破解"><a href="#Navicat-Premium15破解" class="headerlink" title="Navicat Premium15破解"></a>Navicat Premium15破解</h3><p>首先需要下载注册工具</p><p>下载地址：<a href="http://wangshuo.jb51.net:81/201903/tools/NavicatKeygen_jb51.rar" target="_blank" rel="noopener">http://wangshuo.jb51.net:81/201903/tools/NavicatKeygen_jb51.rar</a></p><p>解压密码：<a href="http://www.jb51.net" target="_blank" rel="noopener">www.jb51.net</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium9.png" alt="Navicat-Premium"></p><p>若链接失效可自己搜索下载该工具，注意需要是新版的5.6.0或以上（博主目前能找到的最新的为5.6.0），亲测可注册navicat premium15及以下版本</p><p>双击运行注册工具（本人在未断网未关闭防火墙情况下成功），选择对应的navicat版本，此处为v15,点击Path选择刚才安装navicat目录下的navicat.exe文件</p><p>此处有部分朋友反应解压时工具会被自动删除，因为工具的特殊性，可能会被防护软件监测为病毒删除</p><p>为了保险起见可关闭网络和防火强，若安装了其他防护软件如电脑管家也要一并关闭，并将windows的实时保护关闭</p><p><strong>注意此时不能开启navicat premium（切记此处不可忽略）</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium10.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium11.png" alt="Navicat-Premium"></p><p>出现此界面表示成功</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium12.png" alt="Navicat-Premium"></p><p>选择对应的版本和语言，输入Your Name和Your Organization（可随意输入，也可以不修改使用默认的）,点击生成注册码，然后运行Navicat将注册码复制到软注册栏</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium13.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium14.png" alt="Navicat-Premium"></p><h3 id="点击激活"><a href="#点击激活" class="headerlink" title="点击激活"></a>点击激活</h3><p>此处部分人的激活码后面显示的是红叉，可能是由于上面步骤操作不规范</p><p>未显示cracked就启动了navicate、版本选择不匹配，Patch未选择等原因，可删除软件和安装目录后重新按照步骤安装</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium15.png" alt="Navicat-Premium"></p><p>选择手动激活</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium16.png" alt="Navicat-Premium"></p><p>将请求码复制到注册工具的Request Code中，点击Generate</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium17.png" alt="Navicat-Premium"></p><p>返回activation code即为成功</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium18.png" alt="Navicat-Premium"></p><p>此时手动激活页面的激活码会被自动填充，点击激活即可</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium19.png" alt="Navicat-Premium"></p><p>至此，Navicat Premium15的激活已经完成</p><p>若激活失败可以卸载Navicat Premium删除安装目录后重新尝试几次</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium20.png" alt="Navicat-Premium"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium21.png" alt="Navicat-Premium"></p><p>激活完成就可以开始使用Navicat了 (~ v *)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/Navicat-Premium22.png" alt="Navicat-Premium"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Navicat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git联合开发注意事项</title>
      <link href="/2020/04/21/Note/git%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/"/>
      <url>/2020/04/21/Note/git%E8%81%94%E5%90%88%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><p>尽可能少犯错误，这是人的准则，不犯错误那是天使的梦想，尘世上的一切都免不了错误的。 错误犹如一种引力每一种挫折或不利的突变，是带着同样或较大的有利的种子。<br>                                                ——爱默生【美】</p><hr><h3 id="git-联合开发"><a href="#git-联合开发" class="headerlink" title="git 联合开发"></a>git 联合开发</h3><p>联合开发过程中，不时会遇到，有不同的需求同时开发，开发过程中，有的需求需要提前上线，有的则延后上线，这个时候，如果代码混在一起，一起提交，很可能出问题。</p><p>解决方案是，记住，使用新的分支开发新的功能，最终版本推送的时候，直接可以通过同步线上master到本地开发分支，然后推送开发分支到线上master，最终实现功能开发与代码不会混在一起</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、由项目经理（小组长）创建项目库并创建与成员相对应的分支</p><p>2、各成员需要接受小组长的邀请一起进行项目搭建</p><p>3、成员需下载组长的项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone (项目ssh或https)</span><br></pre></td></tr></table></figure><p>4、下载完之后进入项目创建自己的分支和测试分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 origin&#x2F;分支名</span><br></pre></td></tr></table></figure><p>5、查看现在所处分支，并切换到自己的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看：git branch</span><br><span class="line">切换：git checkout  分支名</span><br></pre></td></tr></table></figure><p>6、在自己的分支内对代码进行修改和添加操作</p><p>7、推送代码到自己的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &#39;提交内容&#39;</span><br><span class="line">git push origin 自己分支名</span><br></pre></td></tr></table></figure><p>8、推送自己分支的代码到测试（develop）分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout  测试分支名</span><br><span class="line">git pull origin 测试分支名  拉最新的代码</span><br><span class="line">git merge 自己分支名  进行自己分支的代码合并到测试分支</span><br><span class="line">git push origin 测试分支名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我分分钟弄死你啊————《唐人街探案》</title>
      <link href="/2020/04/18/Movie/tangtan/"/>
      <url>/2020/04/18/Movie/tangtan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《唐人街探案》是由万达影视传媒有限公司、上海骋亚影视文化传媒有限公司、湖南芒果娱乐有限公司、合一影业有限公司等联合出品，陈思诚执导，王宝强、刘昊然领衔主演，佟丽娅、陈赫、小沈阳、肖央、张子枫等主演的动作喜剧电影。</p><p>该片讲述了唐仁、秦风必须在躲避警察追捕、匪帮追杀、黑帮围剿的同时，在短短七天内，完成找到“失落的黄金”、查明“真凶”、为自己“洗清罪名”这些“逆天”的任务。</p><p>该片获得第73届威尼斯国际电影节“威尼斯日”特别推荐和展映，中国内地票房超8.23亿</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/tangtan.png" alt="move"></p><p>该片讲述了，天赋异禀的结巴少年“秦风”警校落榜，被姥姥遣送泰国找远房表舅——号称“唐人街第一神探 ”，实则“猥琐”大叔的“唐仁“散心。不想一夜花天酒地后，唐仁沦为离奇凶案嫌疑人，不得不和秦风亡命天涯，穷追不舍的警探——-“疯狗”黄兰登；无敌幸运的警察——“草包”坤泰；穷凶极恶、阴差阳错的“匪帮三人组”；高深莫测的“唐人街教父”；“美艳风骚老板娘”等悉数登场。七天，唐仁、秦风这对“欢喜冤家”、“天作之合”必须取长补短、同仇敌忾，他们要在躲避警察追捕、匪帮追杀、黑帮围剿的同时，在短短“七天”内，完成找到“失落的黄金”、查明“真凶”、为他们“洗清罪名”这些“逆天”的任务。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:e128cecc15e2e500cd2056ba0a8cbddcd0ef4b44</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《变形金刚4》内地票房破10亿元</title>
      <link href="/2020/04/17/Movie/bianxing4/"/>
      <url>/2020/04/17/Movie/bianxing4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>截至7月1日晚，《变形金刚4》内地票房已经攀上了8亿大关，将7.32亿的《X战警：逆转未来》远远甩在身后，成为今年内地上映进口片中的票房霸主，而且，预计这个地位在一段时间内都不会受到威胁。而在历年内地上映影片票房排行榜中，《变形金刚4》暂居第八位，不过，相信在一周内，该片的名次就将迅速上升，既能超过今年票房冠军、10.53亿的《西游记之大闹天宫》，也完全有实力刷新《变形金刚》系列影片的票房纪录。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/bian4.jpg" alt="move"></p><p>自上映以来，《变形金刚4》的单日票房从未低于一亿元，7月1日周二半价日，该片依然斩获了过亿票房。在全国二十大城市的排片量也始终高于五成，以绝对领先的姿态统治影市。相比之下，排在第二名的《分手大师》只能拿到20%多的排片；其余影片的排映比例均不足10%，单日票房更是未曾超过500万。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:bacd96e3eeed34e82b20474c78b67bf78beb5fc7</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神性，人性，兽性，你的性取向是什么。《唐人街探案2》你看懂吗</title>
      <link href="/2020/04/16/Movie/tangtan2/"/>
      <url>/2020/04/16/Movie/tangtan2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="材料，正是宋义心中想要报的仇。"><a href="#材料，正是宋义心中想要报的仇。" class="headerlink" title="材料，正是宋义心中想要报的仇。"></a>材料，正是宋义心中想要报的仇。</h3><p>不得不说，<strong>陈思诚虽然在人品上饱受“兽性”质疑</strong>（不代表本人观点），但影视作品“神性”玩得还算靠谱，《唐人街探案2》是一部精心打磨的悬疑喜剧商业大片。</p><p>《唐人街探案2》是唐人街探案系列电影的第二辑，由陈思诚执导，王宝强、刘昊然、肖央、刘承羽、尚语贤、王迅、元华、妻夫木聪、迈克尔·皮特主演的动作片。</p><p>该片讲述了唐仁为巨额奖金欺骗秦风到纽约参加世界名侦探大赛，比赛的内容是寻找杀害唐人街教父七叔的孙子的凶手。两人再次组合侦破案件，并冒着生命危险闹翻纽约的故事。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/tangtan2.jpg" alt="move"></p><p>秦风（刘昊然饰）接到唐仁（王宝强饰）的邀请来纽约参加其与阿香的婚礼。壕气逼人的唐仁迎接秦风，极尽招摇。岂料“婚礼”是唐仁为巨额奖金而参加的世界名侦大赛，比赛的内容是寻找杀害唐人街教父七叔的孙子的凶手。受骗的秦风怒极欲走，却被纽约华人刑警陈英送来的讯息所吸引。七叔孙子的死法离奇，寻人上升为悬赏缉凶。“名侦探”们各显“其能”，鸡飞狗跳。</p><p>众人调查的同时另一起案件发生，作案手法极其相似。原本锁定的凶手竟有了不在场证明，秦风不禁对自己的推理产生了怀疑。第三起案件发生连环案件。秦风、唐仁二人再次披挂，摆脱各路纠缠，闹翻纽约，几欲接近真相。第四起，与凶手失之交臂，诡计呼之欲出。真凶伏法，动机令人不寒而栗。看似完美结案的背后却隐藏着另一个发人深省的谜题。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:DC9F7173707CD096076F4E8F2B08978F402121CF</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>好莱坞大片《敢死队2》票房爆红 李连杰打出中国元素</title>
      <link href="/2020/04/15/Movie/gansidui2/"/>
      <url>/2020/04/15/Movie/gansidui2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相信大家对《敢死队》这部电影一点也不陌生，因为这部电影中明星云集，而在近日《敢死队2》正在热映，在票房方面去捷报连连，票房飘红。</p><p>由史泰龙、施瓦辛格等主演的好莱坞动作大片《敢死队2》正在热映中，截止至9日，影片首周在内地斩获近1.6亿票房，傲视“群雄”，为此出品方之一的乐视 影业创新发布首款“后预告片”，曝光多场激烈枪战场面。据悉，该款预告重金聘请到中国金牌剪辑师魏楠亲自操刀，为中国影迷特别制作，不仅李连杰、余男两位 华裔演员代表成为绝对主力，片尾“敢死么？组队来吧”也宣布了该片为影迷们打造的下一步观影活动正式启动。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/gan2.jpg" alt="move"></p><p>《敢死队2》的“英雄成长史”，更确切地说是迟暮英雄们的“进化史”。看这部电影的观众，大部分是冲着史泰龙、施瓦辛格、尚格云顿这些肌肉猛男去的，这些 人当年带给大家的回忆实在太过美好，光是施瓦辛格这位前州长那一句“I’M BACK”就足以让很多人激动。但相比于前作，这次的“全球猛男大联盟”更显示出了一种“英雄迟暮”——打架的招式无非也就是那几招，所以猛男的出路只能 是耍宝玩幽默。这样虽然也算是一种进化，但老实说，耍嘴皮子还真不是他们的强项，就算是李连杰举起了平底锅变身灰太狼，要将《敢死队2》变成动作喜剧，也不是这些人的强项。</p><p>顺便送上1080p片源，请使用迅雷下载(复制打开迅雷即可)</p><p>magnet:?xt=urn:btih:8766f7b04f7668c4c806d8d6131a842808f16616</p>]]></content>
      
      
      <categories>
          
          <category> 新剧 · 电影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中两种跳转方式</title>
      <link href="/2020/04/13/Note/vue%E8%B7%B3%E8%BD%AC/"/>
      <url>/2020/04/13/Note/vue%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>读书忌死读,死读钻牛角。——叶圣陶</p><p>第一种：通过标签跳转，</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/link.png" alt="link"></p><p>第二种：通过js跳转，定义点击事件进行跳转</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/js1.png" alt="js1">)<img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/js2.png" alt="js2"></p><p>第三种：通过标签跳转，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;添加需要跳转的路由&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>如果想要新页面跳 不覆盖前一页面 可在a标签内加 target=”_blank”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;添加需要跳转的路由&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy</title>
      <link href="/2020/04/11/Blog/three/"/>
      <url>/2020/04/11/Blog/three/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Scrapy是用python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。使用Twisted高效异步网络框架来处理网络通信。"><a href="#Scrapy是用python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。使用Twisted高效异步网络框架来处理网络通信。" class="headerlink" title="Scrapy是用python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。使用Twisted高效异步网络框架来处理网络通信。"></a>Scrapy是用python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。使用Twisted高效异步网络框架来处理网络通信。</h3><h3 id="接下来我们说说scrapy的安装及其他"><a href="#接下来我们说说scrapy的安装及其他" class="headerlink" title="接下来我们说说scrapy的安装及其他"></a>接下来我们说说scrapy的安装及其他</h3><p>1.scrapy安装与环境</p><p>1.在安装scrapy前需要安装好相应的依赖库, 再安装scrapy, 具体安装步骤如下:<br>    (1).安装lxml库: pip install lxml </p><pre><code>(2).安装wheel: pip install wheel(3).安装twisted: pip install twisted文件路径(twisted需下载后本地安装,下载地址:http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted)(版本选择如下图,版本后面有解释,请根据自己实际选择)(4).安装pywin32: pip install pywin32(注意:以上安装步骤一定要确保每一步安装都成功,没有报错信息,如有报错自行百度解决)    (5).安装scrapy: pip install scrapy(注意:以上安装步骤一定要确保每一步安装都成功,没有报错信息,如有报错自行百度解决)   (6).成功验证:在cmd命令行输入scrapy,显示Scrapy1.6.0-no active project,证明安装成功 </code></pre><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/123.png" alt="环境"></p><p>2.scrapy了解</p><p>一、五大核心组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.引擎: 负责数据流传递, 各个组件之间的通信</span><br><span class="line">   2.spider: 定义了爬取的行为和数据解析</span><br><span class="line">   3.调度器: scheduler, 负责调度所有的请求</span><br><span class="line">   4.下载器: 负责发送网络请求, 返回响应数据</span><br><span class="line">   5.管道: item Pipeline ---&gt; item: 定义了要进行数据持久化的字段 ---&gt; pipeline: 与数据库进行交互, 将数据存储在数据库中</span><br></pre></td></tr></table></figure><p>二、scrapy框架的数据流:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spider --&gt;  引擎  --&gt;  调度器  --&gt;  引擎  --&gt;  下载器  --&gt;  互联网 --&gt;  下载器 --&gt;  引擎  --&gt;  spider  --&gt;  引擎  --&gt;  管道  --&gt;  入库</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/scrapy.png" alt="流程"></p><p>三、scrapy中间件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 中间件分类:  </span><br><span class="line">          </span><br><span class="line">- 下载中间件: DownloadMiddleware            </span><br><span class="line">- 爬虫中间件: SpiderMiddleware </span><br><span class="line"></span><br><span class="line"># 中间件的作用:                </span><br><span class="line">- 下载中间件: 拦截请求与响应, 篡改请求与响应                </span><br><span class="line">- 爬虫中间件: 拦截请求与响应, 拦截管道item, 篡改请求与响应, 处理item   </span><br><span class="line"></span><br><span class="line"># 下载中间件的主要方法:  </span><br><span class="line"></span><br><span class="line">process_request            </span><br><span class="line">process_response            </span><br><span class="line">process_exception</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结购物车优惠卷生成</title>
      <link href="/2020/04/10/Note/%E4%BC%98%E6%83%A0%E5%8D%B7/"/>
      <url>/2020/04/10/Note/%E4%BC%98%E6%83%A0%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>丘山积卑而为高,江河合水而为大。——庄子</p><hr><p>在最近的学习中我看到了这样的一份题 如下</p><p>有两个会员，都是普通用户，展示会员列表，后面加一个升级按钮，把一个会员升级为VIP会员，同时送两张优惠卷，一张是满10减5的优惠卷，一张是满20减10的优惠卷，<strong>优惠卷需求生成唯一的编码在优惠卷表中单独存储</strong>，并和用户关联。有两本书，“计算机基础“ 价格为20元库存为10，另外一本是“大学英语”价格为10，库存为10。展示图书列表，点击购买判断会员是否登录，如果登录了直接加入购物车，如果没登录，登录后加入购物车，加入购物车时需要判断库存，如果库存不足提示不能购买，展示购物车列表，购物车列表中展示所有购买的商品，所有商品总价格，实际支付价格，根据用户级别和商品总金额列出用户可以使用的优惠卷，普通用户没有可以不列出，VIP选择不同的优惠卷实际支付金额跟着动态变化。</p><h3 id="优惠卷需求生成唯一的编码"><a href="#优惠卷需求生成唯一的编码" class="headerlink" title="优惠卷需求生成唯一的编码"></a>优惠卷需求生成唯一的编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import string</span><br><span class="line"># 声明字符串区间</span><br><span class="line">code &#x3D; string.ascii_letters + string.digits</span><br><span class="line">def getCode():</span><br><span class="line">    return &#39;&#39;.join(random.sample(code,10))</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(getCode())</span><br></pre></td></tr></table></figure><p>这样生成的code每次都是不一样的</p><h3 id="String模块ascii-letters和digits"><a href="#String模块ascii-letters和digits" class="headerlink" title="String模块ascii_letters和digits"></a>String模块ascii_letters和digits</h3><p>Python3中String模块ascii_letters和digits方法，其中ascii_letters是生成所有字母，从a-z和A-Z,digits是生成所有数字0-9。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 相关</title>
      <link href="/2020/04/10/Blog/two/"/>
      <url>/2020/04/10/Blog/two/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Git-相关操作"><a href="#Git-相关操作" class="headerlink" title="Git 相关操作"></a>Git 相关操作</h3><hr><p>1、git清空密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><p>2、git保存密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>3、没有加入暂存区 后退一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout</span><br></pre></td></tr></table></figure><p>4、加入暂存区 后退一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><p>5、查看提交日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>6、返回相对应的日志号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard + git log 中的日志号</span><br></pre></td></tr></table></figure><p>7、设置国内源 and 查看原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry https:&#x2F;&#x2F;registry.npm.taobao.orgnpm config list</span><br></pre></td></tr></table></figure><p>8、查看当前git分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>9、拉取Git项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>10、素质三联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -Agit commit -m &quot;&quot;git push -u origin master</span><br></pre></td></tr></table></figure><hr><h3 id="一、版本控制系统"><a href="#一、版本控制系统" class="headerlink" title="一、版本控制系统"></a>一、版本控制系统</h3><hr><p>1、意义 记录文件内容变化，以便将来查阅特定版本修订情况的系统 可以讲文件回溯到某个修改之前的状态。 版本控制不仅对源码做控制，可以对任意类型文件进行版本控制</p><p>2、常用的版本工具 CVS SVN Git-分布式 首先安装 文本编辑器软件，使用notepad++ 作为文本编辑器</p><p>3、git本地版本管理</p><h2 id="4、git本地仓库与远程仓库通信"><a href="#4、git本地仓库与远程仓库通信" class="headerlink" title="4、git本地仓库与远程仓库通信"></a>4、git本地仓库与远程仓库通信</h2><h3 id="二、git本地版本管理"><a href="#二、git本地版本管理" class="headerlink" title="二、git本地版本管理"></a>二、git本地版本管理</h3><hr><p>1、配置我们的身份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><p>2、初始化一个git仓库 选择一个文件夹 作为我们的仓库 然后初始化它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>3、查看git当前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>我们目录下的文件 有两种状态： 未追踪untracked文件 已追踪tracked文件 已追踪 表示 这个文件已经添加到git仓库中 未追踪 表示 文件还没有添加到仓库中</p><p>4、添加未追踪的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件</span><br></pre></td></tr></table></figure><p>5、把 add的文件 进行commit提交 添加到仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit </span><br><span class="line">git commit -m &quot;提交的说明&quot; 不会打开文本编辑器</span><br></pre></td></tr></table></figure><p>总结：一个新文件 要先 add 在 commit 两步才能提交到仓库</p><p>6、忽略文件</p><p>项目中 不是所有的文件 都需要追踪的，比如一些临时文件，日志就不用追踪</p><p>因此我们可以写一个.gitingore文件</p><p>7、我们的git可以分为三个区域</p><p>工作区：我们从仓库中 提取某个版本 作为工作内容，对文件可以修改、删除等操作</p><p>暂存区：工作区中的文件内容发生改变，我们要把这个改变先保存起来，放到暂存区 等待提交</p><p>仓库区：所有的已经提交commit的数据</p><p>如果一个被追踪的文件 发生了修改则操作过程：</p><p>第一、git add 文件/* 会把文件从工作区 拷贝一份 放到暂存区</p><p>第二、git commit 文件 会把暂存区存放的所有文件 都提交到仓库</p><hr><h3 id="三、本地仓库与-远程仓库"><a href="#三、本地仓库与-远程仓库" class="headerlink" title="三、本地仓库与 远程仓库"></a>三、本地仓库与 远程仓库</h3><hr><p>1、从远程仓库 clone 到本地</p><p>这个过程 会自动把远程仓库的所有内容 都拷贝一份到本地，并生成创建一个对应的本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 链接</span><br></pre></td></tr></table></figure><p>本地仓库名默认就是 bookweb</p><p>2、推送项目到远程仓库</p><p>git push 推送 推送本地仓库内容 到远程仓库</p><p>3、push的时候因为要 登录远程仓库，所有需要认证</p><p>第一次的时候需要你输入 github的 账号 密码</p><p>我们在输入完以后可以通过 命令</p><p>①设置记住密码（默认15分钟）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure><p>②如果想自己设置时间，可以这样做(1小时后失效)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper &#39;cache --timeout&#x3D;3600&#39;</span><br></pre></td></tr></table></figure><p>③长期存储密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>4、代码冲突的问题</p><p>想在开发都是 团队协同开发有可能多人同时修改了文件中的某一处</p><p>解决冲突： 第一步 首先要先 git pull 先把远程的新的提交 拉过来，到本地仓库。</p><p>5、标签tag 了解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个提交版本 添加 标签  用来表示该提交git tag -a 标签名  -m &quot;描述标签&quot;git tag -a v1 -m &quot;版本1&quot;</span><br></pre></td></tr></table></figure><p>6、git分支</p><p>查看分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>创建分支 <code>git branch 分支名</code> 切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支</span><br></pre></td></tr></table></figure><p>合并分支：</p><p>注意 谁合并谁 先切换到谁<br>master要合并dev 先切换到master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout mastergit merge dev</span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Go Lang+Hugo搭建自己的技术博客与gitee部署</title>
      <link href="/2020/04/09/Blog/one/"/>
      <url>/2020/04/09/Blog/one/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="GoLang"><a href="#GoLang" class="headerlink" title="GoLang"></a>GoLang</h3><p>一、Go了解</p><p>Go 语言起源 2007 年，并于 2009 年正式对外发布，该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范 简单说，Golang是Google主导，背后由一群大牛的操刀设计的新时代编程语言，虽然比较年轻，但是前景还是非常明朗的。</p><p>二、优点 1、简单，容易上手 2、自带高效的GC机制 3、性能高 4、并发编程 5、资源占用低</p><hr><h3 id="Hugo"><a href="#Hugo" class="headerlink" title="Hugo"></a>Hugo</h3><p>1、Hugo 是基于 Go 语言的静态网站生成器。，编译后只有一个二进制文件，不用安装任何依赖，这一点让人很舒服。</p><p>2、适用于搭建个人blog、公司主页、help等网站，是一种小型的CMS系统。静态站点的好处就是快速、安全、易于部署，方便管理</p><p>3、优点： 得益于Go的高性能，性能很快<br>世界上最快的静态网站生成工具，5秒生成6000个页面 文档为Markdown格式,语法超简单 Hugo 可以做静态文件生成工具，还是高性能web 服务； 丰富的站点迁移工具，可以将wordpress，Ghost，Jekyll，DokuWiki，Blogger轻松迁移至 Hugo 超详细的文档 活跃的社区 更加自由的内容组织方式 丰富的主题模板，可以让你的网站更加炫目多彩 多环境支持：macos ，linux，windows</p><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>至于如何安装Hugo，如何搭建网站，网络上也有不少的教程，这里也不再叙述了，自己写出来的未必有官方文档那样详细，所以建议看官方文档。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgohugo.io%2Fdocumentation%2F" target="_blank" rel="noopener">https://gohugo.io/documentation/</a></p><p>首先，可以去go的官网网站下载安装包 <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> 然后直接双击安装即可，不需要配置环境变量，因为安装过程自动配置，安装完毕后，打开命令行，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br><span class="line">go version go1.14.1 windows&#x2F;amd64</span><br></pre></td></tr></table></figure><p>显示主版本号即表示安装成功</p><p>然后，可以进行hugo的在线源码编译安装，打开命令行，输入下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com&#x2F;spf13&#x2F;hugogo build -o hugo main.gomv hugo $GOPATH&#x2F;bin</span><br></pre></td></tr></table></figure><p>如果你不想在线编译安装，也可以去hugo的官网 <a href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener">https://github.com/gohugoio/hugo/releases</a> 下载稳定版的压缩包，解压之后配置一下环境变量也可以</p><p>装完以后，在命令行内输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hugo version</span><br><span class="line">Hugo Static Site Generator v0.68.3-157669A0 windows&#x2F;amd64 BuildDate: 2020-03-24T12:04:36Z</span><br></pre></td></tr></table></figure><p>打印出版本号即表示hugo安装成功</p><p>在命令行中输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site hugo_blog</span><br></pre></td></tr></table></figure><p>就生成了一个名字为hugo_blog的新站点，可以感受到速度非常快，和vue.js创建新站点的速度比起来简直天差地别</p><p>创建网站后，需要下载主题，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.gohugo.org%2Ftheme%2F" target="_blank" rel="noopener">https://www.gohugo.org/theme/</a></p><p>如果本地网站目录中没有<code>themes</code>目录的话，自己创建一个，然后下载主题到该目录内。</p><p>我个人使用的主题是<a href="https://github.com/liuzc/LeaveIt" target="_blank" rel="noopener">https://github.com/liuzc/LeaveIt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd themesgit clone https:&#x2F;&#x2F;github.com&#x2F;liuzc&#x2F;LeaveIt</span><br></pre></td></tr></table></figure><p>一般来说，下载的主题都会自带一个配置样例的，具体的配置参考样例即可。或者可以参考下面这个配置样例： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgohugoio%2Fhugo%2Fblob%2Fmaster%2Fdocs%2Fconfig.toml" target="_blank" rel="noopener">https://github.com/gohugoio/hugo/blob/master/docs/config.toml</a></p><p>编译： 进入站点根目录，然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo</span><br></pre></td></tr></table></figure><p>没错，只要输入命令回车即可，都不用带什么参数就可以生成网站的静态文件，并存放在<code>public</code>文件夹中，非常简单。</p><p>之后就非常简单了</p><hr><h3 id="使用Gitee-Page发布网站"><a href="#使用Gitee-Page发布网站" class="headerlink" title="使用Gitee Page发布网站"></a>使用Gitee Page发布网站</h3><p>我使用的是gitee，你们也可以使用Github</p><p>进入gitee <a href="https://gitee.com/之后创建之间的仓库" target="_blank" rel="noopener">https://gitee.com/之后创建之间的仓库</a></p><p>之后打开命令行，进入<code>public</code>文件中,根据gitee的提示进行操作连接自己的数据库</p><p>最后进入自己的仓库找到服务，点击<code>Gitee Page</code>进行部署，你就有了属于自己的技术博客</p>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Hugo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像安装与启动</title>
      <link href="/2020/04/08/Note/docker%E9%95%9C%E5%83%8F/"/>
      <url>/2020/04/08/Note/docker%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>取得成就时<strong>坚持不懈</strong>，要比遭到失败时顽强不屈更重要。——拉罗科</p><hr><h3 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><p>1、Web 应用的自动化打包和发布。</p><p>2、自动化测试和持续集成、发布。</p><p>3、在服务型环境中部署和调整数据库或其他的后台应用。</p><p>4、从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p><h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h4 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h4><h4 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h4><h4 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h4><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>Docker 官网: <a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com</a></p><p>Github Docker 源码：<a href="https://github.com/docker/docker-ce" target="_blank" rel="noopener">https://github.com/docker/docker-ce</a></p><hr><h3 id="Docker-安装（win10）"><a href="#Docker-安装（win10）" class="headerlink" title="Docker 安装（win10）"></a>Docker 安装（win10）</h3><p>Win10 系统</p><p>现在 Docker 有专门的 Win10 专业版系统的安装包，需要开启Hyper-V。</p><p>开启 Hyper-V</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/hyper1.png" alt="hyper1">)<img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/hyper2.png" alt="hyper2">)<img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/hyper3.png" alt="hyper3">)<img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/hyper4.png" alt="hyper4"></p><h3 id="下载Docker"><a href="#下载Docker" class="headerlink" title="下载Docker"></a>下载Docker</h3><p>一般情况下，我们可以从Docker官网下载docker安装文件，但是官方网站由于众所周知的原因，不是访问慢，就是下载慢。下载docker安装包动不动就要个把小时，真是极大的影响工作效率。</p><p>在这里推荐一个docker的下载（主要是Windows版）地址：</p><p><a href="https://oomake.com/download/docker-windows" target="_blank" rel="noopener">https://oomake.com/download/docker-windows</a></p><p><a href="http://get.daocloud.io/" target="_blank" rel="noopener">http://get.daocloud.io</a></p><h3 id="安装Docker-Toolbox"><a href="#安装Docker-Toolbox" class="headerlink" title="安装Docker Toolbox"></a>安装Docker Toolbox</h3><p>在这一步，你将安装Docker Toolbox。安装后你的系统将会安装以下几个软件：</p><p>Windows版的Docker客户端</p><p>Docker Toolbox管理工具和ISO镜像</p><p>Oracle VM Virtualbox</p><p>Git MSYS-git Unix 工具</p><p>如果你的电脑已经安装了Virtualbox，那么不需要再重新安装Oracle VM Virtualbox，在安装的时候取消勾选就可以了</p><p>Ps:如果你的Virtual box正在运行，那么要先关闭掉它然后再重新运行安装</p><ol><li>打开Docker Toolbox页面</li><li>点击installer链接进行下载</li><li>双击安装包进行安装Docker Toolbox</li><li>点击下一步，进行安装就可以了</li></ol><p>安装完成</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/docker1.png" alt="docker1"></p><h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><p>双击Docker Quickstart Terminal图标，启动一个终端</p><p>第一次启动的话你会看到命令行会输出一些东西，等待一下，它会配置Docker Toolbox，之后，当它完成后，你会看到启动成功的画面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/docker2.png" alt="docker2"></p><p><strong>启动成功</strong></p>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典之keys()、values()和 items()方法</title>
      <link href="/2020/04/08/Blog/six/"/>
      <url>/2020/04/08/Blog/six/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="字典有3个方法，他们返回类似的列表值，分别对应于字典的键，值和键值对：keys-、values-和item-。"><a href="#字典有3个方法，他们返回类似的列表值，分别对应于字典的键，值和键值对：keys-、values-和item-。" class="headerlink" title="字典有3个方法，他们返回类似的列表值，分别对应于字典的键，值和键值对：keys()、values()和item()。"></a>字典有3个方法，他们返回类似的列表值，分别对应于字典的键，值和键值对：keys()、values()和item()。</h2><h2 id="这些方法返回的值不是真正的列表，它们不能被修改，没有append-方法。但这些数据类型可以用于for循环。"><a href="#这些方法返回的值不是真正的列表，它们不能被修改，没有append-方法。但这些数据类型可以用于for循环。" class="headerlink" title="这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型可以用于for循环。"></a>这些方法返回的值不是真正的列表，它们不能被修改，没有append()方法。但这些数据类型可以用于for循环。</h2><p>values()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spam &#x3D; &#123;&#39;color&#39;:&#39;red&#39;,&#39;age&#39;:18&#125;</span><br><span class="line"></span><br><span class="line">for item in spam.values(): </span><br><span class="line"></span><br><span class="line">    print(item)  # red 18  取的是值</span><br></pre></td></tr></table></figure><p>keys()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spam &#x3D; &#123;&#39;color&#39;:&#39;red&#39;,&#39;age&#39;:18&#125;</span><br><span class="line"></span><br><span class="line">for item2 in spam.keys():    </span><br><span class="line"></span><br><span class="line">    print(item2)  # color age  取的时键</span><br></pre></td></tr></table></figure><p>items()方法 这个方法最特别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单个参数</span><br><span class="line"></span><br><span class="line">spam &#x3D; &#123;&#39;color&#39;:&#39;red&#39;,&#39;age&#39;:18&#125;</span><br><span class="line"></span><br><span class="line">for item1 in spam.items():</span><br><span class="line">    print(item1)  # (&#39;color&#39;, &#39;red&#39;)(&#39;age&#39;, 18) items 元组的形式  取出键 值对</span><br><span class="line">    </span><br><span class="line">两个参数</span><br><span class="line"></span><br><span class="line">spam &#x3D; &#123;&#39;color&#39;:&#39;red&#39;,&#39;age&#39;:18&#125;</span><br><span class="line"></span><br><span class="line">for k,v in spam.items():   </span><br><span class="line"></span><br><span class="line">    print(k,v)   # color red age 18   若有两个参数则将key 与 value 单独去取</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结Vue自定义过滤器</title>
      <link href="/2020/04/08/Note/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/04/08/Note/%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><p>有的时候，有些数据是半动态的，即数据的一部分是变化的，一部分是固定不变或者也可能能动态，但是这种动态是相对比较少的。那么我可以使用过滤器来对数据进行一步优化过滤。在vue中提供了Vue.filter(‘flterName’,fn)来定义一个过滤器，过滤器可以在HTML代码中使用，如对动态拿到的数据进行过滤，</p><hr><p>1.定义过滤器</p><p>第一个参数是过滤器的名字</p><p>第二个参数是过滤器的功能函数。如果不定义，vue也不知道你这个字符串是什么，有什么作用。</p><p>2.过滤器功能函数</p><p>第一个参数是传入的要过滤数据，即原数据。</p><p>第二个参数开始就是html调用过滤器的时候传入的参数。</p><h4 id="错误运用过滤器"><a href="#错误运用过滤器" class="headerlink" title="错误运用过滤器"></a>错误运用过滤器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  &#x2F;&#x2F; 自定用户义方法</span><br><span class="line">  user_filter(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过key(用户id)取用户名</span><br><span class="line">    return this.myuser[value]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="正确使用过滤器"><a href="#正确使用过滤器" class="headerlink" title="正确使用过滤器"></a>正确使用过滤器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  &#x2F;&#x2F; 自定用户义方法</span><br><span class="line">  user_filter(value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过key(用户id)取用户名</span><br><span class="line">    return window.that.myuser[value]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 · 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEY UI 与 智能输入框</title>
      <link href="/2020/04/07/Blog/five/"/>
      <url>/2020/04/07/Blog/five/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="关于HeyUI"><a href="#关于HeyUI" class="headerlink" title="关于HeyUI"></a>关于HeyUI</h3><p>HeyUI 是一套基于 Vue2.0 的开源 UI 组件库，主要服务于一些中后台产品。</p><hr><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>HeyUI提供的是一整套解决方案，所有的组件提供全局的可配置模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">●真正的数据驱动</span><br><span class="line"></span><br><span class="line">●全局的配置模式</span><br><span class="line"></span><br><span class="line">●数据字典化</span><br></pre></td></tr></table></figure><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>推荐使用 npm 的方式安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install heyui</span><br></pre></td></tr></table></figure><hr><h3 id="支持环境"><a href="#支持环境" class="headerlink" title="支持环境"></a>支持环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现代浏览器和 IE9 及以上。</span><br></pre></td></tr></table></figure><hr><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeyUI支持 Vue.js 2.x版本</span><br></pre></td></tr></table></figure><hr><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">○ https:&#x2F;&#x2F;vuejs.org&#x2F;Vue (官方文档)</span><br><span class="line"></span><br><span class="line">○ https:&#x2F;&#x2F;github.com&#x2F;heyui&#x2F;hey-cli (Hey-Cli脚手架)</span><br><span class="line"></span><br><span class="line">○ https:&#x2F;&#x2F;admin.heyui.top&#x2F; (官方demo)</span><br></pre></td></tr></table></figure><hr><h2 id="智能搜索-AutoComplete-模糊匹配"><a href="#智能搜索-AutoComplete-模糊匹配" class="headerlink" title="智能搜索(AutoComplete 模糊匹配)"></a>智能搜索(AutoComplete 模糊匹配)</h2><h3 id="异步数据请求"><a href="#异步数据请求" class="headerlink" title="异步数据请求"></a>异步数据请求</h3><p>autocomplete有三种数据类型：key,title,object，如果需求更复杂，请监听change事件手动处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;value:&#123;&#123;value&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div v-width&#x3D;&quot;300&quot;&gt;&lt;AutoComplete :option&#x3D;&quot;param&quot; v-model&#x3D;&quot;value&quot; @change&#x3D;&quot;onChange&quot; type&#x3D;&quot;title&quot;&gt;&lt;&#x2F;AutoComplete&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import jsonp from &#39;fetch-jsonp&#39;;</span><br><span class="line">const loadData &#x3D; function (filter, callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; this 为 option 配置</span><br><span class="line">  &#x2F;&#x2F; this.orgId 使用传递的参数获取数据，例：搜索某公司下的员工</span><br><span class="line">  jsonp(&#96;https:&#x2F;&#x2F;suggest.taobao.com&#x2F;sug?code&#x3D;utf-8&amp;q&#x3D;$&#123;filter&#125;&#96;)</span><br><span class="line">    .then(response &#x3D;&gt; response.json())</span><br><span class="line">    .then((d) &#x3D;&gt; &#123;</span><br><span class="line">      callback(d.result.map((r) &#x3D;&gt; &#123;</span><br><span class="line">        return r[0];</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: &#39;测试&#39;,</span><br><span class="line">      param: &#123;</span><br><span class="line">        orgId: 1, &#x2F;&#x2F; 自定义参数传递</span><br><span class="line">        loadData,</span><br><span class="line">        minWord: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onChange(data, trigger) &#123;</span><br><span class="line">      console.log(data, trigger);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> HEY UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟环境的下载操作</title>
      <link href="/2020/04/06/Blog/four/"/>
      <url>/2020/04/06/Blog/four/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="下载虚拟环境控制器"><a href="#下载虚拟环境控制器" class="headerlink" title="下载虚拟环境控制器"></a>下载虚拟环境控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenvwrapper-win -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv  +name</span><br></pre></td></tr></table></figure><h3 id="切换虚拟环境"><a href="#切换虚拟环境" class="headerlink" title="切换虚拟环境"></a>切换虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Workon +name</span><br></pre></td></tr></table></figure><h3 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip install +name(包名称)</span><br></pre></td></tr></table></figure><h3 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip uninstall +name(包名称)</span><br></pre></td></tr></table></figure><h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rmvirtualenv +name</span><br></pre></td></tr></table></figure><h3 id="导出当前环境所有包"><a href="#导出当前环境所有包" class="headerlink" title="导出当前环境所有包"></a>导出当前环境所有包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip freeze &gt; requirements.txt（&gt;&gt; 追加）</span><br></pre></td></tr></table></figure><h3 id="批量下载包"><a href="#批量下载包" class="headerlink" title="批量下载包"></a>批量下载包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip install -r  requirements.txt（路径）</span><br></pre></td></tr></table></figure><h3 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_+name</span><br></pre></td></tr></table></figure><h3 id="查看安装的所有虚拟环境"><a href="#查看安装的所有虚拟环境" class="headerlink" title="查看安装的所有虚拟环境"></a>查看安装的所有虚拟环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsvirtualenv</span><br></pre></td></tr></table></figure><h3 id="查看当前环境所有包"><a href="#查看当前环境所有包" class="headerlink" title="查看当前环境所有包"></a>查看当前环境所有包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pip list</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 · 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
