<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汪小白</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sirxs.cn/"/>
  <updated>2020-07-22T01:54:22.009Z</updated>
  <id>http://www.sirxs.cn/</id>
  
  <author>
    <name>汪小白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在阿里云Centos上配置Nginx+uwsgi+负载均衡配置</title>
    <link href="http://www.sirxs.cn/2020/07/22/Note/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://www.sirxs.cn/2020/07/22/Note/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-07-22T00:00:00.000Z</published>
    <updated>2020-07-22T01:54:22.009Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>负载均衡的目的是为了解决单个节点压力过大，造成Web服务响应过慢，严重的情况下导致服务瘫痪，无法正常提供服务。<strong>春节期间在12306网站上买过火车票的朋友应该深有体会，有时查询一张火车票都会很慢，甚至整个网页都卡住不动了。通常一个访问量非常大的Web网站（比如：淘宝、京东、12306等），由于一个Web服务同时能处理的用户并发请求的数量有限，同时还有机器故障的情况，所以一个Web站点通常会在N台机器上各部署一套同样的程序。当某一个服务挂掉的时候，还有第二个、第三个、第N个服务。。。继续为用户提供服务，给用户的感觉，你的服务还在正常的运行！</strong>在这些提供同样服务的机器当中，在硬件配置方面也各不一样，这样就会存在部份机器性能非常好，能快速计算并响应用户的请求，另外一部份机器可能配置差点，响应用户的请求的时间会长一些。这就需要我们思考一个问题？如果有一个服务正在同时处理1000个用户的请求，这个服务的上限可能最多能同时处理1000个用户的请求，这时它已经很忙了，如果此时又有一个新请求过来，我们仍然把这个请求分配给这台机器，这时候这个请求就只能在干等着，等这个服务处理完那些请求后，再继续处理它。这样在浏览器中的反应就像12306我们在春节买票一样，卡在那不动了，让用户眼巴巴的干着急。而能提供同样服务的其它机器，这时确很空闲。这样不仅是对服务器资源的浪费，也充分发挥不出弄多台服务器装同一个服务的最高价值。我们通常称对某一台机器的访问量称为负载量，如何将一个用户的请求，合理的分配到一台能快速响应用户请求的服务器上，我们就需要用到一些负载策略。也就体现出了文章主题的用意了：<strong>负载均衡，将用户的所有HTTP请求均衡的分配到每一台机器上，充分发挥所有机器的性能，提高服务的质量和用户体验。负载均衡可以通过负载均衡网络硬件设备和Web服务器软件来实现，前者设备成本较高，小公司通常负担不起，所以后者一般是我们的首选</strong>。<em>实现负载均衡常用的Web服务器软件有Nginx、HAProxy、LVS、Apache，本文主要介绍Nginx的负载均衡策略，至于Nginx是干嘛的，自行百度。</em></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>言归正传，关于在阿里云Centos上配置Nginx+uwsgi+负载均衡配置</strong>，网上一查一大堆，主要内容那是千篇一律</p><ol><li><p>先上张图，了解什么是nginx负载均衡</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/fuzai1.png" alt="fuzai"></p></li><li><p>其实配置起来非常简单，利用wsgi在不同端口上起两个服务，然后修改ngin网站配置，命令如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure></li><li><p>将原来的uwsgi_pass注释，改为变量进行绑定</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>      /root/myweb_access.log;</span><br><span class="line">    <span class="attribute">error_log</span>       /root/myweb_error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">75M</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">include</span> uwsgi_params;</span><br><span class="line">        <span class="comment">#uwsgi_pass 127.0.0.1:8000;</span></span><br><span class="line">        <span class="attribute">uwsgi_pass</span> mytest;</span><br><span class="line">        <span class="attribute">uwsgi_param</span> UWSGI_SCRIPT mypro.wsgi;</span><br><span class="line">        <span class="attribute">uwsgi_param</span> UWSGI_CHDIR  /root/mypro;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="attribute">alias</span> /root/mypro/static;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之后修改主配置文件，在http配置内添加负载均衡配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vim</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> mytest &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8002</span>;  <span class="comment">#负载均衡服务器群</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8003</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后重启服务即可</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl</span> restart nginx.service</span><br></pre></td></tr></table></figure></li></ol><h3 id="内置负载均衡策略"><a href="#内置负载均衡策略" class="headerlink" title="内置负载均衡策略"></a>内置负载均衡策略</h3><p><strong>来源于网络</strong></p><p>Nginx负载均衡是通过upstream模块来实现的，内置实现了三种负载策略，配置还是比较简单的。官网负载均衡配置说明：<a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/load_balancing.html</a></p><ul><li>轮循（默认）<br>Nginx根据请求次数，将每个请求均匀分配到每台服务器</li><li>最少连接<br>将请求分配给连接数最少的服务器。Nginx会统计哪些服务器的连接数最少。</li><li>IP Hash<br>绑定处理请求的服务器。第一次请求时，根据该客户端的IP算出一个HASH值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过HASH算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。</li></ul><ol><li><p>轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backserver &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.14</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>weight</p><p>默认为1，将请求平均分配给每台server</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span>;  <span class="comment"># 2/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;  <span class="comment"># 3/6次</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;  <span class="comment"># 1/6次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例配置，表示6次请求中，100分配2次，101分配3次，102分配1次</p></li><li><p>max_fails</p><p>默认为1。某台Server允许请求失败的次数，超过最大次数后，在fail_timeout时间内，新的请求将不会分配给这台机器。如果设置为0，Nginx会将这台Server置为永久无效状态，然后将请求发给定义了proxy_next_upstream, fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, and memcached_next_upstream指令来处理这次错误的请求。</p></li><li><p>fail_timeout</p><p>默认为10秒。某台Server达到max_fails次失败请求后，在fail_timeout期间内，nginx会认为这台Server暂时不可用，不会将请求分配给它</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>192.168.0.100这台机器，如果有3次请求失败，nginx在15秒内，不会将新的请求分配给它。</p></li><li><p>backup备份机，所有服务器挂了之后才会生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> weight=<span class="number">3</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   在100和101都挂了之前，102为不可用状态，不会将请求分配给它。只有当100和101都挂了，102才会被启用。</p><ol start="6"><li><p>down</p><p>标识某一台server不可用。可能能通过某些参数动态的激活它吧，要不真没啥用。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> weight=<span class="number">2</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">15</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span> down;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   表示101这台Server为无效状态，不会将请求分配给它。</p><ol start="7"><li><p>max_conns</p><p>限制分配给某台Server处理的最大连接数量，超过这个数量，将不会分配新的连接给它。默认为0，表示不限制。注意：1.5.9之后的版本才有这个配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span> max_conns=<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示最多给100这台Server分配1000个请求，如果这台Server正在处理1000个请求，nginx将不会分配新的请求给到它。假如有一个请求处理完了，还剩下999个请求在处理，这时nginx也会将新的请求分配给它。</p></li><li><p>resolve</p><p>将server指令配置的域名，指定域名解析服务器。需要在http模块下配置resolver指令，指定域名解析服务</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">resolver</span> <span class="number">10.0.0.1</span>;</span><br><span class="line">    <span class="attribute">upstream</span> u &#123;</span><br><span class="line">        <span class="attribute">zone</span> ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">server</span> example.com resolve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="第三方负载策略"><a href="#第三方负载策略" class="headerlink" title="第三方负载策略"></a>第三方负载策略</h3><p><strong>来源于网络</strong></p><ol><li><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>根据服务器的响应时间来分配请求，响应时间短的优先分配，即负载压力小的优先会分配。</p><p>由于fair模块是第三方提供的，所以在编译nginx源码的时候，需要将fair添加到nginx模块中。</p><p><code>假设我的nginx是通过源码安装的，安装在/opt/nginx目录下，而且安装时没有添加fair模块</code></p><ul><li><p>下载fair模块<a href="https://github.com/xyang0917/nginx-upstream-fair" target="_blank" rel="noopener">源码</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /opt</span><br><span class="line">wget https://github.com/xyang0917/nginx-upstream-fair/archive/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure><p><strong>解压后的目录名为：nginx-upstream-fair-master</strong></p></li><li><p>重新编译nginx，将fair模块添加到编译参数，我的nginx源码目录在/opt/nginx-1.10.0</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span> /opt/nginx-nginx-<span class="number">1</span>.<span class="number">10</span>.<span class="number">0</span></span><br><span class="line">./configure --prefix=/opt/nginx --add-module=/opt/nginx-upstream-fair-master</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>不要执行make install，这样会覆盖之前nginx的配置</p></li><li><p>将新编译的nginx可执行程序拷贝到/opt/nginx/sbin/目录下，覆盖之前安装的nginx，编译后的nginx执行程序，放在nginx源码的objs目录下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ps</span> -aux | grep nginx</span><br><span class="line">kill -<span class="number">9</span> nginx进程ID  <span class="comment"># 停止nginx服务</span></span><br><span class="line">cp /opt/nginx-<span class="number">1</span>.<span class="number">10</span>.<span class="number">0</span>/objs/nginx /opt/nginx/sbin/  <span class="comment"># 覆盖旧的nginx</span></span><br><span class="line">nginx <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure></li><li><p>配置使用fair负载策略模块</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    fair;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于采用fair负载策略，配置weigth参数改变负载权重将无效。</strong></p></li></ul></li><li><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按请求url的hash结果来分配请求，使每个url定向到同一个后端服务器，服务器做缓存时比较有效。</p><p>1.7.2版本以后，url_hash模块已经集成到了nginx源码当中，不需要单独安装。之前的版本仍需要单独安装，<a href="https://github.com/evanmiller/nginx_upstream_hash" target="_blank" rel="noopener">下载地址</a><br>安装方法和fair模块一样，先下载url_hash源码，然后重新编译nginx源码，将url_hash模块添加到编译配置参数当中，最后将编译后生成的nginx二进制文件替换之前安装的nginx二进制文件即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> tomcats &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.100:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.102:8080</span>;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Nginx" scheme="http://www.sirxs.cn/tags/Nginx/"/>
    
      <category term="Centos" scheme="http://www.sirxs.cn/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>利用DockerHub在Centos7.6环境下部署Nginx反向代理Gunicorn+Flask独立架构</title>
    <link href="http://www.sirxs.cn/2020/07/21/Blog/aliyun%E9%83%A8%E7%BD%B2flask/"/>
    <id>http://www.sirxs.cn/2020/07/21/Blog/aliyun%E9%83%A8%E7%BD%B2flask/</id>
    <published>2020-07-21T00:00:00.000Z</published>
    <updated>2020-07-20T23:35:18.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>书接上回，上回说到</strong>，<a href="https://www.sirxs.cn/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/">在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</a>，今天我们来讲一讲利用DockerHub在Centos7.6环境下部署Nginx反向代理Gunicorn+Flask独立架构</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li><p>首先你需要有自己的云服务。我推荐白嫖</p><p><a href="https://free.aliyun.com/?spm=5176.14145661.J_3598540520.ace-channel-latest-activity-card.3eb418759BoljH" target="_blank" rel="noopener">https://free.aliyun.com/?spm=5176.14145661.J_3598540520.ace-channel-latest-activity-card.3eb418759BoljH</a></p><p>阿里云白嫖服务器</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu.png" alt="docker"></p></li><li><p>其次你需要将本地项目<code>push</code>到DockerHub(仓库)</p><ul><li><p>首先激活账号，创建仓库</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu1.png" alt="docker"></p><p><strong>这里的创建仓库与Github类似</strong></p></li><li><p>填写仓库信息具体为仓库名称、描述以及是否公开或者私有。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu2.png" alt="docker"></p></li><li><p>创建成功之后，它就会出现在镜像列表中</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu3.png" alt="docker"></p></li></ul></li><li><p>此时我们需要对本地的镜像重命名，这里重命名为herosir/flask_back。因为要与dockerhub上的仓库对应。如果名称不对应是无法将本地镜像push到线上仓库中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag myflask herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>结果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu4.png" alt="docker"></p></li><li><p>之后在命令行输入命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li><p>用DockerHub的账号和密码登录</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu5.png" alt="docker"></p></li><li><p>登录成功之后，用命令把本地镜像push到DockerHub中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>注意这里的镜像名称必须和hub中的仓库名称一致，否则将会抛出错误。</p></li><li><p>上传成功后，就可以在DockerHub中看到它了，此时就能随意pull操作了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu6.png" alt="docker"></p></li></ol><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol><li><p>前置操作已经完毕，此时，登录你的云服务器，这里以阿里云的Centos7.6为例子，进入服务器后安装Docker服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#升级yum</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#卸载旧版本docker</span></span><br><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment">#设置源</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum makecache fast</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>安装完成后输入 docker -v</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu7.png" alt="docker"></p><p><em>返回Docker版本号说明没有问题</em></p></li><li><p>拉取我们之前打包并且上传到hub的Flask镜像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>下载成功后，会展示在镜像库里</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu8.png" alt="docker"></p></li><li><p>运行项目，这里我们可以采用后台守护进程的模式起服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> --name testflask herosir/flask_back</span><br></pre></td></tr></table></figure></li><li><p>使用docker ps命令可以看到是否运行成功。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu9.png" alt="docker"></p></li><li><p>使用服务器的ip访问一下Flask服务，这里有个小坑，不论是腾讯云、阿里云还是百度云亦或是各种乱七八糟的云，都需要在安全组策略中开放你需要访问的端口，比如这里我用的阿里云。</p><ul><li><p>解决安群组策略</p></li><li><p>找到服务器的<code>配置规则</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu10.png" alt="docker"></p></li><li><p><code>手动添加</code>下图信息</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu11.png" alt="docker"></p></li></ul></li><li><p>设置完成之后通过服务器<code>公网IP</code>进行访问</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu12.png" alt="docker"></p><p>OK，访问没有问题</p></li><li><p>接下来，我们同样利用Docker来安装Nginx服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>随后启动Nginx测试一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure><ul><li><p>这里也需要设置安群组</p><p>操作同上，内容如下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu13.png" alt="docker"></p></li></ul></li><li><p>直接访问<code>公网IP</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu14.png" alt="docker"></p></li><li><p>现在，我们将运行Nginx容器里的配置文件copy到宿主机里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:/etc/nginx/conf.d/default.conf /root/default.conf</span><br></pre></td></tr></table></figure><p><strong>前面是容器的路径 后面是宿主机的路径</strong></p><p><em>容器id可以通过docker ps命令查看</em></p></li><li><p>复制出来之后，输入命令修改这个nginx配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/default.conf</span><br></pre></td></tr></table></figure></li><li><p>将Gunicorn配置加到里面(<strong>更改</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    listen  [::]:<span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://你的服务器公网IP:<span class="number">5000</span>; <span class="comment"># 这里是指向 gunicorn host 的服务地址</span></span><br><span class="line"></span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改完配置文件之后，关掉运行的nginx服务容器，并且删掉它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器id</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li><li><p>随后再次启动Nginx容器，不过这次和上次不同之处就是需要用到 -v 进行挂载了，挂载简单理解就是将宿主机的文件替换Docker容器内部的文件，达到修改的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d -p <span class="number">80</span>:<span class="number">80</span> -v /root/default.conf:/etc/nginx/conf.d/default.conf nginx</span><br></pre></td></tr></table></figure><p><strong>这里-v参数也遵循冒号左侧为宿主机右侧为容器的原则。</strong></p></li><li><p>新启动成功后，访问服务器ip</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/aliyunbu15.png" alt="docker"></p><p><strong>OK，部署完成</strong></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>部署完成，轻松且愉快</p><p>最后Dockerhub地址：<a href="https://hub.docker.com/r/herosir/flask_back" target="_blank" rel="noopener">https://hub.docker.com/r/herosir/flask_back</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.sirxs.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</title>
    <link href="http://www.sirxs.cn/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.sirxs.cn/2020/07/20/Blog/docker%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-20T00:00:00.000Z</published>
    <updated>2020-07-20T08:13:37.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>书接上回，上回说到</strong>，<a href="https://www.sirxs.cn/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/">Windows下安装docker</a>，今天我们来讲一讲将本地项目打包到docker</p><h4 id="什么是docker镜像"><a href="#什么是docker镜像" class="headerlink" title="什么是docker镜像"></a>什么是docker镜像</h4><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p><p>回到正题，Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ol><li><p>首先我们先看下项目的整体结构</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx.png" alt="docker"></p></li><li><p><code>manage.py</code>是项目入口文件</p><p><strong>此项目地址：<a href="https://gitee.com/wangxs020202/flask/tree/wxs/" target="_blank" rel="noopener">https://gitee.com/wangxs020202/flask/tree/wxs/</a></strong></p></li><li><p>接下里我们使用Gunicorn+gevent来运行Flask项目</p></li><li><p>安装相应的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn gevent --user</span><br></pre></td></tr></table></figure></li><li><p>编辑项目目录下的gunicorn.conf.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers = <span class="number">3</span>    <span class="comment"># 进程数</span></span><br><span class="line">worker_class = <span class="string">"gevent"</span>   <span class="comment"># 异步模式</span></span><br><span class="line">bind = <span class="string">"0.0.0.0:5000"</span></span><br></pre></td></tr></table></figure></li><li><p>由于Gunicorn并不支持Windows环境，所以只需要写好配置，不需要运行。</p></li><li><p>编辑项目目录下的requirements.txt文件，这里面都是我们项目所依赖的库</p><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>导出<code>pip list</code>并生成<code>requirements.txt</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">alembic==<span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">aliyun-python-sdk-core==<span class="number">2.13</span><span class="number">.15</span></span><br><span class="line">autobahn==<span class="number">20.4</span><span class="number">.3</span></span><br><span class="line">Automat==<span class="number">0.8</span><span class="number">.0</span></span><br><span class="line">bcrypt==<span class="number">3.1</span><span class="number">.7</span></span><br><span class="line">billiard==<span class="number">3.6</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line">celery==<span class="number">4.4</span><span class="number">.2</span></span><br><span class="line">certifi==<span class="number">2019.9</span><span class="number">.11</span></span><br><span class="line">cffi==<span class="number">1.12</span><span class="number">.3</span></span><br><span class="line">channels==<span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">chardet==<span class="number">3.0</span><span class="number">.4</span></span><br><span class="line">Click==<span class="number">7.0</span></span><br><span class="line">constantly==<span class="number">15.1</span><span class="number">.0</span></span><br><span class="line">cryptography==<span class="number">2.8</span></span><br><span class="line">daphne==<span class="number">2.5</span><span class="number">.0</span></span><br><span class="line">dnspython==<span class="number">1.16</span><span class="number">.0</span></span><br><span class="line">dwebsocket==<span class="number">0.5</span><span class="number">.12</span></span><br><span class="line">eventlet==<span class="number">0.25</span><span class="number">.2</span></span><br><span class="line">Flask==<span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">Flask-Cors==<span class="number">3.0</span><span class="number">.8</span></span><br><span class="line">Flask-Migrate==<span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">Flask-MySQLdb==<span class="number">0.2</span><span class="number">.0</span></span><br><span class="line">Flask-Script==<span class="number">2.0</span><span class="number">.6</span></span><br><span class="line">Flask-SocketIO==<span class="number">4.3</span><span class="number">.0</span></span><br><span class="line">Flask-SQLAlchemy==<span class="number">2.4</span><span class="number">.1</span></span><br><span class="line">Flask-Uploads==<span class="number">0.2</span><span class="number">.1</span></span><br><span class="line">gevent==<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">greenlet==<span class="number">0.4</span><span class="number">.15</span></span><br><span class="line">gunicorn==<span class="number">20.0</span><span class="number">.4</span></span><br><span class="line">html5lib==<span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">hyperlink==<span class="number">19.0</span><span class="number">.0</span></span><br><span class="line">idna==<span class="number">2.8</span></span><br><span class="line">importlib-metadata==<span class="number">1.6</span><span class="number">.0</span></span><br><span class="line">incremental==<span class="number">17.5</span><span class="number">.0</span></span><br><span class="line">itsdangerous==<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">jmespath==<span class="number">0.9</span><span class="number">.5</span></span><br><span class="line">jsonify==<span class="number">0.5</span></span><br><span class="line">monotonic==<span class="number">1.5</span></span><br><span class="line">mysqlclient==<span class="number">1.4</span><span class="number">.4</span></span><br><span class="line">npm==<span class="number">0.1</span><span class="number">.1</span></span><br><span class="line">numpy==<span class="number">1.18</span><span class="number">.1</span></span><br><span class="line">opencv-contrib-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br><span class="line">opencv-python==<span class="number">4.1</span><span class="number">.2</span><span class="number">.30</span></span><br><span class="line">optional-django==<span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">paramiko==<span class="number">2.7</span><span class="number">.1</span></span><br><span class="line">paypalrestsdk==<span class="number">1.13</span><span class="number">.1</span></span><br><span class="line">pbr==<span class="number">5.4</span><span class="number">.3</span></span><br><span class="line">pdfminer3k==<span class="number">1.3</span><span class="number">.4</span></span><br><span class="line">Pillow==<span class="number">6.2</span><span class="number">.1</span></span><br><span class="line">ply==<span class="number">3.11</span></span><br><span class="line">pyasn1==<span class="number">0.4</span><span class="number">.8</span></span><br><span class="line">pyasn1-modules==<span class="number">0.2</span><span class="number">.8</span></span><br><span class="line">pycodestyle==<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">pycparser==<span class="number">2.19</span></span><br><span class="line">pycryptodome==<span class="number">3.9</span><span class="number">.7</span></span><br><span class="line">pycryptodomex==<span class="number">3.9</span><span class="number">.4</span></span><br><span class="line">PyHamcrest==<span class="number">1.9</span><span class="number">.0</span></span><br><span class="line">PyJWT==<span class="number">1.7</span><span class="number">.1</span></span><br><span class="line">pymongo==<span class="number">3.10</span><span class="number">.1</span></span><br><span class="line">PyMySQL==<span class="number">0.9</span><span class="number">.3</span></span><br><span class="line">PyNaCl==<span class="number">1.3</span><span class="number">.0</span></span><br><span class="line">pyOpenSSL==<span class="number">19.1</span><span class="number">.0</span></span><br><span class="line">pysnowflake==<span class="number">0.1</span><span class="number">.3</span></span><br><span class="line">python-alipay-sdk==<span class="number">2.0</span><span class="number">.1</span></span><br><span class="line">python-dateutil==<span class="number">2.8</span><span class="number">.0</span></span><br><span class="line">python-docx==<span class="number">0.8</span><span class="number">.10</span></span><br><span class="line">python-editor==<span class="number">1.0</span><span class="number">.4</span></span><br><span class="line">python-engineio==<span class="number">3.13</span><span class="number">.0</span></span><br><span class="line">python-socketio==<span class="number">4.6</span><span class="number">.0</span></span><br><span class="line">qiniu==<span class="number">7.2</span><span class="number">.8</span></span><br><span class="line">redis==<span class="number">3.3</span><span class="number">.11</span></span><br><span class="line">requests==<span class="number">2.22</span><span class="number">.0</span></span><br><span class="line">selenium==<span class="number">3.141</span><span class="number">.0</span></span><br><span class="line">service-identity==<span class="number">18.1</span><span class="number">.0</span></span><br><span class="line">soupsieve==<span class="number">1.9</span><span class="number">.5</span></span><br><span class="line">SQLAlchemy==<span class="number">1.3</span><span class="number">.10</span></span><br><span class="line">sqlparse==<span class="number">0.3</span><span class="number">.1</span></span><br><span class="line">stevedore==<span class="number">1.31</span><span class="number">.0</span></span><br><span class="line">tornado==<span class="number">6.0</span><span class="number">.4</span></span><br><span class="line">Twisted==<span class="number">20.3</span><span class="number">.0</span></span><br><span class="line">txaio==<span class="number">20.4</span><span class="number">.1</span></span><br><span class="line">upyun==<span class="number">2.5</span><span class="number">.5</span></span><br><span class="line">urllib3==<span class="number">1.25</span><span class="number">.6</span></span><br><span class="line">vine==<span class="number">1.3</span><span class="number">.0</span></span><br><span class="line">virtualenv==<span class="number">16.7</span><span class="number">.7</span></span><br><span class="line">virtualenv-clone==<span class="number">0.5</span><span class="number">.3</span></span><br><span class="line">virtualenvwrapper==<span class="number">4.8</span><span class="number">.4</span></span><br><span class="line">virtualenvwrapper-win==<span class="number">1.2</span><span class="number">.5</span></span><br><span class="line">webencodings==<span class="number">0.5</span><span class="number">.1</span></span><br><span class="line">Werkzeug==<span class="number">0.16</span><span class="number">.0</span></span><br><span class="line">Whoosh==<span class="number">2.7</span><span class="number">.4</span></span><br><span class="line">yapf==<span class="number">0.30</span><span class="number">.0</span></span><br><span class="line">zipp==<span class="number">3.1</span><span class="number">.0</span></span><br><span class="line">zope.interface==<span class="number">4.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><strong>由于只需要本项目的包，大家可以酌情删除多余的包</strong></p></li><li><p>随后在项目目录下创建一个 Dockerfile 文件，这个文件可以理解为打包镜像的脚本，你需要这个镜像做什么，就把任务写到脚本中，Docker通过执行这个脚本来打包镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /Project/flask_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"gunicorn"</span>, <span class="string">"manage:app"</span>, <span class="string">"-c"</span>, <span class="string">"./gunicorn.conf.py"</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到，我们项目的镜像首先基于python3.6这个基础镜像，然后声明项目目录在/Project/flask_back中，拷贝依赖表，之后安装相应的依赖，这里在安装过程中我们指定了国内的源用来提高打包速度，最后利用gunicorn运行项目，值得一提的是，ENV LANG C.UTF-8是为了声明Docker内部环境中的编码，防止中文乱码问题。</p></li><li><p>最后我们就可以愉快的打包整个项目了，在项目根目录下执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="string">'flask_back'</span> .</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx2.png" alt="docker"></p><p><strong>这里一定要指定Docker的下载源，否则速度会非常缓慢，打包好的镜像文件大概有1g左右。</strong></p></li><li><p>下载结束之后，可以看到myflask这个镜像已经静静躺在镜像库中了，运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx3.png" alt="docker"></p><p>我们可以看到<code>flask_back</code>以及打包成功</p></li><li><p>然后我们就可以利用这个镜像来通过容器跑Flask项目了，运行命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p <span class="number">5000</span>:<span class="number">5000</span> flask_back</span><br></pre></td></tr></table></figure></li><li><p>我们可以看到docker内部的端口5000映射到宿主机的5000端口上</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx4.png" alt="docker"></p></li><li><p>通过网址访问一下，这里注意一点，就是Windows系统下，访问Docker容器需要通过分配的ip来访问，而不是我们常用的localhost。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx5.png" alt="docker"></p></li><li><p>接下来我们启动本地<code>flask</code>项目与<code>docker</code>内部镜像对比</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx7.png" alt="docker"></p></li><li><p>对比</p><ul><li><p>docker</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx6.png" alt="docker"></p></li><li><p>本地</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dokjx8.png" alt="docker"></p></li></ul></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>可以看到启动docker与本地项目并不会影响</strong></p><p>到这里我们的 Docker+Flask + Gunicorn就部署完毕了，将这个镜像上传Dockerhub仓库，在任何时间、任何地点、任何系统上，只要连着网、只要我们想，就都可以在短短1分钟之内部署好我们的项目，这就是Docker技术对开发人员最好的馈赠。</p><p>下期<code>利用DockerHub在Centos7.7环境下部署Nginx反向代理Gunicorn+Flask独立架构</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.sirxs.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装docker</title>
    <link href="http://www.sirxs.cn/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/"/>
    <id>http://www.sirxs.cn/2020/07/16/Blog/docker%E5%AE%89%E8%A3%85/</id>
    <published>2020-07-16T00:00:00.000Z</published>
    <updated>2020-07-16T09:00:30.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://baike.so.com/doc/8850626-9175652.html" target="_blank" rel="noopener">Docker</a> 是一个<a href="https://baike.so.com/doc/4975645-27166090.html" target="_blank" rel="noopener">开源</a>的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a>   并遵从 Apache2.0 协议开源，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.so.com/doc/5349227-5584683.html" target="_blank" rel="noopener">Linux</a>或Windows 机器上，也可以实现<a href="https://baike.so.com/doc/2617474-2763805.html" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.so.com/doc/5888674-6101559.html" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h3 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>首先我们需要下载<code>Git</code>，Git大家应该都有，非常好用的一款<code>开源</code>的分布式版本控制系统，如果没有我们后期会出安装教程。</p></li><li><p>紧接着下载<code>Docker</code>安装包，这个我已经下载好，并传上了百度网盘。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker1.png" alt="docker"></p><p><strong>大家可以拉下：链接: <a href="https://pan.baidu.com/s/1TC8YLrUsS5JhlmOih8Cl5A" target="_blank" rel="noopener">https://pan.baidu.com/s/1TC8YLrUsS5JhlmOih8Cl5A</a> 提取码: zph1</strong></p></li><li><p>接下来打开压缩包，点击安装包</p><p><strong>切记安装的时候一定要断掉网络</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker2.png" alt="docker"></p></li><li><p>进入安装页面，取消勾选项，点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker3.png" alt="docker"></p></li><li><p>选择安装路径，点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker4.png" alt="docker"></p></li><li><p>取消勾选项</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker5.png" alt="docker"></p></li><li><p>直接点击<code>Next</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker6.png" alt="docker"></p></li><li><p>点击<code>Install</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker7.png" alt="docker"></p></li><li><p>安装成功，会给你安装两个软件</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker8.png" alt="docker"></p><p><strong>Oracle VM VirtualBox 是一个虚拟机，不会影响使用，但是必须得</strong></p></li><li><p>之后进入你的<code>Git</code>bin目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker9.png" alt="docker"></p><p><strong>复制路径</strong></p></li><li><p>鼠标右键<code>Docker Quickstart Terminal</code>，点击<code>属性</code>,<code>图一</code>,将复制的路径更换到此地方<code>图二</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker10.png" alt="docker"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker11.png" alt="docker"></p></li><li><p>之后解压<code>DockerToolbox-18.01.0-ce.exe</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker12.png" alt="docker"></p></li><li><p>将解压下来的文件放到下面的路径中</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker13.png" alt="docker"></p></li><li><p>之后进入<code>Docker</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker14.png" alt="docker"></p><p><strong>第一次加载是很慢的</strong></p></li><li><p>出现这个小鲸鱼说明启动成功了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker15.png" alt="docker"></p></li><li><p>进入虚拟机，可以看见一个任务正在运行</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/docker16.png" alt="docker"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>docker安装非常简单的，前面断网的原因是他在运行时会自动下载<code>DockerToolbox-18.01.0-ce.exe</code>这个文件，这个文件非常大的，所以直接断网。明天发<code>在Win10系统下利用Docker部署Gunicorn+Flask打造独立镜像</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="http://www.sirxs.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Git Bash实现Git代码上传加密</title>
    <link href="http://www.sirxs.cn/2020/07/15/Note/Gitbash/"/>
    <id>http://www.sirxs.cn/2020/07/15/Note/Gitbash/</id>
    <published>2020-07-15T08:59:18.000Z</published>
    <updated>2020-07-15T01:40:05.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>以前我都是在<a href="https://gitee.com/" target="_blank" rel="noopener">gitee</a>上上传本地项目，今天新创建了一个vue项目，突发奇想，想上传<a href="https://github.com/" target="_blank" rel="noopener">github</a>,觉得和gitee差不多，很好实现。谁知道在坑无数啊</p><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ol><li><p>这个博客就是在github上部署的，先前用gitbash生成的<code>id_rsa</code>用到了这个上面，然后我就再次使用gitbash生成了新的<code>id_rsa</code>（由此处去坑）</p></li><li><p>在我把新的<code>id_rsa</code>上传的新项目的时候，推送代码的时候出现了错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to ***** denied to deploy key</span><br></pre></td></tr></table></figure><p><strong>实在头疼</strong></p></li><li><p>然后在网上找问题。。。</p></li><li><p>最后将博客下的<code>ssh key</code> 放的用户下就ok了</p></li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li><p>首先我们需查看本地是否以生成<code>id_rsa</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash.png" alt=""></p></li><li><p>如果没有使用<code>Git Bash 进入 ssh 目录</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>查看自己的github上上传的邮箱</p><p><a href="https://github.com/settings/emails" target="_blank" rel="noopener">https://github.com/settings/emails</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash2.png" alt=""></p></li><li><p>粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span></span><br></pre></td></tr></table></figure><p>这将创建以所提供的电子邮件地址为标签的新 SSH 密钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Generating public/private rsa key pair.</span></span><br></pre></td></tr></table></figure></li><li><p>提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</span></span><br></pre></td></tr></table></figure></li><li><p>在提示时输入安全密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter same passphrase again: [Type passphrase again]</span></span><br></pre></td></tr></table></figure></li><li><p>之后查看本地是否生成<code>id_rsa</code>，文本编辑器打开公钥 <code>id_rsa.pub</code> 复制内容，添加到 Github setting。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash3.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/bash4.png" alt=""></p></li><li><p>完成上述进本已将完成，剩下的就是线上仓库与本地建立联系，推送了。</p></li><li><p>每次推送需要输入我们当时设置的密码<strong>如何解决？？</strong></p></li><li><p>git bash 进入你的项目目录，输入： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>然后你会在你本地生成一个文本，上边记录你的账号和密码。当然这些你可以不用关心。 然后你使用上述的命令配置好之后，再操作一次 git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本次踩坑实属对Git的理解还是太浅。。。。</p><p><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">Git菜鸟</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="http://www.sirxs.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 导入Json和Bson</title>
    <link href="http://www.sirxs.cn/2020/07/14/Note/7.14/"/>
    <id>http://www.sirxs.cn/2020/07/14/Note/7.14/</id>
    <published>2020-07-14T08:59:18.000Z</published>
    <updated>2020-07-14T14:25:05.914Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>在很久以前，我们学习了MongoDB的安装与一些简单的命令。<a href="https://www.sirxs.cn/2020/06/04/Note/MongoDB/">MongoDB与相关命令</a>，点击此处跳转。</p><p>我们知道MongoDB可以导出数据为JSON和BSON。BSON是一种特殊的JSON文件，又称为Binary JSON。我们想导入到另一个MongoDB的数据库里时怎么处理呢。</p><p>今天我们就来说一说MongoDB 如何导入Json和Bson。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li><p>首先，我们需要进入MongoDB的<code>bin</code>目录下，直接输入<code>cmd</code>进入终端窗口</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon.png" alt="mon"></p></li><li><p>紧接着，在终端窗口输入下面的代码</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon2.png" alt="mon"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux下可以使用：mongorestore -d &lt;db_name&gt; &lt;bson_folder&gt;</span><br><span class="line">windows下可以使用：mongorestore.exe -d &lt;db_name&gt; &lt;bson_folder&gt;</span><br><span class="line"><span class="comment">#db_name：数据库名</span></span><br><span class="line"><span class="comment">#bson_folder：bson或json文件路径</span></span><br></pre></td></tr></table></figure></li><li><p>之后进入终端窗口，进入<code>MongoDB</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon3.png" alt="mon"></p></li><li><p>进入<code>mongo</code>之后，输入<code>show dbs</code>，查看以有的数据库</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon4.png" alt="mon"></p><p><strong>可以看到我们已经导入的数据库</strong></p></li><li><p>紧接着进入导入的数据库，并查询所有表</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon5.png" alt="mon"></p></li><li><p>最后查询这个表</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mon6.png" alt="mon"></p><p><strong>可以看到我们导入的数据都出现了</strong></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><strong>MongoDB</strong>作为是一种<a href="https://zh.wikipedia.org/wiki/面向文檔的數據庫" target="_blank" rel="noopener">面向文档</a>的<a href="https://zh.wikipedia.org/wiki/数据库管理系统" target="_blank" rel="noopener">数据库管理系统</a>，用<a href="https://zh.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a>等语言撰写而成，在我们遇到存储大量的数据是会是很好的数据库，以解决应用程序开发社区中的大量现实问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="MongoDB" scheme="http://www.sirxs.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>通过高德API和Python3实现通过IP获取地区</title>
    <link href="http://www.sirxs.cn/2020/07/13/Blog/ip%E6%9F%A5%E5%9C%B0%E5%8C%BA/"/>
    <id>http://www.sirxs.cn/2020/07/13/Blog/ip%E6%9F%A5%E5%9C%B0%E5%8C%BA/</id>
    <published>2020-07-13T08:59:18.000Z</published>
    <updated>2020-07-13T12:20:43.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><a href="https://zh.wikipedia.org/wiki/高德地圖" target="_blank" rel="noopener">高德地图</a>，是中国领先的<a href="https://baike.baidu.com/item/数字地图/10689386" target="_blank" rel="noopener">数字地图</a>内容、导航和位置服务解决方案提供商。拥有导航<a href="https://baike.baidu.com/item/电子地图/1287271" target="_blank" rel="noopener">电子地图</a>甲级测绘资质、测绘航空摄影甲级资质和互联网地图服务甲级测绘资质“三甲”资质，其优质的电子地图数据库成为公司的核心竞争力。</p><p>最新地图浏览器：最新<a href="https://baike.baidu.com/item/矢量地图/5132557" target="_blank" rel="noopener">矢量地图</a>渲染，最高质量地图效果、最丰富数据信息、最快速操作体验、最节省数据流量。专业地图服务：实地采集、网络采集，行业领先。</p><p>丰富的出行查询功能：地名信息查询、分类信息查询、公交换乘、驾车路线规划、公交线路查询、位置收藏夹等丰富的基础地理信息查询工具。</p><p>成为现代人们生活的必备品</p><h3 id="获取key并查询"><a href="#获取key并查询" class="headerlink" title="获取key并查询"></a>获取key并查询</h3><ol><li><p>注册成功之后，创建新应用</p><p>进入<a href="https://lbs.amap.com/dev/" target="_blank" rel="noopener">控制台</a>，创建一个新应用。如果您之前已经创建过应用，可直接跳过这个步骤。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode1.png" alt="de"></p></li><li><p>添加新Key</p><p>在创建的应用上点击”添加新Key”按钮，在弹出的对话框中，依次：输入应用名名称，选择绑定的服务为“web服务API”，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode2.png" alt="de"></p><p>在阅读完高德地图API服务条款后，勾选此选项，点击“提交”，完成 Key 的申请，此时您可以在所创建的应用下面看到刚申请的 Key 了。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode3.png" alt="de"></p></li><li><p>进入<a href="https://lbs.amap.com/api/webservice/guide/api/ipconfig/" target="_blank" rel="noopener">高德IP定位</a>，并查看官方文档</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/gaode4.png" alt="de"></p></li><li><p>使用已申请的<code>key</code></p><p>第一步，申请”web服务 API”密钥（Key）；</p><p>第二步，拼接HTTP请求URL，第一步申请的Key需作为必填参数一同发送；</p><p>第三步，接收HTTP请求返回的数据（JSON或XML格式），解析数据。</p><p>如无特殊声明，接口的输入参数和输出数据编码全部统一为UTF-8。</p></li><li><p>IP定位API服务地址：</p><table><thead><tr><th>URL</th><th><a href="https://restapi.amap.com/v3/ip?parameters" target="_blank" rel="noopener">https://restapi.amap.com/v3/ip?parameters</a></th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr></tbody></table></li><li><p>请求参数</p><table><thead><tr><th align="left">参数名</th><th align="left">含义</th><th align="left">规则说明</th><th align="left">是否必须</th><th align="left">缺省值</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">请求服务权限标识</td><td align="left">用户在高德地图官网<a href="https://lbs.amap.com/dev/" target="_blank" rel="noopener">申请Web服务API类型KEY</a></td><td align="left">必填</td><td align="left">无</td></tr><tr><td align="left">ip</td><td align="left">ip地址</td><td align="left">需要搜索的IP地址（仅支持国内）若用户不填写IP，则取客户http之中的请求来进行定位</td><td align="left">可选</td><td align="left">无</td></tr><tr><td align="left">sig</td><td align="left">签名</td><td align="left">选择数字签名认证的付费用户必填</td><td align="left">可选</td><td align="left">无</td></tr><tr><td align="left">output</td><td align="left">返回格式</td><td align="left">可选值：JSON,XML</td><td align="left">可选</td><td align="left">JSON</td></tr></tbody></table></li><li><p>请求接口了解完之后，开始写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">ip = <span class="string">'114.247.50.2'</span></span><br><span class="line">url = <span class="string">'https://restapi.amap.com/v3/ip?ip='</span>+ip+<span class="string">'&amp;output=json&amp;key=66a7ff5f4d2371a783d196becc856f94'</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li><li><p>调用结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"status"</span>:<span class="string">"1"</span>,<span class="string">"info"</span>:<span class="string">"OK"</span>,<span class="string">"infocode"</span>:<span class="string">"10000"</span>,<span class="string">"province"</span>:<span class="string">"北京市"</span>,<span class="string">"city"</span>:<span class="string">"北京市"</span>,<span class="string">"adcode"</span>:<span class="string">"110000"</span>,<span class="string">"rectangle"</span>:<span class="string">"116.0119343,39.66127144;116.7829835,40.2164962"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个ip只能我们手动输入，但我们可以使用<code>socket</code>模块来获取本机的ip</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 获取本机计算机名称</span></span><br><span class="line">hostname = socket.gethostname()</span><br><span class="line"><span class="comment"># 获取本机ip</span></span><br><span class="line">ip = socket.gethostbyname(hostname)</span><br><span class="line">print(ip)</span><br></pre></td></tr></table></figure></li><li><p>打印结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>  <span class="comment"># 因为我用的以太网，所以获取到的是以太网IP</span></span><br></pre></td></tr></table></figure></li><li><p>两者结合使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 获取本机计算机名称</span></span><br><span class="line">hostname = socket.gethostname()</span><br><span class="line"><span class="comment"># 获取本机ip</span></span><br><span class="line">ip = socket.gethostbyname(hostname)</span><br><span class="line">url = <span class="string">'https://restapi.amap.com/v3/ip?ip='</span>+ip+<span class="string">'.139&amp;output=json&amp;key=66a7ff5f4d2371a783d196becc856f94'</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>通过调用高德接口，可以很方便实现通过IP查询地址</p><p><strong>更多内容查看<a href="https://lbs.amap.com/" target="_blank" rel="noopener">高德开放平台</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 为什么推荐蛇形命名法？</title>
    <link href="http://www.sirxs.cn/2020/07/12/Note/python%E5%8F%98%E9%87%8F/"/>
    <id>http://www.sirxs.cn/2020/07/12/Note/python%E5%8F%98%E9%87%8F/</id>
    <published>2020-07-12T08:59:18.000Z</published>
    <updated>2020-07-12T13:42:52.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>关于变量的命名，这又是一个容易引发程序员论战的话题。如何命名才能更具有可读性、易写性与明义性呢？众说纷纭。</p><p>今天，我们将聚焦于变量命名中的连接方式，来切入这块是非之地，想要回答的问题是——<strong>Python 为什么要推荐蛇形命名法？</strong></p><h3 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h3><p>首先一点，对于<strong>单个字符或者单词</strong>（例如：a、A、PYTHON、Cat），当它们被用作变量名时，大致有全小写、全大写和首字母大写这几种情况。编程语言中出现这些情况时，它们基本上跟英语的表达习惯是相同的。</p><p>但是，编程语言为了令变量名表达出更丰富的含义，通常需要使用<strong>多个单词或符号。</strong>英语习惯使用空格来间隔开单词，然而这种用法在编程语言中会带来一些麻烦，所以程序员们就创造出了另外的方法：</p><ul><li>蛇形命名法（snake case）</li><li>驼峰命名法（camel case）</li><li>匈牙利命名法（HN case）</li><li>帕斯卡命名法（Pascal case）</li><li>脊柱命名法（spinal case）</li><li>自由命名法（studly caps）</li><li>驼峰蛇形命名法</li></ul><p>总体而言，这些命名法都是要<strong>克服单词间的空格，从而把不同单词串连起来，</strong>最终达到创造出一种新的“单词”的效果。</p><p>我画了一张思维导图，大略区分了这几种命名法：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mm1.png" alt="img"></p><p>如果按照受众量与知名程度排名，毫无疑问排前两位的是驼峰命名法和蛇形命名法。</p><p>我们简单比较一下它们的优缺点：</p><ul><li>可读性：蛇形命名法用下划线拉大词距，更清楚易读；驼峰命名法的变量名紧凑，节省行宽</li><li>易写性：驼峰命名法以大小写为区分，不引入额外的标识符；蛇形命名法统一小写，输入相对方便</li><li>明义性：对于某些缩写成的专有名词，例如HTTP、RGB、DNS等等，一般习惯全用大写表示，但是如果严格遵循这两种命名法的话，须得只留首字母大写或者全小写，这样对原意都会造成一些“破坏”，有时候甚至让人感觉到别扭。如果保留全大写，IDE可能识别不准，反而会出现波浪提示</li></ul><p>由此可见，它们各有优缺点，但哪一方都不具有压倒性。我个人稍微偏好于蛇形命名法，但是在需要用驼峰命名的时候（比如写 Java 时），也能无障碍切换。</p><p>需要指出的是，Python 也推荐使用驼峰式命名，那是在类名、Type 变量、异常 exception 名这些情况。而在<strong>包名、模块名、方法名和普通变量名</strong>等情况，则是推荐用蛇形命名（lower_case_with_underscores）。</p><p>那么，为什么 Python 会推荐用蛇形命名法呢？</p><p><strong>最大的原因是历史原因。</strong>蛇形命名方式起源于 1960 年代，那时它甚至还没有特定的名称。Python 从 C 语言中借鉴过来后，给它起名为“lower_case_with_underscores”，即带下划线的小写命名。</p><p>直到 21 世纪初的几年，在 Intel 和 Ruby 社区中，才有人开始以“snake_case”即蛇形命名来称呼它。</p><p>现今有不少编程语言在某些场景下会推荐使用蛇形命名法，而 Python 则是其中最早这么做的之一，并且是使用场景最多的语言之一。</p><p>维基百科上统计了一份清单，可以看出 Python 对它的偏好：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/mm2.png" alt="img"></p><p>其次，还有一个比较重要的原因，<strong>那就是 Python 对下划线“_”的独特偏爱。</strong></p><p>比如类似于 <em>xx、<strong>xx、xx_、</strong>xx_</em> 等等的写法就随处可见，甚至还有孤零零一个下划线 _ 作为变量的特殊情况。这样看来，下划线作为单词间的连接，恰恰是这种传统习惯的一部分。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最后，我还看到过一种解释：<strong>因为 Python 是蟒蛇啊，理所当然是用蛇形命名……</strong></p><p>对于这三个解释，你们是如何感想的呢？对于蛇形命名法，大家是喜欢还是不喜欢呢？欢迎留言交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用ShareLatex和Python3打造属于自己的特色简历</title>
    <link href="http://www.sirxs.cn/2020/07/11/Note/%E4%BD%BF%E7%94%A8ShareLatex%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/"/>
    <id>http://www.sirxs.cn/2020/07/11/Note/%E4%BD%BF%E7%94%A8ShareLatex%E5%88%B6%E4%BD%9C%E7%AE%80%E5%8E%86/</id>
    <published>2020-07-11T08:59:18.000Z</published>
    <updated>2020-07-12T13:44:23.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>履历</strong>(英式英语：<a href="https://zh.wikipedia.org/w/index.php?title=Curriculum_Vitae&action=edit&redlink=1" target="_blank" rel="noopener">Curriculum Vitae</a>，简称<strong>CV</strong>；美式英语：<a href="https://zh.wikipedia.org/w/index.php?title=Résumé&action=edit&redlink=1" target="_blank" rel="noopener">Résumé</a>)，是对个人教育、工作经历的书面介绍，是求职者通向面试阶段的重要一环。</p><p>说起简历模板，大家一定不会陌生，随便在百度搜关键词“简历模板”，林林总总的会出现一大片，但是这些简历模板往往都会有一个共同点，就是太Low、“土味”重、没有时代感、味同嚼蜡，蜡都要顺着嘴角流下来了，以一个求职者的视角来看待这些简历都会无奈心烦，更别说招聘者了。所以新时代的简历应该具备独特性、新颖、与众不同并且不落窠臼。</p><p>Resume是在申请求职时最常使用的文件，为你的教育程度、工作经历以及工作技能做简单且明了的摘要，同时，也会依个人、申请职位的需求，列出求职目标。由于是个人“摘要”，Resume通常为一页，最多不超过二页，以求简洁。</p><p>而在CV中，则会详细的列举出个人的经验与相关技能，尤其是个人的学术背景，如：教学经验、研究成果、获奖纪录、相关出版物⋯⋯等细节，也因此，CV的篇幅会比Resume长上许多，通常会超过二页。</p><h3 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h3><ol><li><p>首先进入<a href="https://www.sharelatex.com/" target="_blank" rel="noopener">ShareLatex</a>，注册账号并登陆。</p></li><li><p>之后通过邮箱激活，选择新建序幕，并选简历</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha1.png" alt="sha"></p></li><li><p>紧接着我们会发现有许多简历模板，但是都用LaTeX语法写的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha2.png" alt="sha"></p></li><li><p>随后点开其中一个，就可以进行定制化的编辑</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha3.png" alt="sha"></p></li><li><p>编辑之后，可以点击重新编译查看效果，如果编辑好之后就可以在线下载pdf，非常方便</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha4.png" alt="sha"></p></li><li><p>但是由于LaTeX语法我们没有学过，而且编辑成本比较高，最重要的对于一些英文不好的很难编辑。</p></li><li><p>其实<code>6</code>的问题很好解决。我们可以下载这上面的原始pdf简历，再通过Python脚本将其转换为我们所熟悉的Word文档模式，这样就可以随便进行编辑</p></li><li><p>通过Pdfminer3k以及Python-Docx两个库，使用python可以实现</p></li><li><p>首先安装依赖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pdfminer3k</span><br><span class="line">pip3 install python-docx</span><br></pre></td></tr></table></figure></li><li><p>通过Pdfminer3k读取pdf内容，再使用Python-Docx写入word文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFResourceManager</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> process_pdf</span><br><span class="line"><span class="keyword">from</span> pdfminer.converter <span class="keyword">import</span> TextConverter</span><br><span class="line"><span class="keyword">from</span> pdfminer.layout <span class="keyword">import</span> LAParams</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = open(<span class="string">"pdf文件地址"</span>, <span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line">resource_manager = PDFResourceManager()</span><br><span class="line">return_str = StringIO()</span><br><span class="line">lap_params = LAParams()</span><br><span class="line"></span><br><span class="line">device = TextConverter(resource_manager, return_str, laparams=lap_params)</span><br><span class="line">process_pdf(resource_manager, device, file)</span><br><span class="line">device.close()</span><br><span class="line"></span><br><span class="line">content = return_str.getvalue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_control_characters</span><span class="params">(content)</span>:</span></span><br><span class="line">    mpa = dict.fromkeys(range(<span class="number">32</span>))</span><br><span class="line">    <span class="keyword">return</span> content.translate(mpa)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content.split(<span class="string">'\n'</span>):</span><br><span class="line">    paragraph = doc.add_paragraph()</span><br><span class="line">    paragraph.add_run(remove_control_characters(line))</span><br><span class="line">doc.save(<span class="string">"mypdf.docx"</span>)</span><br></pre></td></tr></table></figure></li><li><p>但是，这样弄出来的简历，没有样式而且麻烦</p></li><li><p>我们可以通过注册登陆<a href="https://smallpdf.com/" target="_blank" rel="noopener">https://smallpdf.com/</a>此网站，进行在线转换</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha5.png" alt="sha"></p></li><li><p>直接拖拽上传即可。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/sha6.png" alt="sha"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>一个不落俗套的简历模板可以让你的求职如虎添翼，也可以让你的简历从招聘者邮箱中的海量简历中脱颖而出，但是简历模板也仅仅是求职中的一个重要细节之一，比起简历模板，简历中的工作经历以及技术经验则更加重要，切不可本末倒置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
      <category term="ShareLatex" scheme="http://www.sirxs.cn/tags/ShareLatex/"/>
    
  </entry>
  
  <entry>
    <title>Win10系统下安装编辑器之神Vim</title>
    <link href="http://www.sirxs.cn/2020/07/10/Note/vim%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.sirxs.cn/2020/07/10/Note/vim%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-07-10T08:59:18.000Z</published>
    <updated>2020-07-10T02:57:32.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>相对于pycharm，Sublime、Vscode等编辑器，vim一直是处于编辑器的最顶端，奉行 Unix 传统的“Do one thing and do it well”哲学。</p><p>本次我们在Win10平台构建一套以Vim为核心的Python开发环境。</p><h3 id="下载安装与使用"><a href="#下载安装与使用" class="headerlink" title="下载安装与使用"></a>下载安装与使用</h3><ol><li><p>首先进入<a href="https://tuxproject.de/projects/vim/x64/" target="_blank" rel="noopener">giv官网</a>下载gvim8，注意根据系统类型选择32或者64位，这里我们选择64位的</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim1.png" alt="vim"></p></li><li><p>下载完成后，将下载好的压缩包解压，并且将文件放到C:/vim目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim2.png" alt="vim"></p></li><li><p>紧接着我们配置下环境变量，这样我们就可以在电脑的任意位置启动vim</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim3.png" alt="vim"></p></li><li><p>之后在当前的用户目录，建立一个_vimrc文件，这是vim的配置文件，所有的设置都在这里编写</p><p>将以下内容添加到_vimrc文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" An example for a vimrc file.</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Maintainer:Bram Moolenaar &lt;Bram@vim.org&gt;</span></span><br><span class="line"><span class="string">"</span> Last change:<span class="number">2019</span> Dec <span class="number">17</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">"</span> To use it, copy it to</span><br><span class="line"><span class="string">"       for Unix:  ~/.vimrc</span></span><br><span class="line"><span class="string">"</span>      <span class="keyword">for</span> Amiga:  s:.vimrc</span><br><span class="line"><span class="string">" for MS-Windows:  $VIM_vimrc</span></span><br><span class="line"><span class="string">"</span>      <span class="keyword">for</span> Haiku:  ~/config/settings/vim/vimrc</span><br><span class="line"><span class="string">"    for OpenVMS:  sys$login:.vimrc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> When started <span class="keyword">as</span> <span class="string">"evim"</span>, evim.vim will already have done these settings, bail</span><br><span class="line"><span class="string">" out.</span></span><br><span class="line"><span class="string">if v:progname =~? "</span>evim<span class="string">"</span></span><br><span class="line"><span class="string">  finish</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Get the defaults that most users want.</span><br><span class="line">source $VIMRUNTIME/defaults.vim</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">"vms"</span>)</span><br><span class="line">  set nobackup<span class="string">" do not keep a backup file, use versions instead</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">  set backup"</span> keep a backup file (restore to previous version)</span><br><span class="line">  <span class="keyword">if</span> has(<span class="string">'persistent_undo'</span>)</span><br><span class="line">    set undofile<span class="string">" keep an undo file (undo changes after closing)</span></span><br><span class="line"><span class="string">  endif</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if &amp;t_Co &gt; 2 || has("</span>gui_running<span class="string">")</span></span><br><span class="line"><span class="string">  "</span> Switch on highlighting the last used search pattern.</span><br><span class="line">  set hlsearch</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">" Put these in an autocmd group, so that we can delete them easily.</span></span><br><span class="line"><span class="string">augroup vimrcEx</span></span><br><span class="line"><span class="string">  au!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  "</span> For all text files set <span class="string">'textwidth'</span> to <span class="number">78</span> characters.</span><br><span class="line">  autocmd FileType text setlocal textwidth=<span class="number">78</span></span><br><span class="line">augroup END</span><br><span class="line"></span><br><span class="line"><span class="string">" Add optional packages.</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" The matchit plugin makes the % command work better, but it is not backwards</span></span><br><span class="line"><span class="string">"</span> compatible.</span><br><span class="line"><span class="string">" The ! means the package won't be loaded right away but when plugins are</span></span><br><span class="line"><span class="string">"</span> loaded during initialization.</span><br><span class="line"><span class="keyword">if</span> has(<span class="string">'syntax'</span>) &amp;&amp; has(<span class="string">'eval'</span>)</span><br><span class="line">  packadd! matchit</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">set encoding=utf<span class="number">-8</span></span><br><span class="line">set fileencodings=utf<span class="number">-8</span>,chinese,latin<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">"win32"</span>)</span><br><span class="line">    set fileencoding=chinese</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    set fileencoding=utf<span class="number">-8</span></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">set autoindent</span><br><span class="line">set nu!</span><br><span class="line">set shiftwidth=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line"></span><br><span class="line">language messages zh_CN.utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line">colo koehler</span><br><span class="line">set guifont=monaco:h11:cANSI</span><br><span class="line"></span><br><span class="line">set ts=<span class="number">4</span></span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">map &lt;F5&gt; :! python.exe %</span><br></pre></td></tr></table></figure></li><li><p>这些都是一些最基本的配置，比如设置编码解决中文乱码问题、自动缩进以及缩进宽度、菜单栏中文字体问题、主题和字体、以及四个空格代替制表符等等，注意一点这个配置里我将运行python脚本的快捷键设置成了F5。</p><p>这时进入windows命令行，输入gvim启动编辑器，然后键入命令:version，看到版本号就没有问题了</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim4.png" alt="vim"></p></li><li><p>虽然现在Vim已经可以正常使用了，但是没有插件的加成，开发效率就不是那么高，所以我们现在来安装一些常用的插件。安装<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">pathogen.vim插件</a>（一个vim插件管理器， 直接Clone或者下载压缩包将Clone或者解压后的pathogen.vim文件放到C:/vim/autoload目录下</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim5.png" alt="vim"></p></li><li><p>修改用户目录下的_vimrc配置文件，将下面的配置加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute pathogen#infect()</span><br></pre></td></tr></table></figure></li><li><p>这样就可以安装其他所有的插件了，紧接着我们安装一个<a href="https://www.vim.org/scripts/script.php?script_id=69" target="_blank" rel="noopener">项目管理插件</a>(project)，它可以帮助我们把项目整体导入vim编辑器内，通过点击文件进行修改，这样就不用每次编辑都要在命令行输入命令才能编辑了，大体上，这个插件可以帮我们快速修改整个项目。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim6.png" alt="vim"></p></li><li><p>将解压后的doc目录中的project文件拷贝到vim安装目录的doc目录下将plugin目录下的project.vim拷贝到vim安装目录的plugin目录下在命令行输入gvim启动编辑器。输入:Project，随后输入\C (是反斜杠和大写C，因为是输入命令，所以不会在编辑内显示，但是执行成功后会弹出窗口)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim7.png" alt="vim"></p></li><li><p>Enter the Name of the Entry: 输入项目名，Enter the Absolute Directory to，Load: 输入项目的文件目录路径（项目目录需要事先存在），Enter the CD parameter: 这个和项目目录路径一样即可，Enter the File Filter: 设置管理的文件类型，<em>.py,</em>.txt等等，可以设置多个，不设置（直接回车）默认为所有类型</p><p>再次使用：打开vim后输入:Project<br>使用回车打开或关闭标签。<br>添加或者修改文件后可以使用\R进行刷新项目。</p><p>这样我们就可以在vim里管理我们的项目了。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim8.png" alt="vim"></p></li><li><p>好了，项目导入后就可以愉快的开发了，但是我们发现vim默认没有代码补全，怎么办呢，聪明如你一定已经猜到可以用插件搞定，使用<a href="https://github.com/rkulla/pydiction" target="_blank" rel="noopener">pydiction</a>Clone或者下载压缩包之后，发现里面有after文件夹、complete-dict、pydiction.py</p><p>将after里面的python_pydiction.vim文件拷贝到 vim安装目录下的ftpplugin里面，将complete-dict、pydiction.py 拷贝到ftpplugin目录下。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim9.png" alt="vim"></p><p>随后在_vimrc里面添加 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filetype plugin on</span><br><span class="line">let g:pydiction_location=<span class="string">'C:vim/ftplugin/complete-dict'</span></span><br><span class="line">let g:pydiction_menu_height = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这就搞定了，使用方法是，敲入两个字母之后使用tab键进行补全，效果是下面这样：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim10.png" alt="vim"></p></li><li><p>还不错吧，有的时候，你甚至想用vim来编辑前端的页面，没有任何问题，使用<a href="https://vim.sourceforge.io/scripts/script.php?script_id=1879" target="_blank" rel="noopener">autocomplpop插件</a></p><p>解压后，将plugin下的脚本文件(.vim)、doc下的帮助文件(.txt)和autoload下的(.vim)文件分别拷贝至vim的 plugin、doc和autoload目录</p><p>这个插件甚至不需要配置，只需要在输入/insert模式下即可自动根据当前文档内的内容进行自动补全</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim11.png" alt="vim"></p></li><li><p>是不是感觉还不错？有了那么一点黑客的赶脚了。</p><p>Vim 有两种模式——Normal 模式和 Insert 模，所有命令都是在 Normal 模式下执行。启动 Vim 后，默认进入 Normal 模式，可以按 i 键进入 Insert 模式，或者 s 删除当前字符并进入 Insert 模式，退出 Insert 模式进入 Normal 按 ESC 。</p><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">i insert 输入</span><br><span class="line">v 行选中</span><br><span class="line">ctrl+v 列选中G 至文末</span><br><span class="line">gg 至文首</span><br><span class="line">:q 未修改退出</span><br><span class="line">:q! 强制不保存退出</span><br><span class="line">:x / :wq 保存并退出</span><br><span class="line">J 合并多行</span><br><span class="line">d 删除当前所选</span><br><span class="line">dd 删除多行并存在剪贴板中（剪切）</span><br><span class="line">y 复制当前所选</span><br><span class="line">yy 复制整行</span><br><span class="line">p 粘贴</span><br><span class="line">u 撤销操作</span><br><span class="line">w 光标移动到下一个单词处</span><br><span class="line">b 光标移动到上一个单词处</span><br><span class="line">^ 光标移动到行首</span><br><span class="line">$ 光标移动到行尾</span><br><span class="line">kjhl 或者上下左右键移动光标</span><br><span class="line">shift+上下键 翻页</span><br><span class="line">shift+左右 光标乙至上/下一个单词（以空格/标点区分单词）词首</span><br><span class="line">u 撤销上一步操作</span><br><span class="line">zo/zn/zc 折叠/展开代码块</span><br><span class="line">:vsp 新建工作区</span><br><span class="line">ctrl+w 松手后再按 方向键 切换工作区</span><br><span class="line">:MR 选择最近打开的文件（需安装插件）</span><br><span class="line">F12 运行当前文件</span><br><span class="line"><span class="comment"># 搜索光标处短语</span></span><br><span class="line">:set paste 进入粘贴模式</span><br><span class="line">:%s/target/something/g 替换全部 target 字段</span><br><span class="line">:s/target/something/g 替换选中区域 target 字段</span><br></pre></td></tr></table></figure></li><li><p>参考命令图解</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/vim12.png" alt="vim"></p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>现而今，Mac os和开源软件渐渐流行起来，此时的人们才发现：可扩展性才是软件的核心竞争力。在JetBrains横行的今天，Vscode为什么被评为最好的IDE？就是因为它在IDE中最具可扩展性。同理，将近30多年的历史浪潮中Vim没有被时代淘汰，反而愈发健壮，拥趸遍布全世界，也正是因为在数不清的编辑器中，Vim具有无可匹敌的可扩展性，当然了，这个世界除了编辑器之神，还有另外一种信仰：Emacs，它的教徒丝毫不少于Vim，它的影响力已经是超越编辑器的存在，有机会再分享关于Emacs的传说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vim" scheme="http://www.sirxs.cn/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>（在线客服系统）Python3.7+Flask1.1.1结合Socket.io与Vue2.9.6联合实现在线客服系统</title>
    <link href="http://www.sirxs.cn/2020/06/28/Blog/websocket/"/>
    <id>http://www.sirxs.cn/2020/06/28/Blog/websocket/</id>
    <published>2020-06-28T05:54:10.000Z</published>
    <updated>2020-06-28T06:48:44.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><h4 id="websocket是个啥？"><a href="#websocket是个啥？" class="headerlink" title="websocket是个啥？"></a>websocket是个啥？</h4><p>webSocket是一种在单个TCP连接上进行全双工通信的协议</p><p>webSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</p><p>现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 而比较新的技术去做轮询的效果是Comet。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。</p><p>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯</p><p>Socket.IO 就是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 client 的 JavaScript 和 server 的 Node（现在也支持python,go lang等语言）。其屏蔽了所有底层细节，让顶层调用非常简单，另外，Socket.IO 还有一个非常重要的好处。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信，这一点就比websocket要智能不少。</p><h3 id="后端服务搭建"><a href="#后端服务搭建" class="headerlink" title="后端服务搭建"></a>后端服务搭建</h3><ol><li><p>我们需要使用flask框架来实现，首先安装相应的包</p><p><strong>分别安装Flask本地，跨域模块，以及socketio模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br><span class="line">pip install flask-cors</span><br><span class="line">pip install flask-socketio</span><br><span class="line">pip install Flask-SQLAlchemy</span><br></pre></td></tr></table></figure><p><strong>注意版本</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flask                   <span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">Flask-Cors              <span class="number">3.0</span><span class="number">.8</span></span><br><span class="line">Flask-SocketIO          <span class="number">4.3</span><span class="number">.0</span></span><br><span class="line">Flask-SQLAlchemy        <span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li><li><p>接下来，写一个flask的入口文件<code>manage.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request,jsonify</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"><span class="keyword">from</span> flask_socketio <span class="keyword">import</span> SocketIO,send,emit</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">CORS(app,cors_allowed_origins=<span class="string">"*"</span>)</span><br><span class="line"></span><br><span class="line">socketio = SocketIO(app,cors_allowed_origins=<span class="string">'*'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@socketio.on('message')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(message)</span>:</span></span><br><span class="line">    message = urllib.parse.unquote(message)</span><br><span class="line">    print(message)</span><br><span class="line">    send(message,broadcast=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('connect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_connect</span><span class="params">()</span>:</span></span><br><span class="line">    emit(<span class="string">'my response'</span>, &#123;<span class="string">'data'</span>: <span class="string">'Connected'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@socketio.on('disconnect', namespace='/chat')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_disconnect</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Client disconnected'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    socketio.run(app,debug=<span class="literal">True</span>,host=<span class="string">"0.0.0.0"</span>,port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><u>我们写了三个基于socketio的视图方法，connect和disconnect顾名思义，当clinet发起连接或者断开时我们可以及时捕获到，而message方法就是前后端进行消息通信的重要方法。</u></p><p><em>发送消息的时候方法加了一个broadcast参数，这是socket.io极具特色的功能，类似广播的效果，可以同时给不同链接的client发送消息，即可以用于聊天，也可以用来做消息推送。</em></p><p> 最后需要注意的一点是，client发送消息时，最好用urlencode编码一下，这样可以解决中文乱码问题，而在server端，可以用urllib.parse.unquote()来进行解码操作。</p></li><li><p>启动flask服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk1.png" alt="socketio"></p><p><strong>没有出现错误，说明后端没问题</strong></p></li></ol><h3 id="Vue搭建页面"><a href="#Vue搭建页面" class="headerlink" title="Vue搭建页面"></a>Vue搭建页面</h3><ol><li><p>指定按本安装依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-socket.io@<span class="number">2.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure></li><li><p>在入口文件<code>main.js</code>中引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueSocketio <span class="keyword">from</span> <span class="string">'vue-socket.io'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueSocketio,<span class="string">'http://127.0.0.1:5000'</span>);</span><br></pre></td></tr></table></figure></li><li><p>构建用户链接组件<code>client.vue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">for</span>=<span class="string">"item in log_list"</span>&gt;</span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">         &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input v-model="msg" /</span>&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"send"</span>&gt;发送消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">  msg: "",</span></span><br><span class="line"><span class="regexp">  log_list:[]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/注册组件标签</span></span><br><span class="line"><span class="regexp">  components:&#123;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  sockets:&#123;</span></span><br><span class="line"><span class="regexp">    connect: function()&#123;</span></span><br><span class="line"><span class="regexp">      console.log('socket 连接成功')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    message: function(val)&#123;</span></span><br><span class="line"><span class="regexp">  console.log('返回:'+val);</span></span><br><span class="line"><span class="regexp">this.log_list.push(val);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  mounted:function()&#123;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp">send()&#123;</span></span><br><span class="line"><span class="regexp">  this.$socket.emit('message',encodeURI("用户:"+this.msg));</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务，访问页面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk2.png" alt="socketio"></p><p><strong>没有问题，接下来构建客服组件</strong></p></li><li><p>构建客服链接组件<code>server.vue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">"item in log_list"</span>&gt;</span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">         &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input v-model="msg" /</span>&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"send"</span>&gt;发送消息&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">  msg: "",</span></span><br><span class="line"><span class="regexp">  log_list:[]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/注册组件标签</span></span><br><span class="line"><span class="regexp">  components:&#123;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  sockets:&#123;</span></span><br><span class="line"><span class="regexp">    connect: function()&#123;</span></span><br><span class="line"><span class="regexp">      console.log('socket 连接成功')</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    message: function(val)&#123;</span></span><br><span class="line"><span class="regexp">  console.log('返回:'+val);</span></span><br><span class="line"><span class="regexp">  this.log_list.push(val);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  mounted:function()&#123;</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">  methods:&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">send()&#123;</span></span><br><span class="line"><span class="regexp">  this.$socket.emit('message',encodeURI("客服:"+this.msg));</span></span><br><span class="line"><span class="regexp">    &#125;,  </span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p><strong>用来模拟用户和客服分别在不同的电脑进行聊天的场景</strong></p></li><li><p>效果展示</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk3.png" alt="socketio"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/wsk4.png" alt="socketio"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://www.sirxs.cn/tags/Vue/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
      <category term="Flask" scheme="http://www.sirxs.cn/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>使用python3.7实现钉钉机器人群发</title>
    <link href="http://www.sirxs.cn/2020/06/19/Blog/dingrobot/"/>
    <id>http://www.sirxs.cn/2020/06/19/Blog/dingrobot/</id>
    <published>2020-06-19T07:54:00.000Z</published>
    <updated>2020-06-22T11:35:06.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>之前实现了<a href="https://www.sirxs.cn/2020/06/02/Blog/%E9%92%89%E9%92%89%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86/">钉钉三方扫码登陆</a>，不得不说，钉钉还是一款很不错的办公软件。在最近的疫情期间，打游戏都不怎么坑了(因为钉钉的存在)。不过钉钉的群发机器人还是挺不错，可以自定义发送的信息。个人感觉比图灵好用，前期的<a href="https://www.sirxs.cn/2020/06/08/Live/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/">微信公众号添加机器人</a>使用的就是图灵机器人。</p><p>不过关于钉钉机器人网上的一些攻略年代都比较久远，代码很多都基于python2，那我们尝试用python3.7来开发配置钉钉自定义机器人。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><h4 id="quote-plus与quote的区别"><a href="#quote-plus与quote的区别" class="headerlink" title="quote_plus与quote的区别"></a>quote_plus与quote的区别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">quote = urllib.parse.quote(<span class="string">'a&amp;b/c'</span>)</span><br><span class="line">print(<span class="string">'a&amp;b/c:'</span>,quote)</span><br><span class="line">plus = urllib.parse.quote_plus(<span class="string">'a&amp;b/c'</span>)</span><br><span class="line">print(<span class="string">'a&amp;b/c:'</span>,plus)</span><br></pre></td></tr></table></figure><p>结果(一个不编译/,一个编译)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b/c: a%<span class="number">26</span>b/c</span><br><span class="line">a&amp;b/c: a%<span class="number">26</span>b%<span class="number">2</span>Fc</span><br></pre></td></tr></table></figure><h3 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h3><ol><li><p>在创建机器人之前，我们需要有自己的钉钉号，和创建一个钉钉群聊，而且创建机器人不支持手机端，所以请在电脑端进行创建</p></li><li><p>进入创建好的群，群成员可根据个人喜好添加，找到<code>智能群组手</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd1.png" alt="dd"></p></li><li><p>进入之后，下拉找到<code>添加机器人</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd2.png" alt="dd"></p></li><li><p>之后<code>添加机器人</code>，选择<code>自定义</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd3.png" alt="dd"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd4.png" alt="dd"></p></li><li><p><code>机器人名称</code>自己修改（<strong>密钥保存</strong>）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd5.png" alt="dd"></p><p><strong>需要注意的是，在安全设置一栏里，我们选择加签的方式来验证，在此说明一下，钉钉机器人的安全策略有三种，第一种是使用关键字，就是说你推送的消息里必须包含你创建机器人时定义的关键字，如果不包含就推送不了消息，第二种就是使用加密签名，第三种是定义几个ip源，非这些源的请求会被拒绝，综合来看还是第二种又安全又灵活。</strong></p></li><li><p>点击<code>完成</code>，ok，群发机器人已创建好（<strong>webhoot保存</strong>）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd6.png" alt="dd"></p><p><strong>值得一提的是，钉钉的机器人基于webhook协议，webhook呢是一个api概念,是微服务api的使用范式之一,也被成为反向api,即前端不主动发送请求。</strong></p></li></ol><h3 id="编写后端请求接口"><a href="#编写后端请求接口" class="headerlink" title="编写后端请求接口"></a>编写后端请求接口</h3><p><a href="https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq" target="_blank" rel="noopener">钉钉开发文档</a></p><p>开发文档中居然出现了python3.8的代码，很遗憾我们用的是3.7的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">timestamp = str(round(time.time() * <span class="number">1000</span>))</span><br><span class="line">secret = <span class="string">'this is secret'</span></span><br><span class="line">secret_enc = secret.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">string_to_sign = <span class="string">'&#123;&#125;\n&#123;&#125;'</span>.format(timestamp, secret)</span><br><span class="line">string_to_sign_enc = string_to_sign.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()</span><br><span class="line">sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))</span><br><span class="line"><span class="comment"># print(timestamp)</span></span><br><span class="line"><span class="comment"># print(sign)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,json   <span class="comment">#导入依赖库</span></span><br><span class="line">headers=&#123;<span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>&#125;   <span class="comment">#定义数据类型</span></span><br><span class="line">webhook = <span class="string">'"this is webhoot"&amp;timestamp='</span>+timestamp+<span class="string">"&amp;sign="</span>+sign</span><br><span class="line"><span class="comment">#定义要发送的数据</span></span><br><span class="line"><span class="comment">#"at": &#123;"atMobiles": "['"+ mobile + "']"</span></span><br><span class="line"><span class="comment">#群发</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="string">"text"</span>: &#123;<span class="string">"content"</span>: <span class="string">'群发消息'</span>&#125;,</span><br><span class="line">    <span class="string">"isAtAll"</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#@</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"msgtype"</span>: <span class="string">"text"</span>, </span><br><span class="line">    <span class="string">"text"</span>: &#123;</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"群发消息"</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">"at"</span>: &#123;</span><br><span class="line">        <span class="string">"atMobiles"</span>: [</span><br><span class="line">            <span class="string">"156xxxx8827"</span>, </span><br><span class="line">            <span class="string">"189xxxx8325"</span></span><br><span class="line">        ], </span><br><span class="line">        <span class="string">"isAtAll"</span>: <span class="literal">False</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(webhook, data=json.dumps(data), headers=headers)   <span class="comment">#发送post请求</span></span><br><span class="line"></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p>推送效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/dd7.png" alt="dd"></p><p><strong>校验不通过的消息将会发送失败，错误如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息内容中不包含任何关键词</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"keywords not in content"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timestamp 无效</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"invalid timestamp"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 签名不匹配</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"sign not match"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址不在白名单</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">310000</span>,</span><br><span class="line">  <span class="attr">"errmsg"</span>:<span class="string">"ip X.X.X.X not in whitelist"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>（贝宝模拟实现跨境支付）使用python3.7+Vue.js2.0+Django2.0.4实现Paypal模拟跨境支付功能</title>
    <link href="http://www.sirxs.cn/2020/06/17/Blog/Paypal_Sandbox/"/>
    <id>http://www.sirxs.cn/2020/06/17/Blog/Paypal_Sandbox/</id>
    <published>2020-06-17T07:54:00.000Z</published>
    <updated>2020-06-17T10:50:22.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><ol><li><a href="https://baike.baidu.com/item/PayPal" target="_blank" rel="noopener">Paypal(贝宝)</a>，作为一种外贸支付方式，目前在国际贸易支付服务中倍受亿万用户追捧，是全球商户和消费者最受欢迎的电子支付方式之一，是倍受全球亿万用户追捧的国际贸易<a href="https://baike.baidu.com/item/支付工具" target="_blank" rel="noopener">支付工具</a>，即时支付，即时到账，全中文操作界面，能通过中国的本地银行轻松提现，解决外贸收款难题，助您成功开展海外业务，决胜全球。注册PayPal后就可立即开始接受信用卡付款。、</li><li>PayPal是名副其实的全球化支付平台，  服务范围超过200个市场， 支持的币种超过100个。在跨国交易中， 将近70%的在线跨境买家更喜欢用PayPal支付海外购物款项。</li><li>之前写过模拟实现<a href="https://www.sirxs.cn/2020/06/13/Blog/Alipay_Sandbox/">支付宝模拟支付</a>，这次我们来实现跨境三方支付接口PayPal</li></ol><h3 id="创建贝宝沙盒应用"><a href="#创建贝宝沙盒应用" class="headerlink" title="创建贝宝沙盒应用"></a>创建贝宝沙盒应用</h3><ol><li><p>首先注册官网 <a href="https://www.paypal.com" target="_blank" rel="noopener">https://www.paypal.com</a> 以及开发者平台：<a href="https://developer.paypal.com/classic-home/" target="_blank" rel="noopener">https://developer.paypal.com/classic-home/</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal1.png" alt="paypal"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal2.png" alt="paypal"></p></li><li><p>注册成功后，在沙盒的账号控制页面：<a href="https://developer.paypal.com/developer/accounts/" target="_blank" rel="noopener">https://developer.paypal.com/developer/accounts/</a></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal3.png" alt="paypal"></p><p><strong>与支付宝沙箱一样，也有两个账号，一个商家，一个个人，当然也可以自己创建账号，点击蓝色按钮，即可创建</strong></p></li><li><p>接下来，我们要修改一下个人用户的信息</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal4.png" alt="paypal"></p><p><strong>Email ID 是支付的时候登陆的账号，密码建议修改</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal5.png" alt="paypal"></p><p><strong>接下来，我们修改一下<code>Funding</code>中的余额，以便我们测试使用</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal6.png" alt="paypal"></p></li><li><p>之后，进入应用管理页面：<a href="https://developer.paypal.com/developer/applications/" target="_blank" rel="noopener">https://developer.paypal.com/developer/applications/</a></p><p><strong>发现已有一个创建好的支付应用，并进入</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal11.png" alt="paypal"></p></li><li><p>记录下它的client_id和client_secret，会用到</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal12.png" alt="paypal"></p></li><li><p>做完这些之后，我们对沙箱的操作就已经完成了，我们进入下一步</p></li></ol><h3 id="安装PayPal的SDK，并进行测试"><a href="#安装PayPal的SDK，并进行测试" class="headerlink" title="安装PayPal的SDK，并进行测试"></a>安装PayPal的SDK，并进行测试</h3><h4 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h4><p>直接在终端窗口输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install paypalrestsdk</span><br></pre></td></tr></table></figure><p>完成下载:</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal7.png" alt="paypal"></p><h4 id="构建视图"><a href="#构建视图" class="headerlink" title="构建视图"></a>构建视图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paypalrestsdk</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment</span><span class="params">(request)</span>:</span></span><br><span class="line">    paypalrestsdk.configure(&#123;</span><br><span class="line">      <span class="string">"mode"</span>: <span class="string">"sandbox"</span>, <span class="comment"># sandbox代表沙盒</span></span><br><span class="line">      <span class="string">"client_id"</span>: <span class="string">"你的client_id,</span></span><br><span class="line"><span class="string">      "</span>client_secret<span class="string">": "</span>你的client_secret<span class="string">" </span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    payment = paypalrestsdk.Payment(&#123;</span></span><br><span class="line"><span class="string">        "</span>intent<span class="string">": "</span>sale<span class="string">",</span></span><br><span class="line"><span class="string">        "</span>paye<span class="string">r": &#123;</span></span><br><span class="line"><span class="string">            "</span>payment_method<span class="string">": "</span>paypal<span class="string">"&#125;,</span></span><br><span class="line"><span class="string">        "</span>redirect_urls<span class="string">": &#123;</span></span><br><span class="line"><span class="string">            "</span>return_url<span class="string">": "</span>http://localhost:<span class="number">8000</span>/palpay/pay/<span class="string">",#支付成功跳转页面</span></span><br><span class="line"><span class="string">            "</span>cancel_url<span class="string">": "</span>http://localhost:<span class="number">3000</span>/paypal/cancel/<span class="string">"&#125;,#取消支付页面</span></span><br><span class="line"><span class="string">        "</span>transactions<span class="string">": [&#123;</span></span><br><span class="line"><span class="string">            "</span>amount<span class="string">": &#123;</span></span><br><span class="line"><span class="string">                #价格，精确到分</span></span><br><span class="line"><span class="string">                "</span>total<span class="string">": "</span><span class="number">5.00</span><span class="string">",</span></span><br><span class="line"><span class="string">                #货币种类</span></span><br><span class="line"><span class="string">                "</span>currency<span class="string">": "</span>USD<span class="string">"&#125;,</span></span><br><span class="line"><span class="string">            "</span>description<span class="string">": "</span>这是一个订单测试<span class="string">"&#125;]&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if payment.create():</span></span><br><span class="line"><span class="string">        print("</span>Payment created successfully<span class="string">")</span></span><br><span class="line"><span class="string">        for link in payment.links:</span></span><br><span class="line"><span class="string">            if link.rel == "</span>approval_url<span class="string">":</span></span><br><span class="line"><span class="string">                approval_url = str(link.href)</span></span><br><span class="line"><span class="string">                print("</span>Redirect <span class="keyword">for</span> approval: %s<span class="string">" % (approval_url))</span></span><br><span class="line"><span class="string">                #直接重定向到支付页面</span></span><br><span class="line"><span class="string">                return redirect(approval_url)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print(payment.error)</span></span><br><span class="line"><span class="string">        return HttpResponse("</span>支付失败<span class="string">")</span></span><br></pre></td></tr></table></figure><p><strong>return_url是支付成功后回调的页面，paypal会将一个支付者id回传，然后服务端需要验证支付才能真的完成支付</strong></p><p><strong>在支付之前会提示输入<code>账号</code>与<code>密码</code>是沙箱环境的账号与密码</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal9.png" alt="paypal"></p><p>登陆成功之后跳转支付页面</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal8.png" alt="paypal"></p><p>支付完成之后，会跳转到我们定义的回调页面，并返回给我们参数：</p><p><code>http://localhost:8000/palpay/pay/?paymentId=PAYID-L3SYORA3C031930S1733650J&amp;token=EC-9TG269735K620131N&amp;PayerID=ETYYRCDN8C3XJ</code></p><p>这里paypal会传过来三个参数，支付id,token和支付者id</p><p>此时，我们的余额还没有扣除，需要用支付者的id进行确认</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment_execute</span><span class="params">(request)</span>:</span></span><br><span class="line">    paymentid = request.Get.get(<span class="string">"paymentId"</span>) <span class="comment">#订单id</span></span><br><span class="line">    payerid = request.Get.get(<span class="string">"PayerID"</span>)  <span class="comment">#支付者id</span></span><br><span class="line">    payment = paypalrestsdk.Payment.find(paymentid)</span><br><span class="line">    <span class="keyword">if</span> payment.execute(&#123;<span class="string">"payer_id"</span>: payerid&#125;):</span><br><span class="line">        print(<span class="string">"Payment execute successfully"</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"支付成功"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(payment.error) <span class="comment"># Error Hash</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"支付失败"</span>)</span><br></pre></td></tr></table></figure><p><strong>确定成功之后，paypal会扣除余额</strong></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal10.png" alt="paypal"></p><p>自此，一次交易完成</p><h4 id="根据订单号，退款"><a href="#根据订单号，退款" class="headerlink" title="根据订单号，退款"></a>根据订单号，退款</h4><p>通过获取到的<code>paymentId</code>，查询到该订单的交易明细</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#明细</span></span><br><span class="line">payment = paypalrestsdk.Payment.find(<span class="string">"paymentId"</span>)</span><br><span class="line">print(payment)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/paypal13.png" alt="paypal"></p><p>可以看到通过<code>paymentId</code>获取到了交易的状态，流水id，以及创建日期。</p><p><strong>通过获取到的流水号进行退款业务</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#退款</span></span><br><span class="line"><span class="keyword">from</span> paypalrestsdk <span class="keyword">import</span> Sale</span><br><span class="line">sale = Sale.find(<span class="string">"流水号"</span>)</span><br><span class="line"><span class="comment"># Make Refund API call</span></span><br><span class="line"><span class="comment"># Set amount only if the refund is partial</span></span><br><span class="line">refund = sale.refund(&#123;</span><br><span class="line">    <span class="string">"amount"</span>: &#123;</span><br><span class="line">        <span class="string">"total"</span>: <span class="string">"5.00"</span>,</span><br><span class="line">        <span class="string">"currency"</span>: <span class="string">"USD"</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># Check refund status</span></span><br><span class="line"><span class="keyword">if</span> refund.success():</span><br><span class="line">    print(<span class="string">"Refund[%s] Success"</span> % (refund.id))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Unable to Refund"</span>)</span><br><span class="line">    print(refund.error)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体而言，没有什么特别的难度，整个支付流程相对支付宝来说，更加的紧凑，但是做支付安全是第一要务，就个人体验（仅是个人体验）层面来说，支付宝在安全方面做的还是要比Paypal略强一些，起码在信用卡欺诈和盗刷方面风控做的更好，在风险保障和赔付方面都有提供保险，当然由于金融环境的差异较大，并不是说Paypal的风控做的不好，只是机制不同，在国外，如果持卡人的信用卡被盗刷，一般发卡组织会让商家去承担责任，而国内只能在交易环节设置更多的验证，本质上说是要持卡人承担责任。这也是为什么支付宝的风控看起来更好的原因。</p><p>  最后就是关于费率问题，Paypal官方给出的费率是每笔交易收取3.9%+$0.3（根据你的交易流水，比例可以优惠，具体下限看接入者的月营业额度），不过这可是美刀，不得不说这个费率是相当的高，但是国内做境外支付的电商，一般还是要接入Paypal作为支付方式。支付宝的费率基本上在1.2%左右，具体的费率也看交易流水，有实力的下限可以做到基本没有，单纯的看费率似乎支付宝更有优势，但是别忘记了，这样对比是不科学的，因为凡是接入Paypal的都是看中覆盖外币业务的地区，费率则是投资人该考虑的问题了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://www.sirxs.cn/tags/Vue/"/>
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OOP总结</title>
    <link href="http://www.sirxs.cn/2020/06/17/Note/oop/"/>
    <id>http://www.sirxs.cn/2020/06/17/Note/oop/</id>
    <published>2020-06-17T05:54:10.000Z</published>
    <updated>2020-06-22T11:35:35.560Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Python 是一种解释型、面向对象、的高级程序设计语言。</p><p>那什么是面向对象呢</p><p>与面向对象经常拿来对比的就是面向过程编程，那么他们之间的区别在什么地方呢？</p><p>打个比方 ，我们买过的一般的玩具（变形金刚），我们必须要按照它说明书上的步骤，一步一步的去组装，才能得到最后的玩具，如果我们想要一个新的玩具，就要去商场买一个新的，然后按照说明书的顺序一步一步的组装。这就是面向过程</p><p>而面型对象呢？就可以理解为积木，没有一个固定的拼装方式，我们可以发挥自己的想象力，去自由的拼装和组装，同样的模块在不同的地方可以起到不同的作用（多态），一块儿积木就是一个最小的单位，我们哪里需要就放到哪里（封装）。也可以用多个对象组装起来去拼装成一个新的对象（继承）。大大的方便了我们的设计，不再拘泥于过程，极大程度上的放飞了生产力和效率。</p><p>总的来说就是<code>封装</code>,<code>继承</code>,<code>多态</code>，<code>抽象</code></p><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。</p><p>所以，在使用面向对象的封装特性时，需要：</p><ul><li>将内容封装到某处</li><li>从某处调用被封装的内容</li></ul><p>一、将内容封装到某处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="comment">#创建并初始化它的属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">obj2 = Foo(<span class="string">'老刘'</span>,<span class="number">28</span>)</span><br><span class="line"><span class="comment"># 将老刘与28分别封装到obj2的name与age属性中</span></span><br></pre></td></tr></table></figure><p>二、从某处调用被封装的内容</p><p>调用被封装的内容时，有两种情况：</p><ul><li>通过对象直接调用</li><li>通过self间接调用</li></ul><p>1、通过对象直接调用被封装的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">print(obj1.name) <span class="comment"># 直接调用obj1对象的name属性</span></span><br><span class="line">print(obj1.age) <span class="comment"># 直接调用obj1对象的age属性</span></span><br></pre></td></tr></table></figure><p>2、通过self间接调用被封装的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self)</span>:</span></span><br><span class="line">print(self.name)</span><br><span class="line">print(self.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据类Foo创建对象</span></span><br><span class="line"><span class="comment"># 自动执行Foo类的__init__方法</span></span><br><span class="line">obj1 = Foo(<span class="string">'老王'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 将老王与18分别封装到obj1的name与age属性中</span></span><br><span class="line">obj1.detail() <span class="comment"># Python默认会将obj1传给self参数，即：obj1.detail(obj1)，所以，此时方法内部的 self ＝ obj1，即：self.name 是 wupeiqi ；self.age 是 18</span></span><br></pre></td></tr></table></figure><p><strong>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</strong></p><p>继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。</p><p>例如：</p><p>　　老王可以：吃、喝、奥利给</p><p>　　老刘可以：吃、喝、奥利给</p><p>如果我们要分别为老王和老刘创建一个类，那么就需要为 老王 和 老刘 实现他们所有的功能，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s在吃'</span>%self.name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s在喝'</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类并继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s奥利给'</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子类并继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoLiu</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">'%s奥利给'</span>%self.name)</span><br><span class="line"></span><br><span class="line">c1 = LaoWang(<span class="string">'老王'</span>)</span><br><span class="line"><span class="comment"># 调用父类方法</span></span><br><span class="line">c1.eat()</span><br><span class="line">c1.drink()</span><br><span class="line"><span class="comment"># 调用自身方法</span></span><br><span class="line">c1.cry()</span><br><span class="line">print(<span class="string">'==================='</span>)</span><br><span class="line">c2 = LaoLiu(<span class="string">'老刘'</span>)</span><br><span class="line"><span class="comment"># 调用父类方法</span></span><br><span class="line">c2.eat()</span><br><span class="line">c2.drink()</span><br><span class="line"><span class="comment"># 调用自身方法</span></span><br><span class="line">c2.cry()</span><br></pre></td></tr></table></figure><p>多态，字面理解为多种形态，没错，就是一个方法能表现出不同的形态。</p><p>同一<strong>方法</strong>作用于不同的对象，可以有不同的解释，产生不同的结果。</p><p>现实中多态的例子举不胜举，比如我按下回车键，如果在word中就是换行，如果在QQ的发送消息界面就是发送消息，如果在命令行界面就是执行命令等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sex == <span class="string">"男士"</span>:</span><br><span class="line">            print(<span class="string">"%s是man"</span>%self.name)</span><br><span class="line">        <span class="keyword">elif</span> self.sex == <span class="string">"女士"</span>:</span><br><span class="line">            print(<span class="string">"%s是woman"</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Person)</span>:</span><span class="comment"># Child 继承 Person</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sex == <span class="string">"男士"</span>:</span><br><span class="line">            print(<span class="string">"%s是boy"</span>%self.name)</span><br><span class="line">        <span class="keyword">elif</span> self.sex == <span class="string">"女士"</span>:</span><br><span class="line">            print(<span class="string">"%sgirl"</span>%self.name)</span><br><span class="line"></span><br><span class="line">老王 = Child(<span class="string">"老王"</span>,<span class="string">"男士"</span>)</span><br><span class="line">小红 = Person(<span class="string">"小红"</span>,<span class="string">"女士"</span>)</span><br><span class="line"></span><br><span class="line">老王.print_title()</span><br><span class="line">小红.print_title()</span><br></pre></td></tr></table></figure><p>抽象：</p><p>提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：<strong>属性（数据）和操作（行为）</strong>。这个抽象模型我们称之为<strong>类</strong>。对类进行实例化得到对象。</p><p>抽象——就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。(就是把现实世界中的某一类东西，提取出来，用程序代码表示，抽象出来一般叫做类或者接口。)抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是数据抽象，二是过程抽象。</p><p>数据抽象——就是用代码的形式表示现时世界中一类事物的特性，就是针对对象的属性。比如建立一个鸟这样的类，鸟都有以下属性：一对翅膀、两只脚、羽毛等。抽象出来的类都是鸟的属性，或者成员变量。</p><p>过程抽象——就是用代码形式表示现实世界中事物的一系列行为，就是针对对象的行为特征。比如鸟会飞、会叫等。抽象出来的类一般都是鸟的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>md5数据加密</title>
    <link href="http://www.sirxs.cn/2020/06/16/Note/md5/"/>
    <id>http://www.sirxs.cn/2020/06/16/Note/md5/</id>
    <published>2020-06-16T05:54:10.000Z</published>
    <updated>2020-06-16T08:29:21.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p><strong>MD5信息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://baike.baidu.com/item/密码散列函数/14937715" target="_blank" rel="noopener">密码散列函数</a>，可以产生出一个128位（16<a href="https://baike.baidu.com/item/字节/1096318" target="_blank" rel="noopener">字节</a>）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家<a href="https://baike.baidu.com/item/罗纳德·李维斯特/700199" target="_blank" rel="noopener">罗纳德·李维斯特</a>（Ronald Linn Rivest）设计，于1992年公开，用以取代<a href="https://baike.baidu.com/item/MD4/8090275" target="_blank" rel="noopener">MD4</a>算法。这套算法的程序在 RFC 1321 标准中被加以规范。1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如<a href="https://baike.baidu.com/item/SHA-2/22718180" target="_blank" rel="noopener">SHA-2</a>。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如<a href="https://baike.baidu.com/item/SSL/320778" target="_blank" rel="noopener">SSL</a>公开密钥认证或是<a href="https://baike.baidu.com/item/数字签名/212550" target="_blank" rel="noopener">数字签名</a>等用途。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p>下载md5包<code>npm install js-md5</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;js-md5&quot;: &quot;^0.7.3&quot;</span><br></pre></td></tr></table></figure><p>测试，并打印出md5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line"><span class="number">666</span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> md5 <span class="keyword">from</span> <span class="string">'js-md5'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//注册组件标签</span></span><br><span class="line">  components:&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//  设置秘钥，增加安全性  (应放在配置文件)</span></span><br><span class="line">    <span class="keyword">var</span> ed = <span class="string">'2020'</span></span><br><span class="line">     <span class="comment">//price:总价 goodid:商品id(3,1)</span></span><br><span class="line"><span class="keyword">var</span> sign = md5(<span class="string">'price=500&amp;goodid=3,1'</span> + ed)</span><br><span class="line">    <span class="built_in">console</span>.log(sign);</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a4299afde799fa1bf6d1ba0c13b0def7</span><br></pre></td></tr></table></figure><h4 id="Django-后端"><a href="#Django-后端" class="headerlink" title="Django(后端)"></a>Django(后端)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改price</span></span><br><span class="line">price = <span class="string">"1"</span></span><br><span class="line">goodid = <span class="string">"3,1"</span></span><br><span class="line"><span class="comment">#前端传的sign</span></span><br><span class="line">sign = <span class="string">"a4299afde799fa1bf6d1ba0c13b0def7"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"><span class="comment">#组合要加密的字符串</span></span><br><span class="line">sign_str = <span class="string">"price="</span>+price+<span class="string">"&amp;goodid="</span>+goodid+<span class="string">"2020"</span></span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">mysign = str(sign_str).encode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">#设置加密</span></span><br><span class="line">md5.update(mysign)</span><br><span class="line">mysign = md5.hexdigest()</span><br><span class="line"><span class="comment">#判断</span></span><br><span class="line">print(mysign)</span><br><span class="line"><span class="keyword">if</span> sign == mysign:</span><br><span class="line">print(<span class="string">"pass"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">"数据被篡改"</span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8c6849857cfeab25fa83bf7497943022</span><br><span class="line">数据被篡改</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>md5加密不经常用，但在设计到重要信息(金钱，虚拟币，商品)的时候会给我们数据带来非常安全的保障</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>（支付宝模拟支付）使用python3.7+Vue.js2.0+Django2.0.4实现支付宝模拟支付功能</title>
    <link href="http://www.sirxs.cn/2020/06/13/Blog/Alipay_Sandbox/"/>
    <id>http://www.sirxs.cn/2020/06/13/Blog/Alipay_Sandbox/</id>
    <published>2020-06-13T07:54:00.000Z</published>
    <updated>2021-06-21T08:11:19.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>在当今科技发达的时代，纸币已将慢慢的从人们的口袋消失。随着带来的是更方便的电子货币（手机虚拟货币）。<a href="https://baike.baidu.com/item/%E6%94%AF%E4%BB%98%E5%AE%9D/496859" target="_blank" rel="noopener">支付宝</a>，是我国比较强大的第三方支付平台，也被广大人群所喜爱。在当今的基本所有网上购物平台都支持支付宝支付，所以我们用支付宝沙箱环境来模拟实现三方支付</p><h4 id="什么是沙箱环境"><a href="#什么是沙箱环境" class="headerlink" title="什么是沙箱环境"></a>什么是沙箱环境</h4><p>蚂蚁沙箱环境 (Beta) 是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考下文的 <strong>沙箱支持产品</strong> 列表）。 在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。 如何使用和配置沙箱环境请参考下文 <strong>如何使用沙箱环境</strong>。</p><p><strong>注意</strong></p><ul><li>由于沙箱为模拟环境，在沙箱完成接口开发及主要功能调试后，请务必在蚂蚁正式环境进行完整的功能验收测试。所有返回码及业务逻辑以正式环境为准。</li><li>为保证沙箱稳定，沙箱环境测试数据会进行定期数据清理。Beta 测试阶段每周日中午12点至每周一中午12点为维护时间，在此时间内沙箱环境部分功能可能会不可用，敬请谅解。</li><li>请勿在沙箱进行压力测试，以免触发相应的限流措施，导致无法正常使用沙箱环境。</li><li>沙箱支持的各个开放产品，沙箱使用的特别说明请参考各产品的快速接入文档或技术接入文档章节。</li></ul><h3 id="如何使用沙箱环境"><a href="#如何使用沙箱环境" class="headerlink" title="如何使用沙箱环境"></a>如何使用沙箱环境</h3><h4 id="第一步配置沙箱应用环境"><a href="#第一步配置沙箱应用环境" class="headerlink" title="第一步配置沙箱应用环境"></a>第一步配置沙箱应用环境</h4><ol><li><p>进入 <strong>开放平台 &gt; 开发者中心</strong> 在开发服务选项中点击 <strong>研发服务</strong> 即可进入 <a href="https://openhome.alipay.com/platform/appDaily.htm" target="_blank" rel="noopener">沙箱环境</a>。</p><p><img src= "/img/loading.gif" data-src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/254687/1589449249412-2fc126a6-4ae8-466d-8b94-be85ca191dc4.png" alt="alipay"></p></li><li><p>进入沙箱环境页面，系统已经自动为你创建一个应用，在 <strong>信息配置</strong> 中可以看到应用信息。</p><p><img src= "/img/loading.gif" data-src="https://static.dingtalk.com/media/lALOnH_0fM0BHM0Cog_674_284.png" alt="alipay"></p><ol><li>沙箱环境密钥设置支持上传 RSA2(SHA256) 的应用公钥和公钥证书两种形式，详见 <a href="https://opendocs.alipay.com/open/291/105971" target="_blank" rel="noopener">生成RSA密钥</a>。配置 RSA2(SHA256) 的应用公钥后，不需要配置 RSA(SHA1) 密钥，签名算法区别参见<a href="https://opendocs.alipay.com/open/291/106115" target="_blank" rel="noopener"> RSA 和RSA2 签名算法区别</a>。配置 crs 公钥证书时 <strong>组织/公司</strong> 需填写为 <strong>沙箱环境</strong>；</li><li>编写代码时，请将：</li></ol><ul><li>请求网关修改为：<code>https://openapi.alipaydev.com/gateway.do</code></li><li>appid 切换为沙箱的 appid</li><li>签名方式使用 RSA2</li><li>应用私钥（private_key）使用第 1 步生成的 RSA2 (SHA256) 的私钥(请根据开发语言进行选择原始或 pkcs8 格式)。</li><li>支付宝公钥（public_key）切换为第 1 步配置后应用公钥后，点击查看支付宝公钥看到的公钥。</li></ul><p><img src= "/img/loading.gif" data-src="https://static.dingtalk.com/media/lALOsWs3ic0Bus0CNw_567_442.png_620x10000q90g.jpg" alt="alipay"></p><p>选看部分作为进阶使用，非必填项；</p><ol><li>应用网关：该地址用于接收开放平台的异步通知。目前沙箱环境不需要配置此参数；</li><li>授权回调地址；第三方应用授权或获取用户信息中用于接收授权回调信息的地址。使用相关产品时需进行配置：</li></ol><ul><li>第三方应用授权：授权 url 中的 redirect_uri 必须与此值相同。</li><li>获取用户信息：授权 url 中的 redirect_uri 的域名必须与此值相同(例如：授权回调地址配置：<a href="https://auth.example.com/authCallBack" target="_blank" rel="noopener">https://auth.example.com/authCallBack</a> 高亮部分需和授权url相同)。</li></ul><ol><li>AES 密钥：目前不再使用。</li></ol></li></ol><h4 id="第二步根据文档写代码"><a href="#第二步根据文档写代码" class="headerlink" title="第二步根据文档写代码"></a>第二步根据文档写代码</h4><h4 id="电脑网站支付流程"><a href="#电脑网站支付流程" class="headerlink" title="电脑网站支付流程"></a>电脑网站支付流程</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/%E7%94%B5%E8%84%91%E7%BD%91%E7%AB%99%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="alipay"></p><h4 id="后端接口设计"><a href="#后端接口设计" class="headerlink" title="后端接口设计"></a>后端接口设计</h4><p><strong>请求方式</strong>： GET </p><p><strong>请求参数</strong>： 路径参数</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>order</td><td>str</td><td>是</td><td>订单编号</td></tr><tr><td>price</td><td>int</td><td>是</td><td>订单价格</td></tr></tbody></table><p><strong>返回数据</strong>： JSON</p><table><thead><tr><th>返回值</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>alipay_url</td><td>str</td><td>是</td><td>支付宝支付链接</td></tr></tbody></table><h4 id="后端实现（支付请求接口）"><a href="#后端实现（支付请求接口）" class="headerlink" title="后端实现（支付请求接口）"></a>后端实现（支付请求接口）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from alipay import AliPay</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">class Alipay(APIView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">         # 随机生成订单号</span><br><span class="line">        order = datetime.datetime.now().strftime("%Y%m%d%H%M%S") + str(random.randint(10, 99))</span><br><span class="line">        # 获取支付价格</span><br><span class="line">        price = request.GET.get("price", None)</span><br><span class="line">        # 获取token</span><br><span class="line">        jwt_token = request.GET.get("token",None)</span><br><span class="line">        try:</span><br><span class="line">            user_json = jwt_decode_handler(jwt_token)</span><br><span class="line">            # 获取token中的uid</span><br><span class="line">            user_id = user_json['user_id']</span><br><span class="line">        except:</span><br><span class="line">            return Response(&#123;"code":405,"message":"用户信息已失效，请重新登录"&#125;)</span><br><span class="line">        # 读取私钥及公钥</span><br><span class="line">        app_private_key_string = open("pay/private.txt").read()</span><br><span class="line">        alipay_public_key_string = open("pay/public.txt").read()</span><br><span class="line"></span><br><span class="line">        alipay = AliPay(</span><br><span class="line">            appid="支付宝沙箱id",</span><br><span class="line">            app_notify_url= None,  # 默认回调url</span><br><span class="line">            app_private_key_string=app_private_key_string,</span><br><span class="line">            alipay_public_key_string=alipay_public_key_string,</span><br><span class="line">            # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">            sign_type="RSA2",  # RSA 或者 RSA2</span><br><span class="line">            debug=True  # 默认False</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_string</span><br><span class="line">        order_str = alipay.api_alipay_trade_page_pay(</span><br><span class="line">            subject="返回名称",</span><br><span class="line">            notify_url=None,</span><br><span class="line">            out_trade_no=order,      # 订单号</span><br><span class="line">            total_amount=price,         # 订单价格</span><br><span class="line">            return_url="http://127.0.0.1:8000/get_alipy/"</span><br><span class="line">        )</span><br><span class="line"># 拼接支付宝支付页面网址url</span><br><span class="line">        request_url = 'https://openapi.alipaydev.com/gateway.do?' + order_str</span><br><span class="line"></span><br><span class="line">        return Response(&#123;</span><br><span class="line">            "code": 200,</span><br><span class="line">            "msg": "请求成功，跳转支付页面",</span><br><span class="line">            "data": request_url</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="后端实现（获取回调网站数据）"><a href="#后端实现（获取回调网站数据）" class="headerlink" title="后端实现（获取回调网站数据）"></a>后端实现（获取回调网站数据）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Get_Alipy(APIView):</span><br><span class="line">    def get(self,request):</span><br><span class="line">        user = request.query_params</span><br><span class="line">        # 获取支付用户id</span><br><span class="line">        uid = r.get("payuid")</span><br><span class="line">        # 获取订单号及价格  并将单位换算成分</span><br><span class="line">        price = int(float(user["total_amount"])*100)</span><br><span class="line">        order = user["out_trade_no"]</span><br><span class="line">        # 订单表中生成订单</span><br><span class="line">        Order.objects.create(uid=int(uid),order=order,price=price)</span><br><span class="line">        return Response(&#123;"code":200,"message":"购买成功"&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>支付宝沙箱环境是一个好东西，不需要商家认证那些，开发者可以直接整代码并且效果和实际上线效果是一样的。是一些技术研究者的福音。</p><p><strong>更多详情请查看</strong>：</p><ul><li><strong>文档主页</strong>：<a href="https://openhome.alipay.com/developmentDocument.htm" target="_blank" rel="noopener">https://openhome.alipay.com/developmentDocument.htm</a></li><li><strong>产品介绍</strong>：<a href="https://docs.open.alipay.com/270" target="_blank" rel="noopener">https://docs.open.alipay.com/270</a></li><li><strong>快速接入</strong>：<a href="https://docs.open.alipay.com/270/105899/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105899/</a></li><li>SDK：<a href="https://docs.open.alipay.com/270/106291/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/106291/</a><ul><li><strong>python对接支付宝SDK</strong>：<a href="https://github.com/fzlee/alipay/blob/master/README.zh-hans.md" target="_blank" rel="noopener">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a></li><li><strong>python对接支付宝SDK安装</strong>：<code>pip install python-alipay-sdk --upgrade</code></li></ul></li><li><strong>API列表</strong>：<a href="https://docs.open.alipay.com/270/105900/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/105900/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://www.sirxs.cn/tags/Vue/"/>
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>snowflake分布式唯一算法</title>
    <link href="http://www.sirxs.cn/2020/06/12/Blog/snowflake/"/>
    <id>http://www.sirxs.cn/2020/06/12/Blog/snowflake/</id>
    <published>2020-06-12T07:54:00.000Z</published>
    <updated>2020-06-12T13:19:18.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>ID一般用来作为数据库表的主键，需要保证唯一性，通常情况下可以有以下几种方式实现：</p><p>1.UUID（Universally Unique Identifier）：</p><p>UUID是由一组32位数的16进制数字所构成的通用唯一识别码，可以保证ID的全局唯一性，但由于数据库或者文件系统的索引一般是由B+树构成的，而UUID插入完全无序，经常会导致一些中间节点合并和分裂，大大降低了数据库插入性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">print(uuid.uuid1())</span><br><span class="line"><span class="number">12725082</span>-acaa<span class="number">-11</span>ea<span class="number">-98</span>eb-e86a64ddceb7</span><br></pre></td></tr></table></figure><p>2.自增ID：</p><p>现在很多数据库引擎都支持自增ID，自增ID最大的好处是每次插入都在末尾，这样可以很大程度的减少节点的合并和分裂。而且自增ID所占空间也比UUID要小。但是自增ID只能保证一个库中一张表的ID唯一，往往不能保证多个库多张表的ID唯一，这样多个库之间合并的时候会因为主键冲突而失败。</p><p>3.自增ID+哈希取模：</p><p>如果数据量比较大，可以用n台机器存储。每台机器设置不同的起始值，所有机器的步长和机器数量相同。相当于自增ID与机器数量哈希取模。比如有3台机器，第一台设置1,4,7……；第二台设置2,5,8……；第三台设置3,6,9……但是这样的话，ID的生成对数据库严重依赖，一旦数据库挂掉，服务将变得不可用。</p><p>4.SnowFlake：</p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p>分布式情况下SnowFlake是一种生成ID比较好的算法。</p><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等。</p><h3 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号，最后还有一个符号位，永远是0。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow2.png" alt="gitee"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li><p>首先安装库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pysnowflake</span><br></pre></td></tr></table></figure></li><li><p>接下来在本地启动snowflake服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snowflake_start_server --worker&#x3D;1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow3.png" alt="gitee"></p></li><li><p>这里值得说下的是可以通过定义端口号来实现运行多个服务</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow4.png" alt="gitee"></p></li><li><p>然后使用<code>setup</code>指定<code>ip</code>与<code>端口</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow5.png" alt="gitee"></p></li><li><p>之后就是对snowflake生成的id进行分析</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/snow1.png" alt="gitee"></p><p><strong>有人就会问，假设我搭建了上千个节点的分布式系统，此时接口接到参数id,我怎么判断该id的订单信息存储在那个节点中呢？</strong></p></li><li><p>其实很容易就可以判断，从SnowFlake的算法结构入手，本身就是二进制转换十进制的整形，现在我们反着进行解析即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先将其转换为二进制</span></span><br><span class="line">print(bin(<span class="number">4369145685749010433</span>))</span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line"><span class="number">0b11110010100010010100101101101000111011000000000001000000000001</span></span><br></pre></td></tr></table></figure></li><li><p>之前我们说第一位是标识符，此后是41位的时间戳，紧接着10位的节点标识码，最后12位的递增序列，从后面数12位是：000000000001，再数5位是：<code>00001</code> 这5位就是某个节点的存储标识，我们就二进制的<code>00001</code>转换为十进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点标识</span></span><br><span class="line">a = bin(<span class="number">4369049307706298369</span>)[<span class="number">47</span>:<span class="number">52</span>]</span><br><span class="line">print(<span class="string">'节点标识二进制%s'</span>%a)</span><br><span class="line"><span class="comment"># 强转十进制</span></span><br><span class="line">print(int(a,<span class="number">2</span>))</span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">节点标识二进制<span class="number">00001</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到，转换结果显示该id存储在节点1的数据库中</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实关于分布式唯一id的解决方案，也不仅仅只有uuid或者snowflake，像redis的incr原子性操作自增，亦或者Mongodb极具特色的_objectid的生成方式，专为分布式而设计的ID生成方案。都是可以参考的解决方案，但是方案总归是方案，总有其自身的特点和缺陷，这就需要根据实际应用场景而具体问题进行具体分析了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>单点登录（SSO）的设计与实现</title>
    <link href="http://www.sirxs.cn/2020/06/10/Note/oss/"/>
    <id>http://www.sirxs.cn/2020/06/10/Note/oss/</id>
    <published>2020-06-10T00:00:00.000Z</published>
    <updated>2020-06-11T00:17:52.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>单点登录英文全称Single Sign On，简称就是SSO。它的解释是：<strong>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</strong></p><p>两个站点如果在同域下，那么它们之间是可以共享cookie的。简单的说就是这种同域下不同站点的sso实现可以通过cookie来实现，当用户访问这个域下面的任意站点时，浏览器都会将这个cookie发送给站点对应的系统。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss.jpg" alt="oss"></p><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>比如阿里系的<strong>淘宝和天猫</strong>，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2019/5/15/16abb63967305d5d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="oss"></p><p>简单来说，单点登录就是<strong>在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。</strong></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="第一种方式：凭借cookie，应用间的重定向"><a href="#第一种方式：凭借cookie，应用间的重定向" class="headerlink" title="第一种方式：凭借cookie，应用间的重定向"></a>第一种方式：凭借cookie，应用间的重定向</h4><p>这种方式比较简单，当用户在上面三个站点中的任意一个站点登录成功时，必须在浏览器中同时设置其他站点的cookie信息。<br> 例如：当用户登录site1站点，并且验证通过之后，浏览器会存储一份site1站点的cookie信息，这时，为了实现单点登录（为了在site2站点和site3站点无需登录），那么我们需要在浏览器设置site2站点和site3站点的cookie信息，因此，在用户登录site1站点的请求响应之前，需要从siteId1站点重定向到site2站点和site3站点去设置cookie信息，这样就可以保证，在任意站点登录成功之后，在浏览器也有其他站点的cookie信息。下图可具体展示其中流程：</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss2.jpg" alt="oss"></p><p>这种方式其实过程比较简单，只需要确保登录其中一个站点在浏览器设置cookie其他站点都在浏览器设置对应cookie，就可以实现单点登录了（单点退出是一样的道理，一个退出清除cookie，其他也清除）。<br> 但是这种方式有一个非常明显的缺点是：这里举例是3个站点，如果是几十个上百个站点再使用这种方式将非常影响效率。</p><h4 id="第二种方式：借助单独的SSO服务器"><a href="#第二种方式：借助单独的SSO服务器" class="headerlink" title="第二种方式：借助单独的SSO服务器"></a>第二种方式：借助单独的SSO服务器</h4><p>这种方式需要借助一个单独的SSOServer，相对于上一种方式，这种方式就不需要将每个站点的cookie信息都保存在浏览器上，浏览器只需要保存SSOServer的cookie信息。将这个cookie信息用于需要做单点登录的所有站点中。<br> 对于这种方式，在浏览器对于任意一个站点的请求都将会先重定向到SSOServer去验证代表当前用户的cookie是否存在，如果存在，那么将验证成功后的跳转页面发送给浏览器，否则将跳转到登录页面提示用户登录。可参考如下图</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/oss3.jpg" alt="oss"></p><p>由于site1和site2的单点登录与site1、site2、site3之间的单点登录是同样道理的（因为登录site1后去访问site2和site3的流程都是相同的），所以，这里借助site1和site2的单点登录来说明这种方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Vue" scheme="http://www.sirxs.cn/tags/Vue/"/>
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>（又拍云云存储）使用python3.7+Vue.js2.0+Django2.0.4实现又拍云云存储的异步文件上传功能</title>
    <link href="http://www.sirxs.cn/2020/06/09/Blog/upyun/"/>
    <id>http://www.sirxs.cn/2020/06/09/Blog/upyun/</id>
    <published>2020-06-09T07:54:00.000Z</published>
    <updated>2020-06-13T12:59:36.914Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h3><p>上次我们实现了<a href="https://www.sirxs.cn/2020/06/08/Blog/qiniu/">七牛云异步上次文件</a>，今天我们来实现又拍云的异步文件上传功能</p><p>话不多说，直接实现吧</p><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><ol><li><p>首先进入又拍云官网：<a href="https://www.upyun.com/" target="_blank" rel="noopener">https://www.upyun.com/</a>，进行<code>注册登陆</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun1.png" alt="upyun"></p></li><li><p>登陆成功后，进入<code>控制台</code>,找到<code>云服务</code>，并进入</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun2.png" alt="upyun"></p></li><li><p>进入之后，<code>创建服务</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun3.png" alt="upyun"></p></li><li><p>这里与七牛云不同的是需要我们<code>新建一个授权操作员</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun4.png" alt="upyun"></p></li><li><p>进入<code>创建操作员</code>之后，将权限全部勾选，而且这个密码是一次性密码，需要我们记录</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun5.png" alt="upyun"></p></li><li><p>创建服务成功之后，进入<code>存储管理</code>，下面可以定义操作员<code>权限</code></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun6.png" alt="upyun"></p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun7.png" alt="upyun"></p></li></ol><h4 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h4><p>使用又拍云还需要安装一个库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install upyun</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun8.png" alt="upyun"></p><h3 id="Django-获取文件，并上传"><a href="#Django-获取文件，并上传" class="headerlink" title="Django(获取文件，并上传)"></a>Django(获取文件，并上传)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义文件上传类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        up = upyun.UpYun(<span class="string">'你的空间名称'</span>, username=<span class="string">'操作员账号'</span>, password=<span class="string">'操作员密码'</span>)</span><br><span class="line">        headers = &#123; <span class="string">'x-gmkerl-rotate'</span>: <span class="string">'180'</span> &#125;</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            res = up.put(<span class="string">'/touxiang1.jpg'</span>, chunk, checksum=<span class="literal">True</span>, headers=headers)</span><br><span class="line">        <span class="comment">#返回结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'filename'</span>:img.name&#125;),content_type=<span class="string">'application/json'</span>)</span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#多线程上传视频文件</span></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpYunVideo</span><span class="params">(APIView)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line"><span class="comment"># 获取视频文件</span></span><br><span class="line">video = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">print(video)</span><br><span class="line">name = video.name</span><br><span class="line">up = upyun.UpYun(<span class="string">'你的空间名称'</span>,<span class="string">'操作员账号'</span>,<span class="string">'操作员密码'</span>)</span><br><span class="line"><span class="comment"># 分块上传</span></span><br><span class="line"><span class="comment"># 创建一个分块上传实例(设置上传路径)</span></span><br><span class="line">uploader = up.init_multi_uploader(<span class="string">'/edu/%s'</span>%name)</span><br><span class="line">threads = []</span><br><span class="line">t1 = threading.Thread(target=uploader.upload,args=(<span class="number">0</span>,<span class="string">'分割文件'</span>))</span><br><span class="line">threads.append(t1)</span><br><span class="line">t2 = threading.Thread(target=uploader.upload,args=(<span class="number">1</span>,<span class="string">'分割文件'</span>))</span><br><span class="line">threads.append(t2)</span><br><span class="line"><span class="comment"># 启动多线程</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 阻塞主进程</span></span><br><span class="line">t.join()</span><br><span class="line"><span class="comment"># 调用结束</span></span><br><span class="line">res = uploader.complete()</span><br><span class="line"><span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'filename'</span>:name&#125;),content_type=<span class="string">'application/json'</span>)</span><br></pre></td></tr></table></figure><h3 id="Vue-获取视频数据，传给后端"><a href="#Vue-获取视频数据，传给后端" class="headerlink" title="Vue(获取视频数据，传给后端)"></a>Vue(获取视频数据，传给后端)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;input @change=<span class="string">"upyun_video"</span> type=<span class="string">"file"</span> &gt;</span><br><span class="line">      上传进度：&#123;&#123;fileloadv&#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 进度条视频</span></span><br><span class="line">      fileloadv:<span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//注册组件标签</span></span><br><span class="line">  components:&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="comment">// 上传七牛(视频)</span></span><br><span class="line">    upyun_video(e)&#123;</span><br><span class="line">      <span class="comment">// 获取文件对象</span></span><br><span class="line">      <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">      <span class="keyword">let</span> param = <span class="keyword">new</span> FormData();</span><br><span class="line">      <span class="comment">// 添加文件</span></span><br><span class="line">      param.append(<span class="string">'file'</span>,file);</span><br><span class="line">      <span class="keyword">const</span> config = &#123;</span><br><span class="line">        headers :&#123;</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 定制化axios</span></span><br><span class="line">      <span class="keyword">const</span> axios_upyun = <span class="keyword">this</span>.axios.create(&#123;<span class="attr">withCredentials</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">      axios_upyun(&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        url:<span class="string">'http://localhost:8000/upyun/'</span>,</span><br><span class="line">        data:param,</span><br><span class="line">        timeout:<span class="number">30000</span>,</span><br><span class="line">        config:config,</span><br><span class="line">        <span class="comment">// 上传进度</span></span><br><span class="line">        onUploadProgress:<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 计算</span></span><br><span class="line">          <span class="keyword">var</span> com = (e.loaded / e.total);</span><br><span class="line">          <span class="comment">// 判断</span></span><br><span class="line">          <span class="keyword">if</span>(com &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.fileloadv = (com * <span class="number">100</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(res)</span><br><span class="line">         <span class="keyword">this</span>.fileloadv = <span class="string">'100%'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>页面效果</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun9.png" alt="upyun"></p><p>上传成功，返回值</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun10.png" alt="upyun"></p><p>查看文件(上传成功)</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun11.png" alt="upyun"></p><p>同时，又拍云也可以用测试域名（CNAME）+ 设置的路径 + 获取到的名称，来实现查看文件</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/upyun12.png" alt="upyun"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>又拍云上传文件与七牛云上传文件其实，实现的过程没有什么太大的区别，之重要的是又拍云的免费流量比七牛云多出大概5g左右，当然了得加入一个所谓的又拍云联盟：<a href="https://www.upyun.com/league" target="_blank" rel="noopener">https://www.upyun.com/league</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="编程 · 技术" scheme="http://www.sirxs.cn/categories/%E7%BC%96%E7%A8%8B-%C2%B7-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Vue" scheme="http://www.sirxs.cn/tags/Vue/"/>
    
      <category term="Django" scheme="http://www.sirxs.cn/tags/Django/"/>
    
      <category term="Python" scheme="http://www.sirxs.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://www.sirxs.cn/2020/06/08/Note/reids%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://www.sirxs.cn/2020/06/08/Note/reids%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-06-08T00:00:00.000Z</published>
    <updated>2020-06-08T07:39:29.826Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>知识是珍贵宝石的结晶,文化是宝石放出的光泽。——泰戈尔</p><hr><h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>在<code>Redis</code>安装目录下找到<code>redis.windows.conf</code>这个文件，并打开</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/redis9.png" alt="redis"></p><p>下图就是RDB开启方式</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/RDB.png" alt="RDB"></p><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发</p><h4 id="1）触发机制"><a href="#1）触发机制" class="headerlink" title="1）触发机制"></a>1）触发机制</h4><p>手动触发分别对应save和bgsave命令</p><p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用</p><p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</p><h4 id="2）自动触发RDB的持久"><a href="#2）自动触发RDB的持久" class="headerlink" title="2）自动触发RDB的持久"></a>2）自动触发RDB的持久</h4><p>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改 时，自动触发bgsave。</p><p>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。</p><p>执行debug reload命令重新加载Redis时，也会自动触发save操作。</p><p>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则 自动执行bgsave。</p><p>bgsave是主流的触发RDB持久化方式</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp.png" alt="img"></p><p>执行bgsave命令，Redis父进程判断当前是否存在正在执行的子进 程，如RDB/AOF子进程，如果存在bgsave命令直接返回。</p><p>父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞，通 过info stats命令查看latest_fork_usec选项，可以获取最近一个fork操作的耗时，单位为微秒</p><p>父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，可以继续响应其他命令。</p><p>子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。执行lastsave命令可以获取最后一次生成RDB的 时间，对应info统计的rdb_last_save_time选项。</p><p>进程发送信号给父进程表示完成，父进程更新统计信息，具体见 info Persistence下的rdb_*相关选项。</p><p>RDB文件的处理</p><p>保存：RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配 置指定。可以通过执行config set dir{newDir}和config set dbfilename{newFileName}运行期动态执行，当下次运行时RDB文件会保存到新目录。</p><h1 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h1><h4 id="RDB的优点："><a href="#RDB的优点：" class="headerlink" title="RDB的优点："></a>RDB的优点：</h4><p>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据 快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</p><p>Redis加载RDB恢复数据远远快于AOF的方式。</p><h4 id="RDB的缺点："><a href="#RDB的缺点：" class="headerlink" title="RDB的缺点："></a>RDB的缺点：</h4><p>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运 行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</p><p>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式 的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</p><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p><h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><h4 id="开启方式-1"><a href="#开启方式-1" class="headerlink" title="开启方式"></a>开启方式</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/note/AOF.png" alt="AOF"></p><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</p><h4 id="1）使用AOF"><a href="#1）使用AOF" class="headerlink" title="1）使用AOF"></a>1）使用AOF</h4><p>开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名 通过appendfilename配置设置，默认文件名是appendonly.aof。保存路径同 RDB持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp1.png" alt="img"></p><h4 id="1）所有的写入命令会追加到aof-buf（缓冲区）中。"><a href="#1）所有的写入命令会追加到aof-buf（缓冲区）中。" class="headerlink" title="1）所有的写入命令会追加到aof_buf（缓冲区）中。"></a>1）所有的写入命令会追加到aof_buf（缓冲区）中。</h4><h4 id="2）AOF缓冲区根据对应的策略向硬盘做同步操作。"><a href="#2）AOF缓冲区根据对应的策略向硬盘做同步操作。" class="headerlink" title="2）AOF缓冲区根据对应的策略向硬盘做同步操作。"></a>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</h4><p>AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如 果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负 载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡</p><h4 id="3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。"><a href="#3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。" class="headerlink" title="3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。"></a>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</h4><p>重写后的AOF文件为什么可以变小？有如下原因：</p><p>1.进程内已经超时的数据不再写入文件。</p><p>2.旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保</p><p>留最终数据的写入命令。</p><p>3.多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢 出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</p><p>AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF 文件可以更快地被Redis加载</p><p>AOF重写过程可以手动触发和自动触发：</p><p>手动触发：直接调用bgrewriteaof命令。</p><p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p><p>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认 为64MB。</p><p>auto-aof-rewrite-percentage：代表当前AOF文件空间 （aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</p><p>自动触发时机=aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（aof_current_size-aof_base_size）/aof_base_size&gt;=auto-aof-rewritepercentage</p><p>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</p><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp2.png" alt="img"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。"><a href="#4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。" class="headerlink" title="4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。"></a>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</h4><p><img src= "/img/loading.gif" data-src="https://wangxs020202.gitee.io/images/me/webp3.png" alt="img"></p><p>流程说明：</p><p>1）AOF持久化开启且存在AOF文件时，优先加载AOF文件，打印如下日志：</p><p>* DB loaded from append only file: 5.841 seconds</p><p>2）AOF关闭或者AOF文件不存在时，加载RDB文件，打印如下日志：</p><p>* DB loaded from disk: 5.586 seconds</p><p>3）加载AOF/RDB文件成功后，Redis启动成功。</p><p>4）AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</p><p>重点回顾</p><p>1）Redis提供了两种持久化方式：RDB和AOF。</p><p>2）RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更 高，因此读取RDB恢复速度更快。由于每次生成RDB开销较大，无法做到实</p><p>时持久化，一般用于数据冷备和复制传输。</p><p>3）save命令会阻塞主线程不建议使用，bgsave命令通过fork操作创建子 进程生成RDB避免阻塞。</p><p>4）AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以 控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积。</p><p>5）AOF重写可以通过auto-aof-rewrite-min-size和auto-aof-rewritepercentage参数控制自动触发，也可以使用bgrewriteaof命令手动触发。</p><p>6）子进程执行期间使用copy-on-write机制与父进程共享内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</p><p>7）持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。</p><p>8）单机下部署多个实例时，为了防止出现多个子进程执行重写操作， 建议做隔离控制，避免CPU和IO资源竞争。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="总结 · 笔记" scheme="http://www.sirxs.cn/categories/%E6%80%BB%E7%BB%93-%C2%B7-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="http://www.sirxs.cn/tags/Redis/"/>
    
  </entry>
  
</feed>
